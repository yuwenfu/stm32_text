L 1 "lib\src\stm32f10x_nvic.c"
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_nvic.c
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file provides all the NVIC firmware functions.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_nvic.h"
L 1 ".\lib\inc\stm32f10x_nvic.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_nvic.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      NVIC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_NVIC_H
N#define __STM32F10x_NVIC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
L 1 ".\lib\inc\stm32f10x_map.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_map.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the peripheral register's definitions
N*                      and memory mapping.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_MAP_H
N#define __STM32F10x_MAP_H
N
N#ifndef EXT
N  #define EXT extern
N#endif /* EXT */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_conf.h"
L 1 ".\lib\inc\stm32f10x_conf.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_conf.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : Library configuration file.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
L 1 ".\lib\inc\stm32f10x_type.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_type.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the common data types used for the
N*                      STM32F10x firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TYPE_H
N#define __STM32F10x_TYPE_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
Ntypedef signed long  s32;
Ntypedef signed short s16;
Ntypedef signed char  s8;
N
Ntypedef signed long  const sc32;  /* Read Only */
Ntypedef signed short const sc16;  /* Read Only */
Ntypedef signed char  const sc8;   /* Read Only */
N
Ntypedef volatile signed long  vs32;
Ntypedef volatile signed short vs16;
Ntypedef volatile signed char  vs8;
N
Ntypedef volatile signed long  const vsc32;  /* Read Only */
Ntypedef volatile signed short const vsc16;  /* Read Only */
Ntypedef volatile signed char  const vsc8;   /* Read Only */
N
Ntypedef unsigned long  u32;
Ntypedef unsigned short u16;
Ntypedef unsigned char  u8;
N
Ntypedef unsigned long  const uc32;  /* Read Only */
Ntypedef unsigned short const uc16;  /* Read Only */
Ntypedef unsigned char  const uc8;   /* Read Only */
N
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
Ntypedef volatile unsigned char  vu8;
N
Ntypedef volatile unsigned long  const vuc32;  /* Read Only */
Ntypedef volatile unsigned short const vuc16;  /* Read Only */
Ntypedef volatile unsigned char  const vuc8;   /* Read Only */
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N#define U8_MAX     ((u8)255)
N#define S8_MAX     ((s8)127)
N#define S8_MIN     ((s8)-128)
N#define U16_MAX    ((u16)65535u)
N#define S16_MAX    ((s16)32767)
N#define S16_MIN    ((s16)-32768)
N#define U32_MAX    ((u32)4294967295uL)
N#define S32_MAX    ((s32)2147483647)
N#define S32_MIN    ((s32)-2147483648)
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_TYPE_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 24 ".\lib\inc\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
N   the "assert_param" macro in the firmware library code (see "Exported macro"
N   section below) */
N/* #define DEBUG    1*/
N
N/* Comment the line below to disable the specific peripheral inclusion */
N/************************************* ADC ************************************/
N#define _ADC
N#define _ADC1
N#define _ADC2
N#define _ADC3
N
N/************************************* BKP ************************************/
N#define _BKP 
N
N/************************************* CAN ************************************/
N#define _CAN
N
N/************************************* CRC ************************************/
N#define _CRC
N
N/************************************* DAC ************************************/
N#define _DAC
N
N/************************************* DBGMCU *********************************/
N#define _DBGMCU
N
N/************************************* DMA ************************************/
N#define _DMA
N#define _DMA1_Channel1
N#define _DMA1_Channel2
N#define _DMA1_Channel3
N#define _DMA1_Channel4
N#define _DMA1_Channel5
N#define _DMA1_Channel6
N#define _DMA1_Channel7
N#define _DMA2_Channel1
N#define _DMA2_Channel2
N#define _DMA2_Channel3
N#define _DMA2_Channel4
N#define _DMA2_Channel5
N
N/************************************* EXTI ***********************************/
N#define _EXTI
N
N/************************************* FLASH and Option Bytes *****************/
N#define _FLASH
N/* Uncomment the line below to enable FLASH program/erase/protections functions,
N   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
N   are enabled */
N #define _FLASH_PROG 
N
N/************************************* FSMC ***********************************/
N#define _FSMC
N
N/************************************* GPIO ***********************************/
N#define _GPIO
N#define _GPIOA
N#define _GPIOB
N#define _GPIOC
N#define _GPIOD
N#define _GPIOE
N#define _GPIOF
N#define _GPIOG
N#define _AFIO
N
N/************************************* I2C ************************************/
N#define _I2C
N#define _I2C1
N#define _I2C2
N
N/************************************* IWDG ***********************************/
N#define _IWDG
N
N/************************************* NVIC ***********************************/
N#define _NVIC
N
N/************************************* PWR ************************************/
N#define _PWR
N
N/************************************* RCC ************************************/
N#define _RCC
N
N/************************************* RTC ************************************/
N#define _RTC
N
N/************************************* SDIO ***********************************/
N#define _SDIO
N
N/************************************* SPI ************************************/
N#define _SPI
N#define _SPI1
N#define _SPI2
N#define _SPI3
N
N/************************************* SysTick ********************************/
N#define _SysTick
N
N/************************************* TIM1 ***********************************/
N#define _TIM1
N
N/************************************* TIM ************************************/
N#define _TIM
N#define _TIM2
N#define _TIM3
N#define _TIM4
N#define _TIM5
N#define _TIM6
N#define _TIM7
N#define _TIM8
N
N/************************************* USART **********************************/
N#define _USART
N#define _USART1
N#define _USART2
N#define _USART3
N#define _UART4
N#define _UART5
N
N/************************************* WWDG ***********************************/
N#define _WWDG
N
N/* In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application */
N#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  DEBUG
S/*******************************************************************************
S* Macro Name     : assert_param
S* Description    : The assert_param macro is used for function's parameters check.
S*                  It is used only if the library is compiled in DEBUG mode. 
S* Input          : - expr: If expr is false, it calls assert_failed function
S*                    which reports the name of the source file and the source
S*                    line number of the call that failed. 
S*                    If expr is true, it returns no value.
S* Return         : None
S*******************************************************************************/ 
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(u8* file, u32 line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* DEBUG */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 29 ".\lib\inc\stm32f10x_map.h" 2
N#include "stm32f10x_type.h"
N#include "cortexm3_macro.h"
L 1 ".\lib\inc\cortexm3_macro.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : cortexm3_macro.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : Header file for cortexm3_macro.s.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CORTEXM3_MACRO_H
N#define __CORTEXM3_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid __WFI(void);
Nvoid __WFE(void);
Nvoid __SEV(void);
Nvoid __ISB(void);
Nvoid __DSB(void);
Nvoid __DMB(void);
Nvoid __SVC(void);
Nu32 __MRS_CONTROL(void);
Nvoid __MSR_CONTROL(u32 Control);
Nu32 __MRS_PSP(void);
Nvoid __MSR_PSP(u32 TopOfProcessStack);
Nu32 __MRS_MSP(void);
Nvoid __MSR_MSP(u32 TopOfMainStack);
Nvoid __RESETPRIMASK(void);
Nvoid __SETPRIMASK(void);
Nu32 __READ_PRIMASK(void);
Nvoid __RESETFAULTMASK(void);
Nvoid __SETFAULTMASK(void);
Nu32 __READ_FAULTMASK(void);
Nvoid __BASEPRICONFIG(u32 NewPriority);
Nu32 __GetBASEPRI(void);
Nu16 __REV_HalfWord(u16 Data);
Nu32 __REV_Word(u32 Data);
N
N#endif /* __CORTEXM3_MACRO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 31 ".\lib\inc\stm32f10x_map.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/******************************************************************************/
N/*                         Peripheral registers structures                    */
N/******************************************************************************/
N
N/*------------------------ Analog to Digital Converter -----------------------*/
Ntypedef struct
N{
N  vu32 SR;	  // ADC状态寄存器 ；
N  vu32 CR1;	  // ADC控制寄存器1 ；
N  vu32 CR2;	  // ADC控制寄存器2 ；
N  vu32 SMPR1; // ADC采样时间寄存器1 ；
N  vu32 SMPR2; // ADC采样时间寄存器2 ；
N  vu32 JOFR1; // ADC注入通道偏移寄存器1 ；
N  vu32 JOFR2; // ADC注入通道偏移寄存器2 ；
N  vu32 JOFR3; // ADC注入通道偏移寄存器3 ；
N  vu32 JOFR4; // ADC注入通道偏移寄存器4 ；
N  vu32 HTR;	 // ADC看门狗高阈值寄存器 ；
N  vu32 LTR;	 // ADC看门狗低阈值寄存器 ；
N  vu32 SQR1; // ADC规则序列寄存器1 ；
N  vu32 SQR2; // ADC规则序列寄存器2 ；
N  vu32 SQR3; // ADC规则序列寄存器3 ；
N  vu32 JSQR; // ADC注入序列寄存器 ；
N  vu32 JDR1; // ADC规则数据寄存器1 ；
N  vu32 JDR2; // ADC规则数据寄存器2 ；
N  vu32 JDR3; // ADC规则数据寄存器3 ；
N  vu32 JDR4; // ADC规则数据寄存器4 ；
N  vu32 DR;	 // 规则数据寄存器 ;
N} ADC_TypeDef;
N
N/*------------------------ Backup Registers ----------------------------------*/
Ntypedef struct
N{
N  u32  RESERVED0;
N  vu16 DR1;		   // 数据后备寄存器 1 ； 
N  u16  RESERVED1;
N  vu16 DR2;		   // 数据后备寄存器 2 ；
N  u16  RESERVED2;
N  vu16 DR3;		   // 数据后备寄存器 3 ；
N  u16  RESERVED3;
N  vu16 DR4;		   // 数据后备寄存器 4 ；
N  u16  RESERVED4;
N  vu16 DR5;		   // 数据后备寄存器 5 ；
N  u16  RESERVED5;
N  vu16 DR6;		   // 数据后备寄存器 6 ；
N  u16  RESERVED6;
N  vu16 DR7;		   // 数据后备寄存器 7 ；
N  u16  RESERVED7;
N  vu16 DR8;		   // 数据后备寄存器 8 ；
N  u16  RESERVED8;
N  vu16 DR9;		   // 数据后备寄存器 9 ；
N  u16  RESERVED9;
N  vu16 DR10;	   // 数据后备寄存器 10 ；
N  u16  RESERVED10; 
N  vu16 RTCCR;	   // RTC时钟校准寄存器 ；
N  u16  RESERVED11;
N  vu16 CR;		   // 后备控制寄存器 ；
N  u16  RESERVED12;
N  vu16 CSR;		   // 后备控制状态寄存器 ；
N  u16  RESERVED13[5];
N  vu16 DR11;
N  u16  RESERVED14;
N  vu16 DR12;
N  u16  RESERVED15;
N  vu16 DR13;
N  u16  RESERVED16;
N  vu16 DR14;
N  u16  RESERVED17;
N  vu16 DR15;
N  u16  RESERVED18;
N  vu16 DR16;
N  u16  RESERVED19;
N  vu16 DR17;
N  u16  RESERVED20;
N  vu16 DR18;
N  u16  RESERVED21;
N  vu16 DR19;
N  u16  RESERVED22;
N  vu16 DR20;				  
N  u16  RESERVED23;
N  vu16 DR21;
N  u16  RESERVED24;
N  vu16 DR22;
N  u16  RESERVED25;
N  vu16 DR23;
N  u16  RESERVED26;
N  vu16 DR24;
N  u16  RESERVED27;
N  vu16 DR25;
N  u16  RESERVED28;
N  vu16 DR26;
N  u16  RESERVED29;
N  vu16 DR27;
N  u16  RESERVED30;
N  vu16 DR28;
N  u16  RESERVED31;
N  vu16 DR29;
N  u16  RESERVED32;
N  vu16 DR30;
N  u16  RESERVED33; 
N  vu16 DR31;
N  u16  RESERVED34;
N  vu16 DR32;
N  u16  RESERVED35;
N  vu16 DR33;
N  u16  RESERVED36;
N  vu16 DR34;
N  u16  RESERVED37;
N  vu16 DR35;
N  u16  RESERVED38;
N  vu16 DR36;
N  u16  RESERVED39;
N  vu16 DR37;
N  u16  RESERVED40;
N  vu16 DR38;
N  u16  RESERVED41;
N  vu16 DR39;
N  u16  RESERVED42;
N  vu16 DR40;
N  u16  RESERVED43;
N  vu16 DR41;
N  u16  RESERVED44;
N  vu16 DR42;
N  u16  RESERVED45;    
N} BKP_TypeDef;
N
N/*------------------------ Controller Area Network ---------------------------*/
Ntypedef struct
N{
N  vu32 TIR;
N  vu32 TDTR;
N  vu32 TDLR;
N  vu32 TDHR;
N} CAN_TxMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 RIR;
N  vu32 RDTR;
N  vu32 RDLR;
N  vu32 RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 FR1;
N  vu32 FR2;
N} CAN_FilterRegister_TypeDef;
N
Ntypedef struct
N{
N  vu32 MCR;
N  vu32 MSR;
N  vu32 TSR;
N  vu32 RF0R;
N  vu32 RF1R;
N  vu32 IER;
N  vu32 ESR;
N  vu32 BTR;
N  u32  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  u32  RESERVED1[12];
N  vu32 FMR;
N  vu32 FM1R;
N  u32  RESERVED2;
N  vu32 FS1R;
N  u32  RESERVED3;
N  vu32 FFA1R;
N  u32  RESERVED4;
N  vu32 FA1R;
N  u32  RESERVED5[8];
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N} CAN_TypeDef;
N
N/*------------------------ CRC calculation unit ------------------------------*/
Ntypedef struct
N{
N  vu32 DR;
N  vu8  IDR;
N  u8   RESERVED0;
N  u16  RESERVED1;
N  vu32 CR;
N} CRC_TypeDef;
N
N
N/*------------------------ Digital to Analog Converter -----------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 SWTRIGR;
N  vu32 DHR12R1;
N  vu32 DHR12L1;
N  vu32 DHR8R1;
N  vu32 DHR12R2;
N  vu32 DHR12L2;
N  vu32 DHR8R2;
N  vu32 DHR12RD;
N  vu32 DHR12LD;
N  vu32 DHR8RD;
N  vu32 DOR1;
N  vu32 DOR2;
N} DAC_TypeDef;
N
N/*------------------------ Debug MCU -----------------------------------------*/
Ntypedef struct
N{
N  vu32 IDCODE;
N  vu32 CR;	
N}DBGMCU_TypeDef;
N
N/*------------------------ DMA Controller ------------------------------------*/
Ntypedef struct
N{
N  vu32 CCR;	   // DMA通道X设置寄存器 ；
N  vu32 CNDTR;  // DMA通道X待传输数据数目寄存器 ；
N  vu32 CPAR;   // DMA通道X外设地址寄存器 ；
N  vu32 CMAR;   // DMA通道X内存地址寄存器 ；
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  vu32 ISR;	   // DMA中断状态寄存器 ；
N  vu32 IFCR;   // DMA中断标志位清除寄存器 ；
N} DMA_TypeDef;
N
N/*------------------------ External Interrupt/Event Controller ---------------*/
Ntypedef struct
N{
N  vu32 IMR;	  // 中断屏蔽寄存器 ；
N  vu32 EMR;	  // 事件屏蔽寄存器 ；
N  vu32 RTSR;  // 上升沿触发选择寄存器 ；
N  vu32 FTSR;  // 下降沿触发选择寄存器 ；
N  vu32 SWIER; // 软件中断事件寄存器 ；
N  vu32 PR;	  // 挂起寄存器 ；
N} EXTI_TypeDef;
N
N/*------------------------ FLASH and Option Bytes Registers ------------------*/
Ntypedef struct
N{
N  vu32 ACR;	    // FLASH访问控制寄存器 ；
N  vu32 KEYR;    // FPEC密钥寄存器 ；
N  vu32 OPTKEYR;	// 选择字节密钥寄存器 ；
N  vu32 SR;		// FLASH状态寄存器 ；
N  vu32 CR;		// FLASH控制寄存器 ；
N  vu32 AR;		// FLASH地址寄存器 ；
N  vu32 RESERVED; //
N  vu32 OBR;		// 选择字节和状态寄存器 ；
N  vu32 WRPR;	// 选择字节写保护寄存器 ；
N} FLASH_TypeDef;
N
Ntypedef struct
N{
N  vu16 RDP;	  // 读出选择字节 ；
N  vu16 USER;  // 用户选择字节 ；
N  vu16 Data0; // Data0选择字节 ；
N  vu16 Data1; // Data1选择字节 ；
N  vu16 WRP0;  // 写保护0选择字节 ；
N  vu16 WRP1;  // 写保护1选择字节
N  vu16 WRP2;  // 写保护2选择字节
N  vu16 WRP3;  // 写保护3选择字节
N} OB_TypeDef;
N
N/*------------------------ Flexible Static Memory Controller -----------------*/
Ntypedef struct
N{
N  vu32 BTCR[8];   
N} FSMC_Bank1_TypeDef; 
N
Ntypedef struct
N{
N  vu32 BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
Ntypedef struct
N{
N  vu32 PCR2;
N  vu32 SR2;
N  vu32 PMEM2;
N  vu32 PATT2;
N  u32  RESERVED0;   
N  vu32 ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
Ntypedef struct
N{
N  vu32 PCR3;
N  vu32 SR3;
N  vu32 PMEM3;
N  vu32 PATT3;
N  u32  RESERVED0;   
N  vu32 ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
Ntypedef struct
N{
N  vu32 PCR4;
N  vu32 SR4;
N  vu32 PMEM4;
N  vu32 PATT4;
N  vu32 PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/*------------------------ General Purpose and Alternate Function IO ---------*/
Ntypedef struct
N{
N  vu32 CRL;	  // 端口配置低寄存器 ；
N  vu32 CRH;	  // 端口配置高寄存器 ；
N  vu32 IDR;	  // 端口输入数据寄存器 ；
N  vu32 ODR;	  // 端口输出数据寄存器 ；
N  vu32 BSRR;  // 端口位设置/复位寄存器 ；
N  vu32 BRR;	  // 端口位复位寄存器 ；
N  vu32 LCKR;  // 端口配置锁定寄存器 ；
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  vu32 EVCR;     // 事件控制寄存器 ；
N  vu32 MAPR;	 // 复用重映射和调试I/O配置寄存器 ；
N  vu32 EXTICR[4];// 外部中断线路0-15配置寄存器 ；
N} AFIO_TypeDef;
N
N/*------------------------ Inter-integrated Circuit Interface ----------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 OAR1;
N  u16  RESERVED2;
N  vu16 OAR2;
N  u16  RESERVED3;
N  vu16 DR;
N  u16  RESERVED4;
N  vu16 SR1;
N  u16  RESERVED5;
N  vu16 SR2;
N  u16  RESERVED6;
N  vu16 CCR;
N  u16  RESERVED7;
N  vu16 TRISE;
N  u16  RESERVED8;
N} I2C_TypeDef;
N
N/*------------------------ Independent WATCHDOG ------------------------------*/
Ntypedef struct
N{
N  vu32 KR;	// IWDG键值寄存器 ；
N  vu32 PR;	// IWDG预分频寄存器 ；
N  vu32 RLR;	// IWDG重装载寄存器 ；
N  vu32 SR;	// IWDG状态寄存器 ；
N} IWDG_TypeDef;
N
N/*------------------------ Nested Vectored Interrupt Controller --------------*/
Ntypedef struct
N{
N  vu32 ISER[2];		  //
N  u32  RESERVED0[30]; //
N  vu32 ICER[2];		  //
N  u32  RSERVED1[30];  //
N  vu32 ISPR[2];		  //
N  u32  RESERVED2[30];
N  vu32 ICPR[2];
N  u32  RESERVED3[30];
N  vu32 IABR[2];
N  u32  RESERVED4[62];
N  vu32 IPR[15];
N} NVIC_TypeDef;
N
Ntypedef struct
N{
N  vuc32 CPUID;	 // CPU ID 基寄存器 ;
N  vu32 ICSR;	 //
N  vu32 VTOR;	 //
N  vu32 AIRCR;	 //
N  vu32 SCR;
N  vu32 CCR;
N  vu32 SHPR[3];
N  vu32 SHCSR;
N  vu32 CFSR;
N  vu32 HFSR;
N  vu32 DFSR;
N  vu32 MMFAR;
N  vu32 BFAR;
N  vu32 AFSR;
N} SCB_TypeDef;
N
N/*------------------------ Power Control -------------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CSR;
N} PWR_TypeDef;
N
N/*------------------------ Reset and Clock Control ---------------------------*/
Ntypedef struct
N{
N  vu32 CR;	     // 时钟控制寄存器 ；
N  vu32 CFGR;	 // 时钟配置寄存器 ；
N  vu32 CIR;		 // 时钟中断寄存器 ；
N  vu32 APB2RSTR; // APB2外设复位寄存器 ；
N  vu32 APB1RSTR; // APB1外设复位寄存器 ；
N  vu32 AHBENR;	 // AHB外设时钟使能寄存器 ；
N  vu32 APB2ENR;	 // APB2外设时钟使能寄存器 ；
N  vu32 APB1ENR;	 // APB1外设时钟使能寄存器 ；
N  vu32 BDCR;	 // 备份域控制寄存器 ；
N  vu32 CSR;		 // 控制/状态寄存器 ；
N} RCC_TypeDef;
N
N/*------------------------ Real-Time Clock -----------------------------------*/
Ntypedef struct
N{
N  vu16 CRH;	      // 控制寄存器高位 ；
N  u16  RESERVED0; //
N  vu16 CRL;		  // 控制寄存器低位 ；
N  u16  RESERVED1; //
N  vu16 PRLH;	  // 预分频装载寄存器高位 ；
N  u16  RESERVED2; //
N  vu16 PRLL;	  // 预分频装载寄存器低位 ；
N  u16  RESERVED3; //
N  vu16 DIVH;	  // 预分频分频因子寄存器高位 ；
N  u16  RESERVED4; //
N  vu16 DIVL;	  // 预分频分频因子寄存器低位 ；
N  u16  RESERVED5; //
N  vu16 CNTH;	  // 计数器寄存器高位 ；
N  u16  RESERVED6; //
N  vu16 CNTL;	  // 计数器寄存器低位 ；
N  u16  RESERVED7; //
N  vu16 ALRH;	  // 闹钟寄存器高位 ；
N  u16  RESERVED8; //
N  vu16 ALRL;	  // 闹钟寄存器低位 ；
N  u16  RESERVED9; //
N} RTC_TypeDef;
N
N/*------------------------ SD host Interface ---------------------------------*/
Ntypedef struct
N{
N  vu32 POWER;
N  vu32 CLKCR;
N  vu32 ARG;
N  vu32 CMD;
N  vuc32 RESPCMD;
N  vuc32 RESP1;
N  vuc32 RESP2;
N  vuc32 RESP3;
N  vuc32 RESP4;
N  vu32 DTIMER;
N  vu32 DLEN;
N  vu32 DCTRL;
N  vuc32 DCOUNT;
N  vuc32 STA;
N  vu32 ICR;
N  vu32 MASK;
N  u32  RESERVED0[2];
N  vuc32 FIFOCNT;
N  u32  RESERVED1[13];
N  vu32 FIFO;
N} SDIO_TypeDef;
N
N/*------------------------ Serial Peripheral Interface -----------------------*/
Ntypedef struct
N{
N  vu16 CR1;	      // SPI控制寄存器1 ；
N  u16  RESERVED0;
N  vu16 CR2;		  // SPI控制寄存器2 ；
N  u16  RESERVED1;
N  vu16 SR;		  // SPI状态寄存器 ；
N  u16  RESERVED2;
N  vu16 DR;		  // SPI数据寄存器 ；
N  u16  RESERVED3;
N  vu16 CRCPR;	  // SPI CRC多项式寄存器 ；
N  u16  RESERVED4;
N  vu16 RXCRCR;	  // SPI接收CRC寄存器 ；
N  u16  RESERVED5;
N  vu16 TXCRCR;	  // SPI发送CRC寄存器 ；
N  u16  RESERVED6;
N  vu16 I2SCFGR;
N  u16  RESERVED7;
N  vu16 I2SPR;
N  u16  RESERVED8;  
N} SPI_TypeDef;
N
N/*------------------------ SystemTick ----------------------------------------*/
Ntypedef struct
N{
N  vu32 CTRL;   // SysTick控制和状态寄存器 ；
N  vu32 LOAD;   // SysTick重装载值寄存器 ；
N  vu32 VAL;	   // SysTick当前值寄存器 ；
N  vuc32 CALIB; // SysTick校准值寄存器 ；
N} SysTick_TypeDef;
N
N/*------------------------ Advanced Control Timer ----------------------------*/
Ntypedef struct
N{
N  vu16 CR1;		  // 控制寄存器1 ；
N  u16  RESERVED0; 
N  vu16 CR2;		  // 控制寄存器2 ；
N  u16  RESERVED1; 
N  vu16 SMCR;	  // 从模式控制寄存器 ；
N  u16  RESERVED2;
N  vu16 DIER;	  // DMA/中断使能寄存器 ；
N  u16  RESERVED3;
N  vu16 SR;		  // 状态寄存器 ；
N  u16  RESERVED4;
N  vu16 EGR;		  // 事件产生寄存器 ；
N  u16  RESERVED5;
N  vu16 CCMR1;	  // 捕获/比较模式寄存器1 ；
N  u16  RESERVED6;
N  vu16 CCMR2;	  // 捕获/比较模式寄存器2 ；
N  u16  RESERVED7;
N  vu16 CCER;	  // 捕获/比较使能寄存器 ；
N  u16  RESERVED8;
N  vu16 CNT;		  // 计数器寄存器 ；
N  u16  RESERVED9;
N  vu16 PSC;		  // 预分频寄存器 ；
N  u16  RESERVED10;
N  vu16 ARR;		  // 自动重装载寄存器 ；
N  u16  RESERVED11;
N  vu16 RCR;		  // 周期计数寄存器 ；
N  u16  RESERVED12;
N  vu16 CCR1;	  // 捕获/比较寄存器1 ；
N  u16  RESERVED13;
N  vu16 CCR2;	  // 捕获/比较寄存器2 ；
N  u16  RESERVED14;
N  vu16 CCR3;	  // 捕获/比较寄存器3 ；
N  u16  RESERVED15;
N  vu16 CCR4;	  // 捕获/比较寄存器4 ；
N  u16  RESERVED16;
N  vu16 BDTR;	  // 刹车和死区寄存器 ；
N  u16  RESERVED17;
N  vu16 DCR;		  // DMA控制寄存器 ；
N  u16  RESERVED18;
N  vu16 DMAR;	  // 连续模式的DMA地址寄存器 ；
N  u16  RESERVED19;
N} TIM1_TypeDef;
N
N/*------------------------ TIM -----------------------------------------------*/
Ntypedef struct
N{
N  vu16 CR1;		// 控制寄存器1 ；
N  u16 RESERVED0;
N  vu16 CR2;	   // 控制寄存器2 ；
N  u16 RESERVED1;
N  vu16 SMCR;   // 从模式控制寄存器 ；
N  u16 RESERVED2;
N  vu16 DIER;   // DMA/中断使能寄存器 ；
N  u16 RESERVED3;
N  vu16 SR;		// 状态寄存器 ；
N  u16 RESERVED4;
N  vu16 EGR;		// 事件产生寄存器 ；
N  u16 RESERVED5;
N  vu16 CCMR1;  // 捕获/比较模式寄存器1 ；
N  u16 RESERVED6;
N  vu16 CCMR2;  // 捕获/比较模式寄存器2 ；
N  u16 RESERVED7;
N  vu16 CCER;  // 捕获/比较使能寄存器 ；
N  u16 RESERVED8;
N  vu16 CNT;	  // 计数器寄存器 ；
N  u16 RESERVED9;
N  vu16 PSC;	  // 预分频寄存器 ；
N  u16 RESERVED10;
N  vu16 ARR;	  // 自动重装载寄存器 ；
N  u16 RESERVED11[3];
N  vu16 CCR1;  // 捕获/比较寄存器1 ；
N  u16 RESERVED12;
N  vu16 CCR2;  // 捕获/比较寄存器2 ；
N  u16 RESERVED13;
N  vu16 CCR3;  // 捕获/比较寄存器3 ；
N  u16 RESERVED14;
N  vu16 CCR4;  // 捕获/比较寄存器4 ；
N  u16 RESERVED15[3];
N  vu16 DCR;	  // DMA控制寄存器 ；
N  u16 RESERVED16;
N  vu16 DMAR;  // 连续模式的DMA地址寄存器 ；
N  u16 RESERVED17; 
N 
N  vu16 RCR;		  // 周期计数寄存器 ；
N  vu16 BDTR;	  // 刹车和死区寄存器 ；
N} TIM_TypeDef;
N
N/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
Ntypedef struct
N{
N  vu16 SR;		 // USART状态寄存器 ；
N  u16  RESERVED0;
N  vu16 DR;		 // USART数据寄存器 ；
N  u16  RESERVED1;
N  vu16 BRR;		 // USART波特率寄存器 ；
N  u16  RESERVED2;
N  vu16 CR1;		 // USART控制寄存器1 ；
N  u16  RESERVED3;
N  vu16 CR2;		 // USART控制寄存器2 ；
N  u16  RESERVED4;
N  vu16 CR3;		 // USART控制寄存器3 ；
N  u16  RESERVED5;
N  vu16 GTPR;	 // USART保护时间和预分频寄存器 ；
N  u16  RESERVED6;
N} USART_TypeDef;
N
N/*------------------------ Window WATCHDOG -----------------------------------*/
Ntypedef struct
N{
N  vu32 CR;	// WWDG控制寄存器 ；
N  vu32 CFR;	// WWDG设置寄存器 ；
N  vu32 SR;  // WWDG状态寄存器 ；
N} WWDG_TypeDef;
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address in the alias region */
N#define PERIPH_BB_BASE        ((u32)0x42000000)
N#define SRAM_BB_BASE          ((u32)0x22000000)
N
N/* Peripheral and SRAM base address in the bit-band region */
N#define SRAM_BASE             ((u32)0x20000000)
N#define PERIPH_BASE           ((u32)0x40000000)
N
N/* FSMC registers base address */
N#define FSMC_R_BASE           ((u32)0xA0000000)
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N/* Flash registers base address */
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
N/* Flash Option Bytes base address */
N#define OB_BASE               ((u32)0x1FFFF800)
N
N/* FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE          ((u32)0xE0042000)
N
N/* System Control Space memory map */
N#define SCS_BASE              ((u32)0xE000E000)
N
N#define SysTick_BASE          (SCS_BASE + 0x0010)
N#define NVIC_BASE             (SCS_BASE + 0x0100)
N#define SCB_BASE              (SCS_BASE + 0x0D00)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/*------------------------ Non Debug Mode ------------------------------------*/
N#ifndef DEBUG
N#ifdef _TIM2
N  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#endif /*_TIM2 */
N
N#ifdef _TIM3
N  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#endif /*_TIM3 */
N
N#ifdef _TIM4
N  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#endif /*_TIM4 */
N
N#ifdef _TIM5
N  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#endif /*_TIM5 */
N
N#ifdef _TIM6
N  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#endif /*_TIM6 */
N
N#ifdef _TIM7
N  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#endif /*_TIM7 */
N
N#ifdef _RTC
N  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#endif /*_RTC */
N
N#ifdef _WWDG
N  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#endif /*_WWDG */
N
N#ifdef _IWDG
N  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#endif /*_IWDG */
N
N#ifdef _SPI2
N  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#endif /*_SPI2 */
N
N#ifdef _SPI3
N  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#endif /*_SPI3 */
N
N#ifdef _USART2
N  #define USART2              ((USART_TypeDef *) USART2_BASE)
N#endif /*_USART2 */
N
N#ifdef _USART3
N  #define USART3              ((USART_TypeDef *) USART3_BASE)
N#endif /*_USART3 */
N
N#ifdef _UART4
N  #define UART4              ((USART_TypeDef *) UART4_BASE)
N#endif /*_UART4 */
N
N#ifdef _UART5
N  #define UART5              ((USART_TypeDef *) UART5_BASE)
N#endif /*_USART5 */
N
N#ifdef _I2C1
N  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#endif /*_I2C1 */
N
N#ifdef _I2C2
N  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#endif /*_I2C2 */
N
N#ifdef _CAN
N  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#endif /*_CAN */
N
N#ifdef _BKP
N  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#endif /*_BKP */
N
N#ifdef _PWR
N  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#endif /*_PWR */
N
N#ifdef _DAC
N  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#endif /*_DAC */
N
N#ifdef _AFIO
N  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#endif /*_AFIO */
N
N#ifdef _EXTI
N  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#endif /*_EXTI */
N
N#ifdef _GPIOA
N  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#endif /*_GPIOA */
N
N#ifdef _GPIOB
N  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#endif /*_GPIOB */
N
N#ifdef _GPIOC
N  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#endif /*_GPIOC */
N
N#ifdef _GPIOD
N  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#endif /*_GPIOD */
N
N#ifdef _GPIOE
N  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#endif /*_GPIOE */
N
N#ifdef _GPIOF
N  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#endif /*_GPIOF */
N
N#ifdef _GPIOG
N  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#endif /*_GPIOG */
N
N#ifdef _ADC1
N  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#endif /*_ADC1 */
N
N#ifdef _ADC2
N  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#endif /*_ADC2 */
N
N#ifdef _TIM1
N  #define TIM1                ((TIM1_TypeDef *) TIM1_BASE)
N#endif /*_TIM1 */
N
N#ifdef _SPI1
N  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#endif /*_SPI1 */
N
N#ifdef _TIM8
N  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#endif /*_TIM8 */
N
N#ifdef _USART1
N  #define USART1              ((USART_TypeDef *) USART1_BASE)
N#endif /*_USART1 */
N
N#ifdef _ADC3
N  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#endif /*_ADC3 */
N
N#ifdef _SDIO
N  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#endif /*_SDIO */
N
N#ifdef _DMA
N  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#endif /*_DMA */
N
N#ifdef _DMA1_Channel1
N  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#endif /*_DMA1_Channel1 */
N
N#ifdef _DMA1_Channel2
N  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#endif /*_DMA1_Channel2 */
N
N#ifdef _DMA1_Channel3
N  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#endif /*_DMA1_Channel3 */
N
N#ifdef _DMA1_Channel4
N  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#endif /*_DMA1_Channel4 */
N
N#ifdef _DMA1_Channel5
N  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#endif /*_DMA1_Channel5 */
N
N#ifdef _DMA1_Channel6
N  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#endif /*_DMA1_Channel6 */
N
N#ifdef _DMA1_Channel7
N  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#endif /*_DMA1_Channel7 */
N
N#ifdef _DMA2_Channel1
N  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#endif /*_DMA2_Channel1 */
N
N#ifdef _DMA2_Channel2
N  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#endif /*_DMA2_Channel2 */
N
N#ifdef _DMA2_Channel3
N  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#endif /*_DMA2_Channel3 */
N
N#ifdef _DMA2_Channel4
N  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#endif /*_DMA2_Channel4 */
N
N#ifdef _DMA2_Channel5
N  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#endif /*_DMA2_Channel5 */
N
N#ifdef _RCC
N  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#endif /*_RCC */
N
N#ifdef _CRC
N  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#endif /*_CRC */
N
N#ifdef _FLASH
N  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N  #define OB                  ((OB_TypeDef *) OB_BASE) 
N#endif /*_FLASH */
N
N#ifdef _FSMC
N  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
N  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
N  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /*_FSMC */
N
N#ifdef _DBGMCU
N  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#endif /*_DBGMCU */
N
N#ifdef _SysTick
N  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
N#endif /*_SysTick */
N
N#ifdef _NVIC
N  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
N  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
N#endif /*_NVIC */
N
N/*------------------------ Debug Mode ----------------------------------------*/
N#else   /* DEBUG */
S#ifdef _TIM2
S  EXT TIM_TypeDef             *TIM2;
S#endif /*_TIM2 */
S
S#ifdef _TIM3
S  EXT TIM_TypeDef             *TIM3;
S#endif /*_TIM3 */
S
S#ifdef _TIM4
S  EXT TIM_TypeDef             *TIM4;
S#endif /*_TIM4 */
S
S#ifdef _TIM5
S  EXT TIM_TypeDef             *TIM5;
S#endif /*_TIM5 */
S
S#ifdef _TIM6
S  EXT TIM_TypeDef             *TIM6;
S#endif /*_TIM6 */
S
S#ifdef _TIM7
S  EXT TIM_TypeDef             *TIM7;
S#endif /*_TIM7 */
S
S#ifdef _RTC
S  EXT RTC_TypeDef             *RTC;
S#endif /*_RTC */
S
S#ifdef _WWDG
S  EXT WWDG_TypeDef            *WWDG;
S#endif /*_WWDG */
S
S#ifdef _IWDG
S  EXT IWDG_TypeDef            *IWDG;
S#endif /*_IWDG */
S
S#ifdef _SPI2
S  EXT SPI_TypeDef             *SPI2;
S#endif /*_SPI2 */
S
S#ifdef _SPI3
S  EXT SPI_TypeDef             *SPI3;
S#endif /*_SPI3 */
S
S#ifdef _USART2
S  EXT USART_TypeDef           *USART2;
S#endif /*_USART2 */
S
S#ifdef _USART3
S  EXT USART_TypeDef           *USART3;
S#endif /*_USART3 */
S
S#ifdef _UART4
S  EXT USART_TypeDef           *UART4;
S#endif /*_UART4 */
S
S#ifdef _UART5
S  EXT USART_TypeDef           *UART5;
S#endif /*_UART5 */
S
S#ifdef _I2C1
S  EXT I2C_TypeDef             *I2C1;
S#endif /*_I2C1 */
S
S#ifdef _I2C2
S  EXT I2C_TypeDef             *I2C2;
S#endif /*_I2C2 */
S
S#ifdef _CAN
S  EXT CAN_TypeDef             *CAN;
S#endif /*_CAN */
S
S#ifdef _BKP
S  EXT BKP_TypeDef             *BKP;
S#endif /*_BKP */
S
S#ifdef _PWR
S  EXT PWR_TypeDef             *PWR;
S#endif /*_PWR */
S
S#ifdef _DAC
S  EXT DAC_TypeDef             *DAC;
S#endif /*_DAC */
S
S#ifdef _AFIO
S  EXT AFIO_TypeDef            *AFIO;
S#endif /*_AFIO */
S
S#ifdef _EXTI
S  EXT EXTI_TypeDef            *EXTI;
S#endif /*_EXTI */
S
S#ifdef _GPIOA
S  EXT GPIO_TypeDef            *GPIOA;
S#endif /*_GPIOA */
S
S#ifdef _GPIOB
S  EXT GPIO_TypeDef            *GPIOB;
S#endif /*_GPIOB */
S
S#ifdef _GPIOC
S  EXT GPIO_TypeDef            *GPIOC;
S#endif /*_GPIOC */
S
S#ifdef _GPIOD
S  EXT GPIO_TypeDef            *GPIOD;
S#endif /*_GPIOD */
S
S#ifdef _GPIOE
S  EXT GPIO_TypeDef            *GPIOE;
S#endif /*_GPIOE */
S
S#ifdef _GPIOF
S  EXT GPIO_TypeDef            *GPIOF;
S#endif /*_GPIOF */
S
S#ifdef _GPIOG
S  EXT GPIO_TypeDef            *GPIOG;
S#endif /*_GPIOG */
S
S#ifdef _ADC1
S  EXT ADC_TypeDef             *ADC1;
S#endif /*_ADC1 */
S
S#ifdef _ADC2
S  EXT ADC_TypeDef             *ADC2;
S#endif /*_ADC2 */
S
S#ifdef _TIM1
S  EXT TIM_TypeDef             *TIM1;
S#endif /*_TIM1 */
S
S#ifdef _SPI1
S  EXT SPI_TypeDef             *SPI1;
S#endif /*_SPI1 */
S
S#ifdef _TIM8
S  EXT TIM_TypeDef             *TIM8;
S#endif /*_TIM8 */
S
S#ifdef _USART1
S  EXT USART_TypeDef           *USART1;
S#endif /*_USART1 */
S
S#ifdef _ADC3
S  EXT ADC_TypeDef             *ADC3;
S#endif /*_ADC3 */
S
S#ifdef _SDIO
S  EXT SDIO_TypeDef            *SDIO;
S#endif /*_SDIO */
S
S#ifdef _DMA
S  EXT DMA_TypeDef             *DMA1;
S  EXT DMA_TypeDef             *DMA2;
S#endif /*_DMA */
S
S#ifdef _DMA1_Channel1
S  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
S#endif /*_DMA1_Channel1 */
S
S#ifdef _DMA1_Channel2
S  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
S#endif /*_DMA1_Channel2 */
S
S#ifdef _DMA1_Channel3
S  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
S#endif /*_DMA1_Channel3 */
S
S#ifdef _DMA1_Channel4
S  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
S#endif /*_DMA1_Channel4 */
S
S#ifdef _DMA1_Channel5
S  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
S#endif /*_DMA1_Channel5 */
S
S#ifdef _DMA1_Channel6
S  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
S#endif /*_DMA1_Channel6 */
S
S#ifdef _DMA1_Channel7
S  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
S#endif /*_DMA1_Channel7 */
S
S#ifdef _DMA2_Channel1
S  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
S#endif /*_DMA2_Channel1 */
S
S#ifdef _DMA2_Channel2
S  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
S#endif /*_DMA2_Channel2 */
S
S#ifdef _DMA2_Channel3
S  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
S#endif /*_DMA2_Channel3 */
S
S#ifdef _DMA2_Channel4
S  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
S#endif /*_DMA2_Channel4 */
S
S#ifdef _DMA2_Channel5
S  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
S#endif /*_DMA2_Channel5 */
S
S#ifdef _RCC
S  EXT RCC_TypeDef             *RCC;
S#endif /*_RCC */
S
S#ifdef _CRC
S  EXT CRC_TypeDef             *CRC;
S#endif /*_CRC */
S
S#ifdef _FLASH
S  EXT FLASH_TypeDef            *FLASH;
S  EXT OB_TypeDef               *OB;  
S#endif /*_FLASH */
S
S#ifdef _FSMC
S  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
S  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
S  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
S  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
S  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
S#endif /*_FSMC */
S
S#ifdef _DBGMCU
S  EXT DBGMCU_TypeDef          *DBGMCU;
S#endif /*_DBGMCU */
S
S#ifdef _SysTick
S  EXT SysTick_TypeDef         *SysTick;
S#endif /*_SysTick */
S
S#ifdef _NVIC
S  EXT NVIC_TypeDef            *NVIC;
S  EXT SCB_TypeDef             *SCB;
S#endif /*_NVIC */
S
N#endif  /* DEBUG */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_MAP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 25 ".\lib\inc\stm32f10x_nvic.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* NVIC Init Structure definition */
Ntypedef struct
N{
N  u8 NVIC_IRQChannel;  // 用以使能或者失能指定的IRQ通道 ；
N  u8 NVIC_IRQChannelPreemptionPriority;	 // 设置了成员NVIC_IRQChannel中的先占优先级 ；
N  u8 NVIC_IRQChannelSubPriority;   // 设置了成员NVIC_IRQChannel中的从优先级 ；
N  FunctionalState NVIC_IRQChannelCmd; // 指定了在成员NVIC_IRQChannel中定义的IRQ通道被使能还是失能 ；
N} NVIC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* IRQ Channels --------------------------------------------------------------*/
N#define WWDG_IRQChannel              ((u8)0x00)  /* 窗口看门狗中断 */
N#define PVD_IRQChannel               ((u8)0x01)  /* PVD通过EXTI探测中断 */
N#define TAMPER_IRQChannel            ((u8)0x02)  /* 篡改中断 */
N#define RTC_IRQChannel               ((u8)0x03)  /* RTC全局中断 */
N#define FLASH_IRQChannel             ((u8)0x04)  /* FLASH全局中断 */
N#define RCC_IRQChannel               ((u8)0x05)  /* RCC全局中断 */
N#define EXTI0_IRQChannel             ((u8)0x06)  /* 外部中断线0中断 */
N#define EXTI1_IRQChannel             ((u8)0x07)  /* 外部中断线1中断 */
N#define EXTI2_IRQChannel             ((u8)0x08)  /* 外部中断线2中断 */
N#define EXTI3_IRQChannel             ((u8)0x09)  /* 外部中断线3中断 */
N#define EXTI4_IRQChannel             ((u8)0x0A)  /* 外部中断线4中断 */
N#define DMA1_Channel1_IRQChannel     ((u8)0x0B)  /* DMA通道1中断 */
N#define DMA1_Channel2_IRQChannel     ((u8)0x0C)  /* DMA通道2中断 */
N#define DMA1_Channel3_IRQChannel     ((u8)0x0D)  /* DMA通道3中断 */
N#define DMA1_Channel4_IRQChannel     ((u8)0x0E)  /* DMA通道4中断 */
N#define DMA1_Channel5_IRQChannel     ((u8)0x0F)  /* DMA通道5中断 */
N#define DMA1_Channel6_IRQChannel     ((u8)0x10)  /* DMA通道6中断 */
N#define DMA1_Channel7_IRQChannel     ((u8)0x11)  /* DMA通道7中断 */
N#define ADC1_2_IRQChannel            ((u8)0x12)  /* ADC全局中断 */
N#define USB_HP_CAN_TX_IRQChannel     ((u8)0x13)  /* USB高优先级或者CAN发送中断 */
N#define USB_LP_CAN_RX0_IRQChannel    ((u8)0x14)  /* USB低优先级或者CAN接收0中断 */
N#define CAN_RX1_IRQChannel           ((u8)0x15)  /* CAN接收1中断 */
N#define CAN_SCE_IRQChannel           ((u8)0x16)  /* CAN SCE中断 */
N#define EXTI9_5_IRQChannel           ((u8)0x17)  /* 外部中断线9-5中断 */
N#define TIM1_BRK_IRQChannel          ((u8)0x18)  /* TIM1 暂停中断 */
N#define TIM1_UP_IRQChannel           ((u8)0x19)  /* TIM1 刷新中断 */
N#define TIM1_TRG_COM_IRQChannel      ((u8)0x1A)  /* TIM1 触发和通讯中断 */
N#define TIM1_CC_IRQChannel           ((u8)0x1B)  /* TIM1 捕获比较中断 */
N#define TIM2_IRQChannel              ((u8)0x1C)  /* TIM2 全局中断 */
N#define TIM3_IRQChannel              ((u8)0x1D)  /* TIM3 全局中断 */
N#define TIM4_IRQChannel              ((u8)0x1E)  /* TIM4 全局中断 */
N#define I2C1_EV_IRQChannel           ((u8)0x1F)  /* I2C1 事件中断 */
N#define I2C1_ER_IRQChannel           ((u8)0x20)  /* I2C1 错误中断 */
N#define I2C2_EV_IRQChannel           ((u8)0x21)  /* I2C2 事件中断 */
N#define I2C2_ER_IRQChannel           ((u8)0x22)  /* I2C2 错误中断 */
N#define SPI1_IRQChannel              ((u8)0x23)  /* SPI1 全局中断 */
N#define SPI2_IRQChannel              ((u8)0x24)  /* SPI2 全局中断 */
N#define USART1_IRQChannel            ((u8)0x25)  /* USART1 全局中断 */
N#define USART2_IRQChannel            ((u8)0x26)  /* USART2 全局中断 */
N#define USART3_IRQChannel            ((u8)0x27)  /* USART3 全局中断 */
N#define EXTI15_10_IRQChannel         ((u8)0x28)  /* 外部中断线15-10中断 */
N#define RTCAlarm_IRQChannel          ((u8)0x29)  /* RTC闹钟通过EXTI线中断 */
N#define USBWakeUp_IRQChannel         ((u8)0x2A)  /* USB通过EXTI线从悬挂唤醒中断 */
N#define TIM8_BRK_IRQChannel          ((u8)0x2B)  /* TIM8 Break Interrupt */
N#define TIM8_UP_IRQChannel           ((u8)0x2C)  /* TIM8 Update Interrupt */
N#define TIM8_TRG_COM_IRQChannel      ((u8)0x2D)  /* TIM8 Trigger and Commutation Interrupt */
N#define TIM8_CC_IRQChannel           ((u8)0x2E)  /* TIM8 Capture Compare Interrupt */
N#define ADC3_IRQChannel              ((u8)0x2F)  /* ADC3 global Interrupt */
N#define FSMC_IRQChannel              ((u8)0x30)  /* FSMC global Interrupt */
N#define SDIO_IRQChannel              ((u8)0x31)  /* SDIO global Interrupt */
N#define TIM5_IRQChannel              ((u8)0x32)  /* TIM5 global Interrupt */
N#define SPI3_IRQChannel              ((u8)0x33)  /* SPI3 global Interrupt */
N#define UART4_IRQChannel             ((u8)0x34)  /* UART4 global Interrupt */
N#define UART5_IRQChannel             ((u8)0x35)  /* UART5 global Interrupt */
N#define TIM6_IRQChannel              ((u8)0x36)  /* TIM6 global Interrupt */
N#define TIM7_IRQChannel              ((u8)0x37)  /* TIM7 global Interrupt */
N#define DMA2_Channel1_IRQChannel     ((u8)0x38)  /* DMA2 Channel 1 global Interrupt */
N#define DMA2_Channel2_IRQChannel     ((u8)0x39)  /* DMA2 Channel 2 global Interrupt */
N#define DMA2_Channel3_IRQChannel     ((u8)0x3A)  /* DMA2 Channel 3 global Interrupt */
N#define DMA2_Channel4_5_IRQChannel   ((u8)0x3B)  /* DMA2 Channel 4 and DMA2 Channel 5 global Interrupt */
N
N
N#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) || \
N                                      ((CHANNEL) == PVD_IRQChannel) || \
N                                      ((CHANNEL) == TAMPER_IRQChannel) || \
N                                      ((CHANNEL) == RTC_IRQChannel) || \
N                                      ((CHANNEL) == FLASH_IRQChannel) || \
N                                      ((CHANNEL) == RCC_IRQChannel) || \
N                                      ((CHANNEL) == EXTI0_IRQChannel) || \
N                                      ((CHANNEL) == EXTI1_IRQChannel) || \
N                                      ((CHANNEL) == EXTI2_IRQChannel) || \
N                                      ((CHANNEL) == EXTI3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel5_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel6_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel7_IRQChannel) || \
N                                      ((CHANNEL) == ADC1_2_IRQChannel) || \
N                                      ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) || \
N                                      ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) || \
N                                      ((CHANNEL) == CAN_RX1_IRQChannel) || \
N                                      ((CHANNEL) == CAN_SCE_IRQChannel) || \
N                                      ((CHANNEL) == EXTI9_5_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_CC_IRQChannel) || \
N                                      ((CHANNEL) == TIM2_IRQChannel) || \
N                                      ((CHANNEL) == TIM3_IRQChannel) || \
N                                      ((CHANNEL) == TIM4_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_ER_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_ER_IRQChannel) || \
N                                      ((CHANNEL) == SPI1_IRQChannel) || \
N                                      ((CHANNEL) == SPI2_IRQChannel) || \
N                                      ((CHANNEL) == USART1_IRQChannel) || \
N                                      ((CHANNEL) == USART2_IRQChannel) || \
N                                      ((CHANNEL) == USART3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI15_10_IRQChannel) || \
N                                      ((CHANNEL) == RTCAlarm_IRQChannel) || \
N                                      ((CHANNEL) == USBWakeUp_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_CC_IRQChannel) || \
N                                      ((CHANNEL) == ADC3_IRQChannel) || \
N                                      ((CHANNEL) == FSMC_IRQChannel) || \
N                                      ((CHANNEL) == SDIO_IRQChannel) || \
N                                      ((CHANNEL) == TIM5_IRQChannel) || \
N                                      ((CHANNEL) == SPI3_IRQChannel) || \
N                                      ((CHANNEL) == UART4_IRQChannel) || \
N                                      ((CHANNEL) == UART5_IRQChannel) || \
N                                      ((CHANNEL) == TIM6_IRQChannel) || \
N                                      ((CHANNEL) == TIM7_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
X#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) ||                                       ((CHANNEL) == PVD_IRQChannel) ||                                       ((CHANNEL) == TAMPER_IRQChannel) ||                                       ((CHANNEL) == RTC_IRQChannel) ||                                       ((CHANNEL) == FLASH_IRQChannel) ||                                       ((CHANNEL) == RCC_IRQChannel) ||                                       ((CHANNEL) == EXTI0_IRQChannel) ||                                       ((CHANNEL) == EXTI1_IRQChannel) ||                                       ((CHANNEL) == EXTI2_IRQChannel) ||                                       ((CHANNEL) == EXTI3_IRQChannel) ||                                       ((CHANNEL) == EXTI4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel5_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel6_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel7_IRQChannel) ||                                       ((CHANNEL) == ADC1_2_IRQChannel) ||                                       ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) ||                                       ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) ||                                       ((CHANNEL) == CAN_RX1_IRQChannel) ||                                       ((CHANNEL) == CAN_SCE_IRQChannel) ||                                       ((CHANNEL) == EXTI9_5_IRQChannel) ||                                       ((CHANNEL) == TIM1_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM1_UP_IRQChannel) ||                                       ((CHANNEL) == TIM1_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM1_CC_IRQChannel) ||                                       ((CHANNEL) == TIM2_IRQChannel) ||                                       ((CHANNEL) == TIM3_IRQChannel) ||                                       ((CHANNEL) == TIM4_IRQChannel) ||                                       ((CHANNEL) == I2C1_EV_IRQChannel) ||                                       ((CHANNEL) == I2C1_ER_IRQChannel) ||                                       ((CHANNEL) == I2C2_EV_IRQChannel) ||                                       ((CHANNEL) == I2C2_ER_IRQChannel) ||                                       ((CHANNEL) == SPI1_IRQChannel) ||                                       ((CHANNEL) == SPI2_IRQChannel) ||                                       ((CHANNEL) == USART1_IRQChannel) ||                                       ((CHANNEL) == USART2_IRQChannel) ||                                       ((CHANNEL) == USART3_IRQChannel) ||                                       ((CHANNEL) == EXTI15_10_IRQChannel) ||                                       ((CHANNEL) == RTCAlarm_IRQChannel) ||                                       ((CHANNEL) == USBWakeUp_IRQChannel) ||                                       ((CHANNEL) == TIM8_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM8_UP_IRQChannel) ||                                       ((CHANNEL) == TIM8_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM8_CC_IRQChannel) ||                                       ((CHANNEL) == ADC3_IRQChannel) ||                                       ((CHANNEL) == FSMC_IRQChannel) ||                                       ((CHANNEL) == SDIO_IRQChannel) ||                                       ((CHANNEL) == TIM5_IRQChannel) ||                                       ((CHANNEL) == SPI3_IRQChannel) ||                                       ((CHANNEL) == UART4_IRQChannel) ||                                       ((CHANNEL) == UART5_IRQChannel) ||                                       ((CHANNEL) == TIM6_IRQChannel) ||                                       ((CHANNEL) == TIM7_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
N
N
N/* System Handlers -----------------------------------------------------------*/
N#define SystemHandler_NMI            ((u32)0x00001F) /* NMI Handler */
N#define SystemHandler_HardFault      ((u32)0x000000) /* 硬件错误Handler */
N#define SystemHandler_MemoryManage   ((u32)0x043430) /* 存储器管理Handler */
N#define SystemHandler_BusFault       ((u32)0x547931) /* 总线错误Handler */
N#define SystemHandler_UsageFault     ((u32)0x24C232) /* 使用错误Handler */
N#define SystemHandler_SVCall         ((u32)0x01FF40) /* SVCall Handler */
N#define SystemHandler_DebugMonitor   ((u32)0x0A0080) /* 除错监控Handler */
N#define SystemHandler_PSV            ((u32)0x02829C) /* PSV Handler */
N#define SystemHandler_SysTick        ((u32)0x02C39A) /* 系统滴答定时器Handler */
N
N#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                           ((HANDLER) == SystemHandler_BusFault) || \
N                                           ((HANDLER) == SystemHandler_UsageFault))
X#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                            ((HANDLER) == SystemHandler_BusFault) ||                                            ((HANDLER) == SystemHandler_UsageFault))
N
N#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                             ((HANDLER) == SystemHandler_BusFault) || \
N                                             ((HANDLER) == SystemHandler_UsageFault) || \
N                                             ((HANDLER) == SystemHandler_SVCall) || \
N                                             ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                             ((HANDLER) == SystemHandler_PSV) || \
N                                             ((HANDLER) == SystemHandler_SysTick))
X#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                              ((HANDLER) == SystemHandler_BusFault) ||                                              ((HANDLER) == SystemHandler_UsageFault) ||                                              ((HANDLER) == SystemHandler_SVCall) ||                                              ((HANDLER) == SystemHandler_DebugMonitor) ||                                              ((HANDLER) == SystemHandler_PSV) ||                                              ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                ((HANDLER) == SystemHandler_BusFault) || \
N                                                ((HANDLER) == SystemHandler_SVCall))
X#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                 ((HANDLER) == SystemHandler_BusFault) ||                                                 ((HANDLER) == SystemHandler_SVCall))
N
N#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) || \
N                                                ((HANDLER) == SystemHandler_PSV) || \
N                                                ((HANDLER) == SystemHandler_SysTick))
X#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) ||                                                 ((HANDLER) == SystemHandler_PSV) ||                                                 ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) || \
N                                          ((HANDLER) == SystemHandler_SysTick))
X#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) ||                                           ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                               ((HANDLER) == SystemHandler_BusFault) || \
N                                               ((HANDLER) == SystemHandler_UsageFault) || \
N                                               ((HANDLER) == SystemHandler_SVCall) || \
N                                               ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                               ((HANDLER) == SystemHandler_PSV) || \
N                                               ((HANDLER) == SystemHandler_SysTick))
X#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                ((HANDLER) == SystemHandler_BusFault) ||                                                ((HANDLER) == SystemHandler_UsageFault) ||                                                ((HANDLER) == SystemHandler_SVCall) ||                                                ((HANDLER) == SystemHandler_DebugMonitor) ||                                                ((HANDLER) == SystemHandler_PSV) ||                                                ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) || \
N                                                 ((HANDLER) == SystemHandler_MemoryManage) || \
N                                                 ((HANDLER) == SystemHandler_BusFault) || \
N                                                 ((HANDLER) == SystemHandler_UsageFault) || \
N                                                 ((HANDLER) == SystemHandler_DebugMonitor)) 
X#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) ||                                                  ((HANDLER) == SystemHandler_MemoryManage) ||                                                  ((HANDLER) == SystemHandler_BusFault) ||                                                  ((HANDLER) == SystemHandler_UsageFault) ||                                                  ((HANDLER) == SystemHandler_DebugMonitor)) 
N
N#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                  ((HANDLER) == SystemHandler_BusFault))
X#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                   ((HANDLER) == SystemHandler_BusFault))
N
N
N/* Vector Table Base ---------------------------------------------------------*/
N#define NVIC_VectTab_RAM             ((u32)0x20000000) // 向量表位于RAM	；
N#define NVIC_VectTab_FLASH           ((u32)0x08000000) // 向量表位于FLASH ；
N
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N
N/* System Low Power ----------------------------------------------------------*/
N#define NVIC_LP_SEVONPEND            ((u8)0x10)	 // 根据待处理请求唤醒 ；
N#define NVIC_LP_SLEEPDEEP            ((u8)0x04)	 // 深度睡眠使能 ；
N#define NVIC_LP_SLEEPONEXIT          ((u8)0x02)	 // 退出ISR后睡眠 ；
N
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N
N/* Preemption Priority Group -------------------------------------------------*/
N#define NVIC_PriorityGroup_0         ((u32)0x700) /* 先占优先级0位，从优先级4位 */
N#define NVIC_PriorityGroup_1         ((u32)0x600) /* 先占优先级1位，从优先级3位 */
N#define NVIC_PriorityGroup_2         ((u32)0x500) /* 先占优先级2位，从优先级2位 */
N#define NVIC_PriorityGroup_3         ((u32)0x400) /* 先占优先级3位，从优先级1位 */
N#define NVIC_PriorityGroup_4         ((u32)0x300) /* 先占优先级4位，从优先级0位 */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x0007FFFF)
N#define IS_NVIC_BASE_PRI(PRI)   ((PRI) < 0x10)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid NVIC_DeInit(void);
Nvoid NVIC_SCBDeInit(void);
Nvoid NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SETPRIMASK(void);
Nvoid NVIC_RESETPRIMASK(void);
Nvoid NVIC_SETFAULTMASK(void);
Nvoid NVIC_RESETFAULTMASK(void);
Nvoid NVIC_BASEPRICONFIG(u32 NewPriority);
Nu32 NVIC_GetBASEPRI(void);
Nu16 NVIC_GetCurrentPendingIRQChannel(void);
NITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel);
Nvoid NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nvoid NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nu16 NVIC_GetCurrentActiveHandler(void);
NITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel);
Nu32 NVIC_GetCPUID(void);
Nvoid NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset);
Nvoid NVIC_GenerateSystemReset(void);
Nvoid NVIC_GenerateCoreReset(void);
Nvoid NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState);
Nvoid NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState);
Nvoid NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
N                                      u8 SystemHandlerSubPriority);
NITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler);
Nvoid NVIC_SetSystemHandlerPendingBit(u32 SystemHandler);
Nvoid NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler);
NITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler);
Nu32 NVIC_GetFaultHandlerSources(u32 SystemHandler);
Nu32 NVIC_GetFaultAddress(u32 SystemHandler);
N
N#endif /* __STM32F10x_NVIC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 20 "lib\src\stm32f10x_nvic.c" 2
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N#define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
N
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N
N/*******************************************************************************
N* Function Name  : NVIC_DeInit
N* Description    : Deinitializes the NVIC peripheral registers to their default
N*                  reset values.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 将外设NVIC寄存器重设为缺省值 ；
N*******************************************************************************/
Nvoid NVIC_DeInit(void)
N{
N  u32 index = 0;
N  
N  NVIC->ICER[0] = 0xFFFFFFFF;
X  ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ICER[0] = 0xFFFFFFFF;
N  NVIC->ICER[1] = 0x0FFFFFFF;
X  ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ICER[1] = 0x0FFFFFFF;
N  NVIC->ICPR[0] = 0xFFFFFFFF;
X  ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ICPR[0] = 0xFFFFFFFF;
N  NVIC->ICPR[1] = 0x0FFFFFFF;
X  ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ICPR[1] = 0x0FFFFFFF;
N  
N  for(index = 0; index < 0x0F; index++)
N  {
N     NVIC->IPR[index] = 0x00000000;
X     ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->IPR[index] = 0x00000000;
N  } 
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SCBDeInit
N* Description    : Deinitializes the SCB peripheral registers to their default 
N*                  reset values.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 将外设SCB寄存器重设为缺省值 ；
N*******************************************************************************/
Nvoid NVIC_SCBDeInit(void)
N{
N  u32 index = 0x00;
N  
N  SCB->ICSR = 0x0A000000;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->ICSR = 0x0A000000;
N  SCB->VTOR = 0x00000000;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->VTOR = 0x00000000;
N  SCB->AIRCR = AIRCR_VECTKEY_MASK;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->AIRCR = ((u32)0x05FA0000);
N  SCB->SCR = 0x00000000;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SCR = 0x00000000;
N  SCB->CCR = 0x00000000;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->CCR = 0x00000000;
N  for(index = 0; index < 0x03; index++)
N  {
N     SCB->SHPR[index] = 0;
X     ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHPR[index] = 0;
N  }
N  SCB->SHCSR = 0x00000000;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHCSR = 0x00000000;
N  SCB->CFSR = 0xFFFFFFFF;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->CFSR = 0xFFFFFFFF;
N  SCB->HFSR = 0xFFFFFFFF;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->HFSR = 0xFFFFFFFF;
N  SCB->DFSR = 0xFFFFFFFF;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->DFSR = 0xFFFFFFFF;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_PriorityGroupConfig
N* Description    : Configures the priority grouping: pre-emption priority
N*                  and subpriority.
N* Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
N*                    length. This parameter can be one of the following values:
N*                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
N*                         4 bits for subpriority
N*                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
N*                         3 bits for subpriority
N*                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
N*                         2 bits for subpriority
N*                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
N*                         1 bits for subpriority
N*                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
N*                         0 bits for subpriority
N* Output         : None
N* Return         : None
N* 功能           : 设置优先级分组：先占优先级和从优先级 ；
N*******************************************************************************/
Nvoid NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
N{
N  /* Check the parameters */
N  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
X  ((void)0);
N  
N  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
N  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->AIRCR = ((u32)0x05FA0000) | NVIC_PriorityGroup;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_Init
N* Description    : Initializes the NVIC peripheral according to the specified
N*                  parameters in the NVIC_InitStruct.
N* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
N*                    that contains the configuration information for the
N*                    specified NVIC peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 ；
N*******************************************************************************/
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
N{
N  u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
N  u32 tmppre = 0, tmpsub = 0x0F;
N
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
X  ((void)0);
N  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
X  ((void)0);
N  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
X  ((void)0);  
N  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
X  ((void)0);
N    
N  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
N  {
N    /* Compute the Corresponding IRQ Priority --------------------------------*/    
N    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
X    tmppriority = (0x700 - (((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->AIRCR & (u32)0x700))>> 0x08;
N    tmppre = (0x4 - tmppriority);
N    tmpsub = tmpsub >> tmppriority;
N    
N    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
N    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
N
N    tmppriority = tmppriority << 0x04;
N    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
N    
N    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
X    tmpreg = ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
N    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
N    tmpreg &= ~tmpmask;
N    tmppriority &= tmpmask;  
N    tmpreg |= tmppriority;
N
N    NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
X    ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
N    
N    /* Enable the Selected IRQ Channels --------------------------------------*/
N    NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
X    ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
N      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
N  }
N  else
N  {
N    /* Disable the Selected IRQ Channels -------------------------------------*/
N    NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
X    ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
N      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_StructInit
N* Description    : Fills each NVIC_InitStruct member with its default value.
N* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
N*                    will be initialized.
N* Output         : None
N* Return         : None
N* 功能           : 把NVIC_InitStruct中的每一个参数按缺省值填入 ；
N*******************************************************************************/
Nvoid NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
N{
N  /* NVIC_InitStruct members default value */
N  NVIC_InitStruct->NVIC_IRQChannel = 0x00;
N  NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
N  NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
N  NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SETPRIMASK
N* Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 使能PRIMASK优先级：提升执行优先级至0 ；
N*******************************************************************************/
Nvoid NVIC_SETPRIMASK(void)
N{
N  __SETPRIMASK();
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_RESETPRIMASK
N* Description    : Disables the PRIMASK priority.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 失能PRIMASK优先级 ；
N*******************************************************************************/
Nvoid NVIC_RESETPRIMASK(void)
N{
N  __RESETPRIMASK();
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SETFAULTMASK
N* Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 使能FAULTMASK优先级：提升执行优先级至-1 ；
N*******************************************************************************/
Nvoid NVIC_SETFAULTMASK(void)
N{
N  __SETFAULTMASK();
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_RESETFAULTMASK
N* Description    : Disables the FAULTMASK priority.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 失能FAULTMASK优先级 ；
N*******************************************************************************/
Nvoid NVIC_RESETFAULTMASK(void)
N{
N  __RESETFAULTMASK();
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_BASEPRICONFIG
N* Description    : The execution priority can be changed from 15 (lowest 
N                   configurable priority) to 1. Writing a zero  value will disable 
N*                  the mask of execution priority.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 改变执行优先级从N（最低可设置优先级）提升至1 ；
N*******************************************************************************/
Nvoid NVIC_BASEPRICONFIG(u32 NewPriority)
N{
N  /* Check the parameters */
N  assert_param(IS_NVIC_BASE_PRI(NewPriority));
X  ((void)0);
N  
N  __BASEPRICONFIG(NewPriority << 0x04);
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetBASEPRI
N* Description    : Returns the BASEPRI mask value.
N* Input          : None
N* Output         : None
N* Return         : BASEPRI register value
N* 功能           : 返回BASEPRI屏蔽值 ；
N*******************************************************************************/
Nu32 NVIC_GetBASEPRI(void)
N{
N  return (__GetBASEPRI());
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetCurrentPendingIRQChannel
N* Description    : Returns the current pending IRQ channel identifier.
N* Input          : None
N* Output         : None
N* Return         : Pending IRQ Channel Identifier.
N* 功能           : 返回当前待处理IRQ标识符 ；
N*******************************************************************************/
Nu16 NVIC_GetCurrentPendingIRQChannel(void)
N{
N  return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
X  return ((u16)((((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->ICSR & (u32)0x003FF000) >> 0x0C));
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetIRQChannelPendingBitStatus
N* Description    : Checks whether the specified IRQ Channel pending bit is set
N*                  or not.
N* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
N* Output         : None
N* Return         : The new state of IRQ Channel pending bit(SET or RESET).
N* 功能           : 检查指定的IRQ通道待处理位设置与否 ；
N*******************************************************************************/
NITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
N{
N  ITStatus pendingirqstatus = RESET;
N  u32 tmp = 0x00;
N  
N  /* Check the parameters */
N  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
X  ((void)0);
N  
N  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
N
N  if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
X  if (((((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
N  {
N    pendingirqstatus = SET;
N  }
N  else
N  {
N    pendingirqstatus = RESET;
N  }
N  return pendingirqstatus;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SetIRQChannelPendingBit
N* Description    : Sets the NVICs interrupt pending bit.
N* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
N* Output         : None
N* Return         : None
N* 功能           : 设置指定的IRQ通道待处理位 ；
N*******************************************************************************/
Nvoid NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
N{
N  /* Check the parameters */
N  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
X  ((void)0);
N  
N  *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_ClearIRQChannelPendingBit
N* Description    : Clears the NVICs interrupt pending bit.
N* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
N* Output         : None
N* Return         : None
N* 功能           : 清除指定的IRQ通道待处理位 ；
N*******************************************************************************/
Nvoid NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
N{
N  /* Check the parameters */
N  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
X  ((void)0);
N  
N  NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
X  ((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetCurrentActiveHandler
N* Description    : Returns the current active Handler (IRQ Channel and
N*                  SystemHandler) identifier.
N* Input          : None
N* Output         : None
N* Return         : Active Handler Identifier.
N* 功能           : 返回当前活动的Handler（IRQ通道和系统Handler）的标识符 ；
N*******************************************************************************/
Nu16 NVIC_GetCurrentActiveHandler(void)
N{
N  return ((u16)(SCB->ICSR & (u32)0x3FF));
X  return ((u16)(((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->ICSR & (u32)0x3FF));
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetIRQChannelActiveBitStatus
N* Description    : Checks whether the specified IRQ Channel active bit is set
N*                  or not.
N* Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
N* Output         : None
N* Return         : The new state of IRQ Channel active bit(SET or RESET).
N* 功能           : 检查指定的IRQ通道活动位设置与否 ；
N*******************************************************************************/
NITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
N{
N  ITStatus activeirqstatus = RESET;
N  u32 tmp = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
X  ((void)0);
N  
N  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
N
N  if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
X  if (((((NVIC_TypeDef *) (((u32)0xE000E000) + 0x0100))->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
N  {
N    activeirqstatus = SET;
N  }
N  else
N  {
N    activeirqstatus = RESET;
N  }
N  return activeirqstatus;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetCPUID
N* Description    : Returns the ID number, the version number and the implementation
N*                  details of the Cortex-M3 core.
N* Input          : None
N* Output         : None
N* Return         : CPU ID.
N* 功能           : 返回ID号码，Cortex-M3内核的版本号和实现细节 ；
N*******************************************************************************/
Nu32 NVIC_GetCPUID(void)
N{
N  return (SCB->CPUID);
X  return (((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->CPUID);
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SetVectorTable
N* Description    : Sets the vector table location and Offset.
N* Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
N*                    FLASH memory.
N*                    This parameter can be one of the following values:
N*                       - NVIC_VectTab_RAM
N*                       - NVIC_VectTab_FLASH
N*                  - Offset: Vector Table base offset field. 
N*                            This value must be a multiple of 0x100.
N* Output         : None
N* Return         : None
N* 功能           : 设置向量表的位置和偏移 ；
N*******************************************************************************/
Nvoid NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
N{ 
N  /* Check the parameters */
N  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
X  ((void)0);
N  assert_param(IS_NVIC_OFFSET(Offset));  
X  ((void)0);  
N   
N  SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GenerateSystemReset
N* Description    : Generates a system reset.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 产生一个系统复位 ；
N*******************************************************************************/
Nvoid NVIC_GenerateSystemReset(void)
N{
N  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->AIRCR = ((u32)0x05FA0000) | (u32)0x04;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GenerateCoreReset
N* Description    : Generates a Core (Core + NVIC) reset.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 产生一个内核（内核+NVIC）复位 ；
N*******************************************************************************/
Nvoid NVIC_GenerateCoreReset(void)
N{
N  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->AIRCR = ((u32)0x05FA0000) | (u32)0x01;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SystemLPConfig
N* Description    : Selects the condition for the system to enter low power mode.
N* Input          : - LowPowerMode: Specifies the new mode for the system to enter
N*                    low power mode.
N*                    This parameter can be one of the following values:
N*                       - NVIC_LP_SEVONPEND
N*                       - NVIC_LP_SLEEPDEEP
N*                       - NVIC_LP_SLEEPONEXIT
N*                  - NewState: new state of LP condition.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 选择系统进入低功耗模式的条件 ；
N*******************************************************************************/
Nvoid NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_NVIC_LP(LowPowerMode));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));  
X  ((void)0);  
N  
N  if (NewState != DISABLE)
N  {
N    SCB->SCR |= LowPowerMode;
X    ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SCR |= LowPowerMode;
N  }
N  else
N  {
N    SCB->SCR &= (u32)(~(u32)LowPowerMode);
X    ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SCR &= (u32)(~(u32)LowPowerMode);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SystemHandlerConfig
N* Description    : Enables or disables the specified System Handlers.
N* Input          : - SystemHandler: specifies the system handler to be enabled
N*                    or disabled.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_MemoryManage
N*                       - SystemHandler_BusFault
N*                       - SystemHandler_UsageFault
N*                  - NewState: new state of  specified System Handlers.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能指定的系统Handler ；
N*******************************************************************************/
Nvoid NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
N{
N  u32 tmpreg = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
X  ((void)0); 
N  
N  tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
N
N  if (NewState != DISABLE)
N  {
N    SCB->SHCSR |= tmpreg;
X    ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHCSR |= tmpreg;
N  }
N  else
N  {
N    SCB->SHCSR &= ~tmpreg;
X    ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHCSR &= ~tmpreg;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SystemHandlerPriorityConfig
N* Description    : Configures the specified System Handlers priority.
N* Input          : - SystemHandler: specifies the system handler to be
N*                    enabled or disabled.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_MemoryManage
N*                       - SystemHandler_BusFault
N*                       - SystemHandler_UsageFault
N*                       - SystemHandler_SVCall
N*                       - SystemHandler_DebugMonitor
N*                       - SystemHandler_PSV
N*                       - SystemHandler_SysTick
N*                  - SystemHandlerPreemptionPriority: new priority group of the
N*                    specified system handlers.
N*                  - SystemHandlerSubPriority: new sub priority of the specified
N*                    system handlers.
N* Output         : None
N* Return         : None
N* 功能           : 设置指定的系统Handler优先级 ；
N*******************************************************************************/
Nvoid NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
N                                      u8 SystemHandlerSubPriority)
N{
N  u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
N  u32 tmppriority = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
X  ((void)0);  
N  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
X  ((void)0);
N    
N  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
X  tmppriority = (0x700 - (((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->AIRCR & (u32)0x700))>> 0x08;
N  tmp1 = (0x4 - tmppriority);
N  tmp2 = tmp2 >> tmppriority;
N    
N  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
N  tmppriority |=  SystemHandlerSubPriority & tmp2;
N
N  tmppriority = tmppriority << 0x04;
N  tmp1 = SystemHandler & (u32)0xC0;
N  tmp1 = tmp1 >> 0x06; 
N  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
N  tmppriority = tmppriority << (tmp2 * 0x08);
N  handlermask = (u32)0xFF << (tmp2 * 0x08);
N  
N  SCB->SHPR[tmp1] &= ~handlermask;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHPR[tmp1] &= ~handlermask;
N  SCB->SHPR[tmp1] |= tmppriority;
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHPR[tmp1] |= tmppriority;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetSystemHandlerPendingBitStatus
N* Description    : Checks whether the specified System handlers pending bit is
N*                  set or not.
N* Input          : - SystemHandler: specifies the system handler pending bit to
N*                    check.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_MemoryManage
N*                       - SystemHandler_BusFault
N*                       - SystemHandler_SVCall
N* Output         : None
N* Return         : The new state of System Handler pending bit(SET or RESET).
N* 功能           : 检查指定的系统Handler待处理位设置与否 ；
N*******************************************************************************/
NITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
N{
N  ITStatus bitstatus  = RESET;
N  u32 tmp = 0x00, tmppos = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  
N  tmppos = (SystemHandler >> 0x0A);
N  tmppos &= (u32)0x0F;
N
N  tmppos = (u32)0x01 << tmppos;
N
N  tmp = SCB->SHCSR & tmppos;
X  tmp = ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHCSR & tmppos;
N
N  if (tmp == tmppos)
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_SetSystemHandlerPendingBit
N* Description    : Sets System Handler pending bit.
N* Input          : - SystemHandler: specifies the system handler pending bit
N*                    to be set.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_NMI
N*                       - SystemHandler_PSV
N*                       - SystemHandler_SysTick
N* Output         : None
N* Return         : None
N* 功能           : 设置系统Handler待处理位 ；
N*******************************************************************************/
Nvoid NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
N{
N  u32 tmp = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  
N  /* Get the System Handler pending bit position */
N  tmp = SystemHandler & (u32)0x1F;
N  /* Set the corresponding System Handler pending bit */
N  SCB->ICSR |= ((u32)0x01 << tmp);
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->ICSR |= ((u32)0x01 << tmp);
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_ClearSystemHandlerPendingBit
N* Description    : Clears System Handler pending bit.
N* Input          : - SystemHandler: specifies the system handler pending bit to
N*                    be clear.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_PSV
N*                       - SystemHandler_SysTick
N* Output         : None
N* Return         : None
N* 功能           : 清除系统Handler待处理位 ；
N*******************************************************************************/
Nvoid NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
N{
N  u32 tmp = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  
N  /* Get the System Handler pending bit position */
N  tmp = SystemHandler & (u32)0x1F;
N  /* Clear the corresponding System Handler pending bit */
N  SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
X  ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->ICSR |= ((u32)0x01 << (tmp - 0x01));
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetSystemHandlerActiveBitStatus
N* Description    : Checks whether the specified System handlers active bit is
N*                  set or not.
N* Input          : - SystemHandler: specifies the system handler active bit to
N*                    check.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_MemoryManage
N*                       - SystemHandler_BusFault
N*                       - SystemHandler_UsageFault
N*                       - SystemHandler_SVCall
N*                       - SystemHandler_DebugMonitor
N*                       - SystemHandler_PSV
N*                       - SystemHandler_SysTick
N* Output         : None
N* Return         : The new state of System Handler active bit(SET or RESET).
N* 功能           : 检查系统Handler活动位设置与否 ；
N*******************************************************************************/
NITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
N{
N  ITStatus bitstatus  = RESET;
N
N  u32 tmp = 0x00, tmppos = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  
N  tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
N
N  tmppos = (u32)0x01 << tmppos;
N
N  tmp = SCB->SHCSR & tmppos;
X  tmp = ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->SHCSR & tmppos;
N
N  if (tmp == tmppos)
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetFaultHandlerSources
N* Description    : Returns the system fault handlers sources.
N* Input          : - SystemHandler: specifies the system handler to get its fault
N*                    sources.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_HardFault
N*                       - SystemHandler_MemoryManage
N*                       - SystemHandler_BusFault
N*                       - SystemHandler_UsageFault
N*                       - SystemHandler_DebugMonitor
N* Output         : None
N* Return         : Source of the fault handler.
N* 功能           : 返回表示出错的系统Handler源 ；
N*******************************************************************************/
Nu32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
N{
N  u32 faultsources = 0x00;
N  u32 tmpreg = 0x00, tmppos = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  
N  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
N  tmppos = (SystemHandler >> 0x14) & (u32)0x03;
N
N  if (tmpreg == 0x00)
N  {
N    faultsources = SCB->HFSR;
X    faultsources = ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->HFSR;
N  }
N  else if (tmpreg == 0x01)
N  {
N    faultsources = SCB->CFSR >> (tmppos * 0x08);
X    faultsources = ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->CFSR >> (tmppos * 0x08);
N    if (tmppos != 0x02)
N    {
N      faultsources &= (u32)0x0F;
N    }
N    else
N    {
N      faultsources &= (u32)0xFF;
N    }
N  }
N  else
N  {
N    faultsources = SCB->DFSR;
X    faultsources = ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->DFSR;
N  }
N  return faultsources;
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_GetFaultAddress
N* Description    : Returns the address of the location that generated a fault
N*                  handler.
N* Input          : - SystemHandler: specifies the system handler to get its
N*                    fault address.
N*                    This parameter can be one of the following values:
N*                       - SystemHandler_MemoryManage
N*                       - SystemHandler_BusFault
N* Output         : None
N* Return         : Fault address.
N* 功能           : 返回产生表示出错的系统Handler所在位置的地址 ；
N*******************************************************************************/
Nu32 NVIC_GetFaultAddress(u32 SystemHandler)
N{
N  u32 faultaddress = 0x00;
N  u32 tmp = 0x00;
N
N  /* Check the parameters */
N  assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
X  ((void)0);
N  
N  tmp = (SystemHandler >> 0x16) & (u32)0x01;
N
N  if (tmp == 0x00)
N  {
N    faultaddress = SCB->MMFAR;
X    faultaddress = ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->MMFAR;
N  }
N  else
N  {
N    faultaddress = SCB->BFAR;
X    faultaddress = ((SCB_TypeDef *) (((u32)0xE000E000) + 0x0D00))->BFAR;
N  }
N  return faultaddress;
N}
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
