; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_dac.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\stm32f10x_dac.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\lib\inc -I.\User -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 -DVECT_TAB_RAM --omf_browse=.\output\stm32f10x_dac.crf lib\src\stm32f10x_dac.c]
                          THUMB

                          AREA ||i.DAC_Cmd||, CODE, READONLY, ALIGN=2

                  DAC_Cmd PROC
;;;147    *******************************************************************************/
;;;148    void DAC_Cmd(u32 DAC_Channel, FunctionalState NewState)
000000  b139              CBZ      r1,|L1.18|
;;;149    {
;;;150      /* Check the parameters */
;;;151      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;152      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;153    
;;;154      if (NewState != DISABLE)
;;;155      {
;;;156        /* Enable the selected DAC channel */
;;;157        DAC->CR |= CR_EN_Set << DAC_Channel;
000002  4a08              LDR      r2,|L1.36|
000004  6812              LDR      r2,[r2,#0]
000006  2301              MOVS     r3,#1
000008  4083              LSLS     r3,r3,r0
00000a  431a              ORRS     r2,r2,r3
00000c  4b05              LDR      r3,|L1.36|
00000e  601a              STR      r2,[r3,#0]
000010  e006              B        |L1.32|
                  |L1.18|
;;;158      }
;;;159      else
;;;160      {
;;;161        /* Disable the selected DAC channel */
;;;162        DAC->CR &= ~(CR_EN_Set << DAC_Channel);
000012  4a04              LDR      r2,|L1.36|
000014  6812              LDR      r2,[r2,#0]
000016  2301              MOVS     r3,#1
000018  4083              LSLS     r3,r3,r0
00001a  439a              BICS     r2,r2,r3
00001c  4b01              LDR      r3,|L1.36|
00001e  601a              STR      r2,[r3,#0]
                  |L1.32|
;;;163      }
;;;164    }
000020  4770              BX       lr
;;;165    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x40007400

                          AREA ||i.DAC_DMACmd||, CODE, READONLY, ALIGN=2

                  DAC_DMACmd PROC
;;;177    *******************************************************************************/
;;;178    void DAC_DMACmd(u32 DAC_Channel, FunctionalState NewState)
000000  b141              CBZ      r1,|L2.20|
;;;179    {
;;;180      /* Check the parameters */
;;;181      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;182      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;183    
;;;184      if (NewState != DISABLE)
;;;185      {
;;;186        /* Enable the selected DAC channel DMA request */
;;;187        DAC->CR |= CR_DMAEN_Set << DAC_Channel;
000002  4a09              LDR      r2,|L2.40|
000004  6812              LDR      r2,[r2,#0]
000006  f44f5380          MOV      r3,#0x1000
00000a  4083              LSLS     r3,r3,r0
00000c  431a              ORRS     r2,r2,r3
00000e  4b06              LDR      r3,|L2.40|
000010  601a              STR      r2,[r3,#0]
000012  e007              B        |L2.36|
                  |L2.20|
;;;188      }
;;;189      else
;;;190      {
;;;191        /* Disable the selected DAC channel DMA request */
;;;192        DAC->CR &= ~(CR_DMAEN_Set << DAC_Channel);
000014  4a04              LDR      r2,|L2.40|
000016  6812              LDR      r2,[r2,#0]
000018  f44f5380          MOV      r3,#0x1000
00001c  4083              LSLS     r3,r3,r0
00001e  439a              BICS     r2,r2,r3
000020  4b01              LDR      r3,|L2.40|
000022  601a              STR      r2,[r3,#0]
                  |L2.36|
;;;193      }
;;;194    }
000024  4770              BX       lr
;;;195    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40007400

                          AREA ||i.DAC_DeInit||, CODE, READONLY, ALIGN=1

                  DAC_DeInit PROC
;;;60     *******************************************************************************/
;;;61     void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63       /* Enable DAC reset state */
;;;64       RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;65       /* Release DAC from reset state */
;;;66       RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5000          MOV      r0,#0x20000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;67     }
000014  bd10              POP      {r4,pc}
;;;68     
                          ENDP


                          AREA ||i.DAC_DualSoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_DualSoftwareTriggerCmd PROC
;;;234    *******************************************************************************/
;;;235    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L4.16|
;;;236    {
;;;237      /* Check the parameters */
;;;238      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;239    
;;;240      if (NewState != DISABLE)
;;;241      {
;;;242        /* Enable software trigger for both DAC channels */
;;;243        DAC->SWTRIGR |= DUAL_SWTRIG_Set ;
000002  4907              LDR      r1,|L4.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410103          ORR      r1,r1,#3
00000a  4a05              LDR      r2,|L4.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L4.28|
                  |L4.16|
;;;244      }
;;;245      else
;;;246      {
;;;247        /* Disable software trigger for both DAC channels */
;;;248        DAC->SWTRIGR &= DUAL_SWTRIG_Reset;
000010  4903              LDR      r1,|L4.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210103          BIC      r1,r1,#3
000018  4a01              LDR      r2,|L4.32|
00001a  6011              STR      r1,[r2,#0]
                  |L4.28|
;;;249      }
;;;250    }
00001c  4770              BX       lr
;;;251    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40007404

                          AREA ||i.DAC_GetDataOutputValue||, CODE, READONLY, ALIGN=2

                  DAC_GetDataOutputValue PROC
;;;381    *******************************************************************************/
;;;382    u16 DAC_GetDataOutputValue(u32 DAC_Channel)
000000  4601              MOV      r1,r0
;;;383    {
;;;384      /* Check the parameters */
;;;385      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;386    
;;;387      /* Returns the DAC channel data output register value */
;;;388      return (u16) (*(vu32*)(DAC_BASE + DOR_Offset + ((u32)DAC_Channel >> 2)));
000002  4a03              LDR      r2,|L5.16|
000004  eb020091          ADD      r0,r2,r1,LSR #2
000008  f8d0042c          LDR      r0,[r0,#0x42c]
00000c  b280              UXTH     r0,r0
;;;389    }
00000e  4770              BX       lr
;;;390    
                          ENDP

                  |L5.16|
                          DCD      0x40007000

                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;82     *******************************************************************************/
;;;83     void DAC_Init(u32 DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;84     {
;;;85       u32 tmpreg1 = 0, tmpreg2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;86     
;;;87       /* Check the DAC parameters */
;;;88       assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
;;;89       assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
;;;90       assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
;;;91       assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
;;;92     
;;;93     /*---------------------------- DAC CR Configuration --------------------------*/
;;;94       /* Get the DAC CR value */
;;;95       tmpreg1 = DAC->CR;
000006  4c0a              LDR      r4,|L6.48|
000008  6822              LDR      r2,[r4,#0]
;;;96       /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;97       tmpreg1 &= ~(CR_CLEAR_Mask << DAC_Channel);
00000a  f64074fe          MOV      r4,#0xffe
00000e  4084              LSLS     r4,r4,r0
000010  43a2              BICS     r2,r2,r4
;;;98       /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
;;;99          mask/amplitude for wave genration */
;;;100      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;101      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;102      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;103      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;104      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
000012  e9d14500          LDRD     r4,r5,[r1,#0]
000016  432c              ORRS     r4,r4,r5
000018  688d              LDR      r5,[r1,#8]
00001a  432c              ORRS     r4,r4,r5
00001c  68cd              LDR      r5,[r1,#0xc]
00001e  ea440305          ORR      r3,r4,r5
;;;105                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
;;;106      /* Calculate CR register value depending on DAC_Channel */
;;;107      tmpreg1 |= tmpreg2 << DAC_Channel;
000022  fa03f400          LSL      r4,r3,r0
000026  4322              ORRS     r2,r2,r4
;;;108      /* Write to DAC CR */
;;;109      DAC->CR = tmpreg1;
000028  4c01              LDR      r4,|L6.48|
00002a  6022              STR      r2,[r4,#0]
;;;110    }
00002c  bd30              POP      {r4,r5,pc}
;;;111    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel1Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel1Data PROC
;;;299    *******************************************************************************/
;;;300    void DAC_SetChannel1Data(u32 DAC_Align, u16 Data)
000000  4a02              LDR      r2,|L7.12|
;;;301    {
;;;302      /* Check the parameters */
;;;303      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;304      assert_param(IS_DAC_DATA(Data));
;;;305    
;;;306      /* Set the DAC channel1 selected data holding register */
;;;307      *((vu32 *)(DAC_BASE + DHR12R1_Offset + DAC_Align)) = (u32)Data;
000002  4402              ADD      r2,r2,r0
000004  f8c21408          STR      r1,[r2,#0x408]
;;;308    }
000008  4770              BX       lr
;;;309    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      0x40007000

                          AREA ||i.DAC_SetChannel2Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel2Data PROC
;;;322    *******************************************************************************/
;;;323    void DAC_SetChannel2Data(u32 DAC_Align, u16 Data)
000000  4a02              LDR      r2,|L8.12|
;;;324    {
;;;325      /* Check the parameters */
;;;326      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;327      assert_param(IS_DAC_DATA(Data));
;;;328    
;;;329      /* Set the DAC channel2 selected data holding register */
;;;330      *((vu32 *)(DAC_BASE + DHR12R2_Offset + DAC_Align)) = (u32)Data;
000002  4402              ADD      r2,r2,r0
000004  f8c21414          STR      r1,[r2,#0x414]
;;;331    }
000008  4770              BX       lr
;;;332    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      0x40007000

                          AREA ||i.DAC_SetDualChannelData||, CODE, READONLY, ALIGN=2

                  DAC_SetDualChannelData PROC
;;;348    *******************************************************************************/
;;;349    void DAC_SetDualChannelData(u32 DAC_Align, u16 Data2, u16 Data1)
000000  b510              PUSH     {r4,lr}
;;;350    {
;;;351      u32 Data = 0;
000002  2300              MOVS     r3,#0
;;;352    
;;;353      /* Check the parameters */
;;;354      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;355      assert_param(IS_DAC_DATA(Data1));
;;;356      assert_param(IS_DAC_DATA(Data2));
;;;357      
;;;358      /* Calculate and set dual DAC data holding register value */
;;;359      if (DAC_Align == DAC_Align_8b_R)
000004  2808              CMP      r0,#8
000006  d102              BNE      |L9.14|
;;;360      {
;;;361        Data = ((u32)Data2 << 8) | Data1; 
000008  ea422301          ORR      r3,r2,r1,LSL #8
00000c  e001              B        |L9.18|
                  |L9.14|
;;;362      }
;;;363      else
;;;364      {
;;;365        Data = ((u32)Data2 << 16) | Data1;
00000e  ea424301          ORR      r3,r2,r1,LSL #16
                  |L9.18|
;;;366      }
;;;367    
;;;368      /* Set the dual DAC selected data holding register */
;;;369      *((vu32 *)(DAC_BASE + DHR12RD_Offset + DAC_Align)) = Data;
000012  4c02              LDR      r4,|L9.28|
000014  4404              ADD      r4,r4,r0
000016  f8c43420          STR      r3,[r4,#0x420]
;;;370    }
00001a  bd10              POP      {r4,pc}
;;;371    
                          ENDP

                  |L9.28|
                          DCD      0x40007000

                          AREA ||i.DAC_SoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_SoftwareTriggerCmd PROC
;;;207    *******************************************************************************/
;;;208    void DAC_SoftwareTriggerCmd(u32 DAC_Channel, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;209    {
;;;210      /* Check the parameters */
;;;211      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;212      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;213    
;;;214      if (NewState != DISABLE)
000002  b141              CBZ      r1,|L10.22|
;;;215      {
;;;216        /* Enable software trigger for the selected DAC channel */
;;;217        DAC->SWTRIGR |= SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4);
000004  4a08              LDR      r2,|L10.40|
000006  6812              LDR      r2,[r2,#0]
000008  0904              LSRS     r4,r0,#4
00000a  2301              MOVS     r3,#1
00000c  40a3              LSLS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  4b05              LDR      r3,|L10.40|
000012  601a              STR      r2,[r3,#0]
000014  e007              B        |L10.38|
                  |L10.22|
;;;218      }
;;;219      else
;;;220      {
;;;221        /* Disable software trigger for the selected DAC channel */
;;;222        DAC->SWTRIGR &= ~(SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4));
000016  4a04              LDR      r2,|L10.40|
000018  6812              LDR      r2,[r2,#0]
00001a  0904              LSRS     r4,r0,#4
00001c  2301              MOVS     r3,#1
00001e  40a3              LSLS     r3,r3,r4
000020  439a              BICS     r2,r2,r3
000022  4b01              LDR      r3,|L10.40|
000024  601a              STR      r2,[r3,#0]
                  |L10.38|
;;;223      }
;;;224    }
000026  bd10              POP      {r4,pc}
;;;225    
                          ENDP

                  |L10.40|
                          DCD      0x40007404

                          AREA ||i.DAC_StructInit||, CODE, READONLY, ALIGN=1

                  DAC_StructInit PROC
;;;119    *******************************************************************************/
;;;120    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000000  2100              MOVS     r1,#0
;;;121    {
;;;122    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;123      /* Initialize the DAC_Trigger member */
;;;124      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
000002  6001              STR      r1,[r0,#0]
;;;125    
;;;126      /* Initialize the DAC_WaveGeneration member */
;;;127      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000004  6041              STR      r1,[r0,#4]
;;;128    
;;;129      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;130      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000006  6081              STR      r1,[r0,#8]
;;;131    
;;;132      /* Initialize the DAC_OutputBuffer member */
;;;133      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000008  60c1              STR      r1,[r0,#0xc]
;;;134    }
00000a  4770              BX       lr
;;;135    
                          ENDP


                          AREA ||i.DAC_WaveGenerationCmd||, CODE, READONLY, ALIGN=2

                  DAC_WaveGenerationCmd PROC
;;;267    *******************************************************************************/
;;;268    void DAC_WaveGenerationCmd(u32 DAC_Channel, u32 DAC_Wave, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;269    {
;;;270      /* Check the parameters */
;;;271      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;272      assert_param(IS_DAC_WAVE(DAC_Wave)); 
;;;273      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;274    
;;;275      if (NewState != DISABLE)
000002  b13a              CBZ      r2,|L12.20|
;;;276      {
;;;277        /* Enable the selected wave generation for the selected DAC channel */
;;;278        DAC->CR |= DAC_Wave << DAC_Channel;
000004  4b07              LDR      r3,|L12.36|
000006  681b              LDR      r3,[r3,#0]
000008  fa01f400          LSL      r4,r1,r0
00000c  4323              ORRS     r3,r3,r4
00000e  4c05              LDR      r4,|L12.36|
000010  6023              STR      r3,[r4,#0]
000012  e006              B        |L12.34|
                  |L12.20|
;;;279      }
;;;280      else
;;;281      {
;;;282        /* Disable the selected wave generation for the selected DAC channel */
;;;283        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000014  4b03              LDR      r3,|L12.36|
000016  681b              LDR      r3,[r3,#0]
000018  fa01f400          LSL      r4,r1,r0
00001c  43a3              BICS     r3,r3,r4
00001e  4c01              LDR      r4,|L12.36|
000020  6023              STR      r3,[r4,#0]
                  |L12.34|
;;;284      }
;;;285    }
000022  bd10              POP      {r4,pc}
;;;286    
                          ENDP

                  |L12.36|
                          DCD      0x40007400
