; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_flash.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\lib\inc -I.\User -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 -DVECT_TAB_RAM --omf_browse=.\output\stm32f10x_flash.crf lib\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;836    *******************************************************************************/
;;;837    void FLASH_ClearFlag(u16 FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;838    {
;;;839      /* Check the parameters */
;;;840      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;841      
;;;842      /* Clear the flags */
;;;843      FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;844    }
000004  4770              BX       lr
;;;845    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;471    *******************************************************************************/
;;;472    FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;473    {
000004  4604              MOV      r4,r0
;;;474      u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;475      
;;;476      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;477      
;;;478      /* Check the parameters */
;;;479      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;480      
;;;481      FLASH_Pages = (u32)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;482      WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;483      WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;484      WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;485      WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;486      
;;;487      /* Wait for last operation to be completed */
;;;488      status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;489      
;;;490      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13f              BNE      |L2.174|
;;;491      {
;;;492        /* Authorizes the small information block programming */
;;;493        FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;494        FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;495        FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;496    
;;;497        if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d005              BEQ      |L2.82|
;;;498        {
;;;499          OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;500          
;;;501          /* Wait for last operation to be completed */
;;;502          status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  200f              MOVS     r0,#0xf
00004c  f7fffffe          BL       FLASH_WaitForLastOperation
000050  4605              MOV      r5,r0
                  |L2.82|
;;;503        }
;;;504        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000052  2d04              CMP      r5,#4
000054  d108              BNE      |L2.104|
000056  2fff              CMP      r7,#0xff
000058  d006              BEQ      |L2.104|
;;;505        {
;;;506          OB->WRP1 = WRP1_Data;
00005a  4819              LDR      r0,|L2.192|
00005c  1c80              ADDS     r0,r0,#2
00005e  8007              STRH     r7,[r0,#0]
;;;507          
;;;508          /* Wait for last operation to be completed */
;;;509          status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  200f              MOVS     r0,#0xf
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
                  |L2.104|
;;;510        }
;;;511    
;;;512        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000068  2d04              CMP      r5,#4
00006a  d10a              BNE      |L2.130|
00006c  f1b80fff          CMP      r8,#0xff
000070  d007              BEQ      |L2.130|
;;;513        {
;;;514          OB->WRP2 = WRP2_Data;
000072  4813              LDR      r0,|L2.192|
000074  1d00              ADDS     r0,r0,#4
000076  f8a08000          STRH     r8,[r0,#0]
;;;515          
;;;516          /* Wait for last operation to be completed */
;;;517          status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  200f              MOVS     r0,#0xf
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;518        }
;;;519        
;;;520        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d10a              BNE      |L2.156|
000086  f1b90fff          CMP      r9,#0xff
00008a  d007              BEQ      |L2.156|
;;;521        {
;;;522          OB->WRP3 = WRP3_Data;
00008c  480c              LDR      r0,|L2.192|
00008e  1d80              ADDS     r0,r0,#6
000090  f8a09000          STRH     r9,[r0,#0]
;;;523         
;;;524          /* Wait for last operation to be completed */
;;;525          status = FLASH_WaitForLastOperation(ProgramTimeout);
000094  200f              MOVS     r0,#0xf
000096  f7fffffe          BL       FLASH_WaitForLastOperation
00009a  4605              MOV      r5,r0
                  |L2.156|
;;;526        }
;;;527              
;;;528        if(status != FLASH_BUSY)
00009c  2d01              CMP      r5,#1
00009e  d006              BEQ      |L2.174|
;;;529        {
;;;530          /* if the program operation is completed, disable the OPTPG Bit */
;;;531          FLASH->CR &= CR_OPTPG_Reset;
0000a0  4805              LDR      r0,|L2.184|
0000a2  6900              LDR      r0,[r0,#0x10]
0000a4  f64171ef          MOV      r1,#0x1fef
0000a8  4008              ANDS     r0,r0,r1
0000aa  4903              LDR      r1,|L2.184|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L2.174|
;;;532        }
;;;533      } 
;;;534      /* Return the write protection operation Status */
;;;535      return status;       
0000ae  4628              MOV      r0,r5
;;;536    }
0000b0  e8bd87f0          POP      {r4-r10,pc}
;;;537    
                          ENDP

                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;220    *******************************************************************************/
;;;221    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;222    {
;;;223      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;224    
;;;225      /* Wait for last operation to be completed */
;;;226      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;227      
;;;228      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d118              BNE      |L3.68|
;;;229      {
;;;230        /* if the previous operation is completed, proceed to erase all pages */
;;;231         FLASH->CR |= CR_MER_Set;
000012  480d              LDR      r0,|L3.72|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490b              LDR      r1,|L3.72|
00001c  6108              STR      r0,[r1,#0x10]
;;;232         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;233        
;;;234        /* Wait for last operation to be completed */
;;;235        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f64070ff          MOV      r0,#0xfff
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;236    
;;;237        if(status != FLASH_BUSY)
000032  2c01              CMP      r4,#1
000034  d006              BEQ      |L3.68|
;;;238        {
;;;239          /* if the erase operation is completed, disable the MER Bit */
;;;240          FLASH->CR &= CR_MER_Reset;
000036  4804              LDR      r0,|L3.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fb          MOV      r1,#0x1ffb
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L3.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L3.68|
;;;241        }
;;;242      }	   
;;;243      /* Return the Erase Status */
;;;244      return status;
000044  4620              MOV      r0,r4
;;;245    }
000046  bd10              POP      {r4,pc}
;;;246    
                          ENDP

                  |L3.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;256    *******************************************************************************/
;;;257    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;260      
;;;261      /* Wait for last operation to be completed */
;;;262      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;263    
;;;264      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d13b              BNE      |L4.138|
;;;265      {
;;;266        /* Authorize the small information block programming */
;;;267        FLASH->OPTKEYR = FLASH_KEY1;
000012  481f              LDR      r0,|L4.144|
000014  491f              LDR      r1,|L4.148|
000016  6088              STR      r0,[r1,#8]
;;;268        FLASH->OPTKEYR = FLASH_KEY2;
000018  481f              LDR      r0,|L4.152|
00001a  6088              STR      r0,[r1,#8]
;;;269        
;;;270        /* if the previous operation is completed, proceed to erase the option bytes */
;;;271        FLASH->CR |= CR_OPTER_Set;
00001c  4608              MOV      r0,r1
00001e  6900              LDR      r0,[r0,#0x10]
000020  f0400020          ORR      r0,r0,#0x20
000024  6108              STR      r0,[r1,#0x10]
;;;272        FLASH->CR |= CR_STRT_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400040          ORR      r0,r0,#0x40
00002e  6108              STR      r0,[r1,#0x10]
;;;273    
;;;274        /* Wait for last operation to be completed */
;;;275        status = FLASH_WaitForLastOperation(EraseTimeout);
000030  f64070ff          MOV      r0,#0xfff
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4604              MOV      r4,r0
;;;276        
;;;277        if(status == FLASH_COMPLETE)
00003a  2c04              CMP      r4,#4
00003c  d11c              BNE      |L4.120|
;;;278        {
;;;279          /* if the erase operation is completed, disable the OPTER Bit */
;;;280          FLASH->CR &= CR_OPTER_Reset;
00003e  4815              LDR      r0,|L4.148|
000040  6900              LDR      r0,[r0,#0x10]
000042  f64171df          MOV      r1,#0x1fdf
000046  4008              ANDS     r0,r0,r1
000048  4912              LDR      r1,|L4.148|
00004a  6108              STR      r0,[r1,#0x10]
;;;281           
;;;282          /* Enable the Option Bytes Programming operation */
;;;283          FLASH->CR |= CR_OPTPG_Set;
00004c  4608              MOV      r0,r1
00004e  6900              LDR      r0,[r0,#0x10]
000050  f0400010          ORR      r0,r0,#0x10
000054  6108              STR      r0,[r1,#0x10]
;;;284    
;;;285          /* Enable the readout access */
;;;286          OB->RDP= RDP_Key; 
000056  20a5              MOVS     r0,#0xa5
000058  4910              LDR      r1,|L4.156|
00005a  8008              STRH     r0,[r1,#0]
;;;287    
;;;288          /* Wait for last operation to be completed */
;;;289          status = FLASH_WaitForLastOperation(ProgramTimeout);
00005c  200f              MOVS     r0,#0xf
00005e  f7fffffe          BL       FLASH_WaitForLastOperation
000062  4604              MOV      r4,r0
;;;290     
;;;291          if(status != FLASH_BUSY)
000064  2c01              CMP      r4,#1
000066  d010              BEQ      |L4.138|
;;;292          {
;;;293            /* if the program operation is completed, disable the OPTPG Bit */
;;;294            FLASH->CR &= CR_OPTPG_Reset;
000068  480a              LDR      r0,|L4.148|
00006a  6900              LDR      r0,[r0,#0x10]
00006c  f64171ef          MOV      r1,#0x1fef
000070  4008              ANDS     r0,r0,r1
000072  4908              LDR      r1,|L4.148|
000074  6108              STR      r0,[r1,#0x10]
000076  e008              B        |L4.138|
                  |L4.120|
;;;295          }
;;;296        }
;;;297        else
;;;298        {
;;;299          if (status != FLASH_BUSY)
000078  2c01              CMP      r4,#1
00007a  d006              BEQ      |L4.138|
;;;300          {
;;;301            /* Disable the OPTPG Bit */
;;;302            FLASH->CR &= CR_OPTPG_Reset;
00007c  4805              LDR      r0,|L4.148|
00007e  6900              LDR      r0,[r0,#0x10]
000080  f64171ef          MOV      r1,#0x1fef
000084  4008              ANDS     r0,r0,r1
000086  4903              LDR      r1,|L4.148|
000088  6108              STR      r0,[r1,#0x10]
                  |L4.138|
;;;303          }
;;;304        }  
;;;305      }
;;;306      /* Return the erase status */
;;;307      return status;
00008a  4620              MOV      r0,r4
;;;308    }
00008c  bd10              POP      {r4,pc}
;;;309    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      0x45670123
                  |L4.148|
                          DCD      0x40022000
                  |L4.152|
                          DCD      0xcdef89ab
                  |L4.156|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;180    *******************************************************************************/
;;;181    FLASH_Status FLASH_ErasePage(u32 Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;182    {
000002  4605              MOV      r5,r0
;;;183      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;184    
;;;185      /* Check the parameters */
;;;186      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;187    
;;;188      /* Wait for last operation to be completed */
;;;189      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;190      
;;;191      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d119              BNE      |L5.72|
;;;192      { 
;;;193        /* if the previous operation is completed, proceed to erase the page */
;;;194        FLASH->CR|= CR_PER_Set;
000014  480d              LDR      r0,|L5.76|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490b              LDR      r1,|L5.76|
00001e  6108              STR      r0,[r1,#0x10]
;;;195        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6145              STR      r5,[r0,#0x14]
;;;196        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;197        
;;;198        /* Wait for last operation to be completed */
;;;199        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f64070ff          MOV      r0,#0xfff
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4604              MOV      r4,r0
;;;200    
;;;201        if(status != FLASH_BUSY)
000036  2c01              CMP      r4,#1
000038  d006              BEQ      |L5.72|
;;;202        {
;;;203          /* if the erase operation is completed, disable the PER Bit */
;;;204          FLASH->CR &= CR_PER_Reset;
00003a  4804              LDR      r0,|L5.76|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f64171fd          MOV      r1,#0x1ffd
000042  4008              ANDS     r0,r0,r1
000044  4901              LDR      r1,|L5.76|
000046  6108              STR      r0,[r1,#0x10]
                  |L5.72|
;;;205        }
;;;206      }
;;;207      /* Return the Erase Status */																					      
;;;208      return status;
000048  4620              MOV      r0,r4
;;;209    }
00004a  bd70              POP      {r4-r6,pc}
;;;210    
                          ENDP

                  |L5.76|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;790    *******************************************************************************/
;;;791    FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;792    {
;;;793      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;794    
;;;795      /* Check the parameters */
;;;796      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;797    
;;;798      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L6.26|
;;;799      {
;;;800        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
000008  4a08              LDR      r2,|L6.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0020201          AND      r2,r2,#1
000010  b10a              CBZ      r2,|L6.22|
;;;801        {
;;;802          bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L6.40|
                  |L6.22|
;;;803        }
;;;804        else
;;;805        {
;;;806          bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L6.40|
                  |L6.26|
;;;807        }
;;;808      }
;;;809      else
;;;810      {
;;;811       if((FLASH->SR & FLASH_FLAG) != (u32)RESET)
00001a  4a04              LDR      r2,|L6.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  400a              ANDS     r2,r2,r1
000020  b10a              CBZ      r2,|L6.38|
;;;812        {
;;;813          bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L6.40|
                  |L6.38|
;;;814        }
;;;815        else
;;;816        {
;;;817          bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L6.40|
;;;818        }
;;;819      }
;;;820      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;821      return bitstatus;
;;;822    }
000028  4770              BX       lr
;;;823    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;730    *******************************************************************************/
;;;731    FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;732    {
;;;733      FlagStatus bitstatus = RESET;
;;;734      
;;;735      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (u32)RESET)
000002  4904              LDR      r1,|L7.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0010120          AND      r1,r1,#0x20
00000a  b109              CBZ      r1,|L7.16|
;;;736      {
;;;737        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;738      }
;;;739      else
;;;740      {
;;;741        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;742      }
;;;743      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;744      return bitstatus; 
;;;745    }
000012  4770              BX       lr
;;;746    
                          ENDP

                  |L7.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;707    *******************************************************************************/
;;;708    FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;709    {
;;;710      FlagStatus readoutstatus = RESET;
;;;711    
;;;712      if ((FLASH->OBR & RDPRT_Mask) != (u32)RESET)
000002  4904              LDR      r1,|L8.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
00000a  b109              CBZ      r1,|L8.16|
;;;713      {
;;;714        readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L8.18|
                  |L8.16|
;;;715      }
;;;716      else
;;;717      {
;;;718        readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;719      }
;;;720      return readoutstatus;
;;;721    }
000012  4770              BX       lr
;;;722    
                          ENDP

                  |L8.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;854    *******************************************************************************/
;;;855    FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;856    {
;;;857      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;858      
;;;859      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L9.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L9.16|
;;;860      {
;;;861        flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L9.46|
                  |L9.16|
;;;862      }
;;;863      else 
;;;864      {  
;;;865        if(FLASH->SR & FLASH_FLAG_PGERR)
000010  4907              LDR      r1,|L9.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L9.30|
;;;866        { 
;;;867          flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L9.46|
                  |L9.30|
;;;868        }
;;;869        else 
;;;870        {
;;;871          if(FLASH->SR & FLASH_FLAG_WRPRTERR)
00001e  4904              LDR      r1,|L9.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L9.44|
;;;872          {
;;;873            flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L9.46|
                  |L9.44|
;;;874          }
;;;875          else
;;;876          {
;;;877            flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L9.46|
;;;878          }
;;;879        }
;;;880      }
;;;881      /* Return the Flash Status */
;;;882      return flashstatus;
;;;883    }
00002e  4770              BX       lr
;;;884    
                          ENDP

                  |L9.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;678    *******************************************************************************/
;;;679    u32 FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L10.8|
;;;680    {
;;;681      /* Return the User Option Byte */
;;;682      return (u32)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;683    }
000006  4770              BX       lr
;;;684    
                          ENDP

                  |L10.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;692    *******************************************************************************/
;;;693    u32 FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L11.8|
;;;694    {
;;;695      /* Return the Falsh write protection Register value */
;;;696      return (u32)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;697    }
000004  4770              BX       lr
;;;698    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;109    *******************************************************************************/
;;;110    void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L12.24|
;;;111    {
;;;112      /* Check the parameters */
;;;113      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;114      
;;;115      /* Enable or disable the Half cycle access */
;;;116      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L12.24|
00000a  6011              STR      r1,[r2,#0]
;;;117      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;118    }
000014  4770              BX       lr
;;;119    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;758    *******************************************************************************/
;;;759    void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L13.14|
;;;760    {
;;;761      /* Check the parameters */
;;;762      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;763      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;764    
;;;765      if(NewState != DISABLE)
;;;766      {
;;;767        /* Enable the interrupt sources */
;;;768        FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L13.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L13.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L13.24|
                  |L13.14|
;;;769      }
;;;770      else
;;;771      {
;;;772        /* Disable the interrupt sources */
;;;773        FLASH->CR &= ~(u32)FLASH_IT;
00000e  4a03              LDR      r2,|L13.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L13.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L13.24|
;;;774      }
;;;775    }
000018  4770              BX       lr
;;;776    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;164    *******************************************************************************/
;;;165    void FLASH_Lock(void)
000000  4803              LDR      r0,|L14.16|
;;;166    {
;;;167      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;168      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L14.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;169    }
00000c  4770              BX       lr
;;;170    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;130    *******************************************************************************/
;;;131    void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L15.24|
;;;132    {
;;;133      /* Check the parameters */
;;;134      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;135      
;;;136      /* Enable or disable the Prefetch Buffer */
;;;137      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L15.24|
00000a  6011              STR      r1,[r2,#0]
;;;138      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;139    }
000014  4770              BX       lr
;;;140    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;380    *******************************************************************************/
;;;381    FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;382    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;383      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;384    
;;;385      /* Check the parameters */
;;;386      assert_param(IS_FLASH_ADDRESS(Address));
;;;387    
;;;388      /* Wait for last operation to be completed */
;;;389      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;390      
;;;391      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d113              BNE      |L16.60|
;;;392      {
;;;393        /* if the previous operation is completed, proceed to program the new data */
;;;394        FLASH->CR |= CR_PG_Set;
000014  480a              LDR      r0,|L16.64|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4908              LDR      r1,|L16.64|
00001e  6108              STR      r0,[r1,#0x10]
;;;395      
;;;396        *(vu16*)Address = Data;
000020  802e              STRH     r6,[r5,#0]
;;;397        /* Wait for last operation to be completed */
;;;398        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;399    
;;;400        if(status != FLASH_BUSY)
00002a  2c01              CMP      r4,#1
00002c  d006              BEQ      |L16.60|
;;;401        {
;;;402          /* if the program operation is completed, disable the PG Bit */
;;;403          FLASH->CR &= CR_PG_Reset;
00002e  4804              LDR      r0,|L16.64|
000030  6900              LDR      r0,[r0,#0x10]
000032  f64171fe          MOV      r1,#0x1ffe
000036  4008              ANDS     r0,r0,r1
000038  4901              LDR      r1,|L16.64|
00003a  6108              STR      r0,[r1,#0x10]
                  |L16.60|
;;;404        }
;;;405      } 
;;;406      /* Return the Program Status */
;;;407      return status;
00003c  4620              MOV      r0,r4
;;;408    }
00003e  bd70              POP      {r4-r6,pc}
;;;409    
                          ENDP

                  |L16.64|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;421    *******************************************************************************/
;;;422    FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;423    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;424      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;425    
;;;426      /* Check the parameters */
;;;427      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;428    
;;;429      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;430    
;;;431      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L17.68|
;;;432      {
;;;433        /* Authorize the small information block programming */
;;;434        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L17.72|
000016  490d              LDR      r1,|L17.76|
000018  6088              STR      r0,[r1,#8]
;;;435        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L17.80|
00001c  6088              STR      r0,[r1,#8]
;;;436    
;;;437        /* Enables the Option Bytes Programming operation */
;;;438        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;439        *(vu16*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;440        
;;;441        /* Wait for last operation to be completed */
;;;442        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  200f              MOVS     r0,#0xf
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;443    
;;;444        if(status != FLASH_BUSY)
000032  2c01              CMP      r4,#1
000034  d006              BEQ      |L17.68|
;;;445        {
;;;446          /* if the program operation is completed, disable the OPTPG Bit */
;;;447          FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L17.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L17.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L17.68|
;;;448        }
;;;449      }    
;;;450      /* Return the Option Byte Data Program Status */
;;;451      return status;      
000044  4620              MOV      r0,r4
;;;452    }
000046  bd70              POP      {r4-r6,pc}
;;;453    
                          ENDP

                  |L17.72|
                          DCD      0x45670123
                  |L17.76|
                          DCD      0x40022000
                  |L17.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;320    *******************************************************************************/
;;;321    FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;322    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;323      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;324    
;;;325      /* Check the parameters */
;;;326      assert_param(IS_FLASH_ADDRESS(Address));
;;;327    
;;;328      /* Wait for last operation to be completed */
;;;329      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;330      
;;;331      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d125              BNE      |L18.96|
;;;332      {
;;;333        /* if the previous operation is completed, proceed to program the new first 
;;;334        half word */
;;;335        FLASH->CR |= CR_PG_Set;
000014  4813              LDR      r0,|L18.100|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4911              LDR      r1,|L18.100|
00001e  6108              STR      r0,[r1,#0x10]
;;;336      
;;;337        *(vu16*)Address = (u16)Data;
000020  802e              STRH     r6,[r5,#0]
;;;338    
;;;339        /* Wait for last operation to be completed */
;;;340        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;341     
;;;342        if(status == FLASH_COMPLETE)
00002a  2c04              CMP      r4,#4
00002c  d10f              BNE      |L18.78|
;;;343        {
;;;344          /* if the previous operation is completed, proceed to program the new second 
;;;345          half word */
;;;346          *(vu16*)(Address + 2) = Data >> 16;
00002e  0c30              LSRS     r0,r6,#16
000030  8068              STRH     r0,[r5,#2]
;;;347        
;;;348          /* Wait for last operation to be completed */
;;;349          status = FLASH_WaitForLastOperation(ProgramTimeout);
000032  200f              MOVS     r0,#0xf
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4604              MOV      r4,r0
;;;350            
;;;351          if(status != FLASH_BUSY)
00003a  2c01              CMP      r4,#1
00003c  d010              BEQ      |L18.96|
;;;352          {
;;;353            /* Disable the PG Bit */
;;;354            FLASH->CR &= CR_PG_Reset;
00003e  4809              LDR      r0,|L18.100|
000040  6900              LDR      r0,[r0,#0x10]
000042  f64171fe          MOV      r1,#0x1ffe
000046  4008              ANDS     r0,r0,r1
000048  4906              LDR      r1,|L18.100|
00004a  6108              STR      r0,[r1,#0x10]
00004c  e008              B        |L18.96|
                  |L18.78|
;;;355          }
;;;356        }
;;;357        else
;;;358        {
;;;359          if (status != FLASH_BUSY)
00004e  2c01              CMP      r4,#1
000050  d006              BEQ      |L18.96|
;;;360          {
;;;361            /* Disable the PG Bit */
;;;362            FLASH->CR &= CR_PG_Reset;
000052  4804              LDR      r0,|L18.100|
000054  6900              LDR      r0,[r0,#0x10]
000056  f64171fe          MOV      r1,#0x1ffe
00005a  4008              ANDS     r0,r0,r1
00005c  4901              LDR      r1,|L18.100|
00005e  6108              STR      r0,[r1,#0x10]
                  |L18.96|
;;;363          }
;;;364         }
;;;365      }
;;;366      /* Return the Program Status */
;;;367      return status;
000060  4620              MOV      r0,r4
;;;368    }
000062  bd70              POP      {r4-r6,pc}
;;;369    
                          ENDP

                  |L18.100|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;551    *******************************************************************************/
;;;552    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;553    {
000002  4605              MOV      r5,r0
;;;554      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;555    
;;;556      /* Check the parameters */
;;;557      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;558    
;;;559      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;560    
;;;561      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L19.152|
;;;562      {
;;;563        /* Authorizes the small information block programming */
;;;564        FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L19.156|
000016  4922              LDR      r1,|L19.160|
000018  6088              STR      r0,[r1,#8]
;;;565        FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L19.164|
00001c  6088              STR      r0,[r1,#8]
;;;566    
;;;567        FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;568        FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;569    
;;;570        /* Wait for last operation to be completed */
;;;571        status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f64070ff          MOV      r0,#0xfff
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;572    
;;;573        if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L19.134|
;;;574        {
;;;575          /* if the erase operation is completed, disable the OPTER Bit */
;;;576          FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L19.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L19.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;577    
;;;578          /* Enable the Option Bytes Programming operation */
;;;579          FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;580    
;;;581          if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L19.98|
;;;582          {
;;;583            OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L19.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L19.104|
                  |L19.98|
;;;584          }
;;;585          else
;;;586          {
;;;587            OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L19.168|
000066  8008              STRH     r0,[r1,#0]
                  |L19.104|
;;;588          }
;;;589    
;;;590          /* Wait for last operation to be completed */
;;;591          status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f64070ff          MOV      r0,#0xfff
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;592        
;;;593          if(status != FLASH_BUSY)
000072  2c01              CMP      r4,#1
000074  d010              BEQ      |L19.152|
;;;594          {
;;;595            /* if the program operation is completed, disable the OPTPG Bit */
;;;596            FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L19.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L19.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L19.152|
                  |L19.134|
;;;597          }
;;;598        }
;;;599        else 
;;;600        {
;;;601          if(status != FLASH_BUSY)
000086  2c01              CMP      r4,#1
000088  d006              BEQ      |L19.152|
;;;602          {
;;;603            /* Disable the OPTER Bit */
;;;604            FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L19.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L19.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L19.152|
;;;605          }
;;;606        }
;;;607      }
;;;608      /* Return the protection operation Status */
;;;609      return status;      
000098  4620              MOV      r0,r4
;;;610    }
00009a  bd70              POP      {r4-r6,pc}
;;;611      	
                          ENDP

                  |L19.156|
                          DCD      0x45670123
                  |L19.160|
                          DCD      0x40022000
                  |L19.164|
                          DCD      0xcdef89ab
                  |L19.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;88     *******************************************************************************/
;;;89     void FLASH_SetLatency(u32 FLASH_Latency)
000000  4905              LDR      r1,|L20.24|
;;;90     {
;;;91       /* Check the parameters */
;;;92       assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;93       
;;;94       /* Sets the Latency value */
;;;95       FLASH->ACR &= ACR_LATENCY_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0010138          AND      r1,r1,#0x38
000008  4a03              LDR      r2,|L20.24|
00000a  6011              STR      r1,[r2,#0]
;;;96       FLASH->ACR |= FLASH_Latency;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;97     }
000014  4770              BX       lr
;;;98     
                          ENDP

000016  0000              DCW      0x0000
                  |L20.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;149    *******************************************************************************/
;;;150    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L21.12|
;;;151    {
;;;152      /* Authorize the FPEC Access */
;;;153      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L21.16|
000004  6048              STR      r0,[r1,#4]
;;;154      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L21.20|
000008  6048              STR      r0,[r1,#4]
;;;155    }
00000a  4770              BX       lr
;;;156    
                          ENDP

                  |L21.12|
                          DCD      0x45670123
                  |L21.16|
                          DCD      0x40022000
                  |L21.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;633    *******************************************************************************/
;;;634    FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;635    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;636      FLASH_Status status = FLASH_COMPLETE; 
00000a  2404              MOVS     r4,#4
;;;637    
;;;638      /* Check the parameters */
;;;639      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;640      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;641      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;642    
;;;643      /* Authorize the small information block programming */
;;;644      FLASH->OPTKEYR = FLASH_KEY1;
00000c  4813              LDR      r0,|L22.92|
00000e  4914              LDR      r1,|L22.96|
000010  6088              STR      r0,[r1,#8]
;;;645      FLASH->OPTKEYR = FLASH_KEY2;
000012  4814              LDR      r0,|L22.100|
000014  6088              STR      r0,[r1,#8]
;;;646      
;;;647      /* Wait for last operation to be completed */
;;;648      status = FLASH_WaitForLastOperation(ProgramTimeout);
000016  200f              MOVS     r0,#0xf
000018  f7fffffe          BL       FLASH_WaitForLastOperation
00001c  4604              MOV      r4,r0
;;;649      
;;;650      if(status == FLASH_COMPLETE)
00001e  2c04              CMP      r4,#4
000020  d119              BNE      |L22.86|
;;;651      {  
;;;652        /* Enable the Option Bytes Programming operation */
;;;653        FLASH->CR |= CR_OPTPG_Set; 
000022  480f              LDR      r0,|L22.96|
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400010          ORR      r0,r0,#0x10
00002a  490d              LDR      r1,|L22.96|
00002c  6108              STR      r0,[r1,#0x10]
;;;654               
;;;655        OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
00002e  ea470005          ORR      r0,r7,r5
000032  4330              ORRS     r0,r0,r6
000034  f04000f8          ORR      r0,r0,#0xf8
000038  490b              LDR      r1,|L22.104|
00003a  8008              STRH     r0,[r1,#0]
;;;656      
;;;657        /* Wait for last operation to be completed */
;;;658        status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  200f              MOVS     r0,#0xf
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;659    
;;;660        if(status != FLASH_BUSY)
000044  2c01              CMP      r4,#1
000046  d006              BEQ      |L22.86|
;;;661        {
;;;662          /* if the program operation is completed, disable the OPTPG Bit */
;;;663          FLASH->CR &= CR_OPTPG_Reset;
000048  4805              LDR      r0,|L22.96|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171ef          MOV      r1,#0x1fef
000050  4008              ANDS     r0,r0,r1
000052  4903              LDR      r1,|L22.96|
000054  6108              STR      r0,[r1,#0x10]
                  |L22.86|
;;;664        }
;;;665      }    
;;;666      /* Return the Option Byte program Status */
;;;667      return status;
000056  4620              MOV      r0,r4
;;;668    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;669    
                          ENDP

                  |L22.92|
                          DCD      0x45670123
                  |L22.96|
                          DCD      0x40022000
                  |L22.100|
                          DCD      0xcdef89ab
                  |L22.104|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;894    *******************************************************************************/
;;;895    FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;896    { 
000002  4604              MOV      r4,r0
;;;897      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;898       
;;;899      /* Check for the Flash Status */
;;;900      status = FLASH_GetStatus();
000006  f7fffffe          BL       FLASH_GetStatus
00000a  4605              MOV      r5,r0
;;;901    
;;;902      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;903      while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e005              B        |L23.26|
                  |L23.14|
;;;904      {
;;;905        delay();
00000e  f7fffffe          BL       delay
;;;906        status = FLASH_GetStatus();
000012  f7fffffe          BL       FLASH_GetStatus
000016  4605              MOV      r5,r0
;;;907        Timeout--;
000018  1e64              SUBS     r4,r4,#1
                  |L23.26|
00001a  2d01              CMP      r5,#1                 ;903
00001c  d101              BNE      |L23.34|
00001e  2c00              CMP      r4,#0                 ;903
000020  d1f5              BNE      |L23.14|
                  |L23.34|
;;;908      }
;;;909    
;;;910      if(Timeout == 0x00 )
000022  b904              CBNZ     r4,|L23.38|
;;;911      {
;;;912        status = FLASH_TIMEOUT;
000024  2505              MOVS     r5,#5
                  |L23.38|
;;;913      }
;;;914    
;;;915      /* Return the operation status */
;;;916      return status;
000026  4628              MOV      r0,r5
;;;917    }
000028  bd70              POP      {r4-r6,pc}
;;;918    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;926    *******************************************************************************/
;;;927    static void delay(void)
000000  b508              PUSH     {r3,lr}
;;;928    {
;;;929      vu32 i = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;930    
;;;931      for(i = 0xFF; i != 0; i--)
000006  20ff              MOVS     r0,#0xff
000008  9000              STR      r0,[sp,#0]
00000a  e002              B        |L24.18|
                  |L24.12|
00000c  9800              LDR      r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  9000              STR      r0,[sp,#0]
                  |L24.18|
000012  9800              LDR      r0,[sp,#0]
000014  2800              CMP      r0,#0
000016  d1f9              BNE      |L24.12|
;;;932      {
;;;933      }
;;;934    }
000018  bd08              POP      {r3,pc}
;;;935    #endif
                          ENDP

