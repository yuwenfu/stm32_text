; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_usart.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\lib\inc -I.\User -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 -DVECT_TAB_RAM --omf_browse=.\output\stm32f10x_usart.crf lib\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;893    *******************************************************************************/
;;;894    void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
000000  43ca              MVNS     r2,r1
;;;895    {
;;;896      /* Check the parameters */
;;;897      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;898      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;899      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;900       
;;;901      USARTx->SR = (u16)~USART_FLAG;
000002  8002              STRH     r2,[r0,#0]
;;;902    }
000004  4770              BX       lr
;;;903    
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1002   *******************************************************************************/
;;;1003   void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
000000  b510              PUSH     {r4,lr}
;;;1004   {
;;;1005     u16 bitpos = 0x00, itmask = 0x00;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;1006   
;;;1007     /* Check the parameters */
;;;1008     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1009     assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;1010     assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;1011     
;;;1012     bitpos = USART_IT >> 0x08;
000006  120a              ASRS     r2,r1,#8
;;;1013   
;;;1014     itmask = (u16)((u16)0x01 << bitpos);
000008  2401              MOVS     r4,#1
00000a  4094              LSLS     r4,r4,r2
00000c  b2a3              UXTH     r3,r4
;;;1015     USARTx->SR = (u16)~itmask;
00000e  43dc              MVNS     r4,r3
000010  8004              STRH     r4,[r0,#0]
;;;1016   }
000012  bd10              POP      {r4,pc}
;;;1017   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;260    *******************************************************************************/
;;;261    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;262    {
000002  4602              MOV      r2,r0
;;;263      u32 tmpreg = 0x00;
000004  2000              MOVS     r0,#0
;;;264    
;;;265      /* Check the parameters */
;;;266      assert_param(IS_USART_123_PERIPH(USARTx));
;;;267      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;268      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;269      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;270      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
;;;271      
;;;272    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;273      tmpreg = USARTx->CR2;
000006  8a10              LDRH     r0,[r2,#0x10]
;;;274      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;275      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000008  f24f03ff          MOV      r3,#0xf0ff
00000c  4018              ANDS     r0,r0,r3
;;;276    
;;;277      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;278      /* Set CLKEN bit according to USART_Clock value */
;;;279      /* Set CPOL bit according to USART_CPOL value */
;;;280      /* Set CPHA bit according to USART_CPHA value */
;;;281      /* Set LBCL bit according to USART_LastBit value */
;;;282      tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00000e  880b              LDRH     r3,[r1,#0]
000010  884c              LDRH     r4,[r1,#2]
000012  4323              ORRS     r3,r3,r4
000014  888c              LDRH     r4,[r1,#4]
000016  4323              ORRS     r3,r3,r4
000018  88cc              LDRH     r4,[r1,#6]
00001a  4323              ORRS     r3,r3,r4
00001c  4318              ORRS     r0,r0,r3
;;;283                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;284    
;;;285      /* Write to USART CR2 */
;;;286      USARTx->CR2 = (u16)tmpreg;
00001e  8210              STRH     r0,[r2,#0x10]
;;;287    }
000020  bd10              POP      {r4,pc}
;;;288    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;297    *******************************************************************************/
;;;298    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;299    {
;;;300      /* USART_ClockInitStruct members default value */
;;;301      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;302      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;303      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;304      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;305    }
00000a  4770              BX       lr
;;;306    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;318    *******************************************************************************/
;;;319    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;320    {
;;;321      /* Check the parameters */
;;;322      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;323      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;324      
;;;325      if (NewState != DISABLE)
;;;326      {
;;;327        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;328        USARTx->CR1 |= CR1_UE_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f4425200          ORR      r2,r2,#0x2000
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;329      }
;;;330      else
;;;331      {
;;;332        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;333        USARTx->CR1 &= CR1_UE_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64d73ff          MOV      r3,#0xdfff
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L5.22|
;;;334      }
;;;335    }
000016  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;422    *******************************************************************************/
;;;423    void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
000000  b11a              CBZ      r2,|L6.10|
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;427      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;428      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;429    
;;;430      if (NewState != DISABLE)
;;;431      {
;;;432        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;433           DMAR bits in the USART CR3 register */
;;;434        USARTx->CR3 |= USART_DMAReq;
000002  8a83              LDRH     r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  8283              STRH     r3,[r0,#0x14]
000008  e002              B        |L6.16|
                  |L6.10|
;;;435      }
;;;436      else
;;;437      {
;;;438        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;439           DMAR bits in the USART CR3 register */
;;;440        USARTx->CR3 &= (u16)~USART_DMAReq;
00000a  8a83              LDRH     r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  8283              STRH     r3,[r0,#0x14]
                  |L6.16|
;;;441      }
;;;442    }
000010  4770              BX       lr
;;;443    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;92     *******************************************************************************/
;;;93     void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;94     {
000002  4604              MOV      r4,r0
;;;95       /* Check the parameters */
;;;96       assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;97     
;;;98       switch (*(u32*)&USARTx)
000004  4923              LDR      r1,|L7.148|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d02b              BEQ      |L7.100|
00000c  dc06              BGT      |L7.28|
00000e  4822              LDR      r0,|L7.152|
000010  4420              ADD      r0,r0,r4
000012  b198              CBZ      r0,|L7.60|
000014  f5b06f80          CMP      r0,#0x400
000018  d138              BNE      |L7.140|
00001a  e019              B        |L7.80|
                  |L7.28|
00001c  f5b06f80          CMP      r0,#0x400
000020  d02a              BEQ      |L7.120|
000022  f5b04f6c          CMP      r0,#0xec00
000026  d131              BNE      |L7.140|
;;;99       {
;;;100        case USART1_BASE:
;;;101          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000028  2101              MOVS     r1,#1
00002a  0388              LSLS     r0,r1,#14
00002c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;102          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000030  2100              MOVS     r1,#0
000032  f44f4080          MOV      r0,#0x4000
000036  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;103          break;
00003a  e028              B        |L7.142|
                  |L7.60|
;;;104    
;;;105        case USART2_BASE:
;;;106          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  0448              LSLS     r0,r1,#17
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;107          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000044  2100              MOVS     r1,#0
000046  f44f3000          MOV      r0,#0x20000
00004a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;108          break;
00004e  e01e              B        |L7.142|
                  |L7.80|
;;;109    
;;;110        case USART3_BASE:
;;;111          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000050  2101              MOVS     r1,#1
000052  0488              LSLS     r0,r1,#18
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;112          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000058  2100              MOVS     r1,#0
00005a  f44f2080          MOV      r0,#0x40000
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;113          break;
000062  e014              B        |L7.142|
                  |L7.100|
;;;114        
;;;115        case UART4_BASE:
;;;116          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000064  2101              MOVS     r1,#1
000066  04c8              LSLS     r0,r1,#19
000068  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;117          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00006c  2100              MOVS     r1,#0
00006e  f44f2000          MOV      r0,#0x80000
000072  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;118          break;
000076  e00a              B        |L7.142|
                  |L7.120|
;;;119        
;;;120        case UART5_BASE:
;;;121          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000078  2101              MOVS     r1,#1
00007a  0508              LSLS     r0,r1,#20
00007c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;122          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000080  2100              MOVS     r1,#0
000082  f44f1080          MOV      r0,#0x100000
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;123          break;            
00008a  e000              B        |L7.142|
                  |L7.140|
;;;124    
;;;125        default:
;;;126          break;
00008c  bf00              NOP      
                  |L7.142|
00008e  bf00              NOP                            ;103
;;;127      }
;;;128    }
000090  bd10              POP      {r4,pc}
;;;129    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      0x40004c00
                  |L7.152|
                          DCD      0xbfffbc00

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;846    *******************************************************************************/
;;;847    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
000000  4602              MOV      r2,r0
;;;848    {
;;;849      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;850    
;;;851      /* Check the parameters */
;;;852      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;853      assert_param(IS_USART_FLAG(USART_FLAG));
;;;854      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;855    
;;;856      if ((USARTx->SR & USART_FLAG) != (u16)RESET)
000004  8813              LDRH     r3,[r2,#0]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L8.14|
;;;857      {
;;;858        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L8.16|
                  |L8.14|
;;;859      }
;;;860      else
;;;861      {
;;;862        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;863      }
;;;864      return bitstatus;
;;;865    }
000010  4770              BX       lr
;;;866    
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;927    *******************************************************************************/
;;;928    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;929    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;930      u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000006  2400              MOVS     r4,#0
000008  2100              MOVS     r1,#0
00000a  2500              MOVS     r5,#0
;;;931      ITStatus bitstatus = RESET;
00000c  2000              MOVS     r0,#0
;;;932    
;;;933      /* Check the parameters */
;;;934      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;935      assert_param(IS_USART_IT(USART_IT));
;;;936      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
;;;937      
;;;938      /* Get the USART register index */
;;;939      usartreg = (((u8)USART_IT) >> 0x05);
00000e  f3c31542          UBFX     r5,r3,#5,#3
;;;940    
;;;941      /* Get the interrupt position */
;;;942      itmask = USART_IT & IT_Mask;
000012  f003011f          AND      r1,r3,#0x1f
;;;943    
;;;944      itmask = (u32)0x01 << itmask;
000016  2601              MOVS     r6,#1
000018  fa06f101          LSL      r1,r6,r1
;;;945      
;;;946      if (usartreg == 0x01) /* The IT  is in CR1 register */
00001c  2d01              CMP      r5,#1
00001e  d102              BNE      |L9.38|
;;;947      {
;;;948        itmask &= USARTx->CR1;
000020  8996              LDRH     r6,[r2,#0xc]
000022  4031              ANDS     r1,r1,r6
000024  e006              B        |L9.52|
                  |L9.38|
;;;949      }
;;;950      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000026  2d02              CMP      r5,#2
000028  d102              BNE      |L9.48|
;;;951      {
;;;952        itmask &= USARTx->CR2;
00002a  8a16              LDRH     r6,[r2,#0x10]
00002c  4031              ANDS     r1,r1,r6
00002e  e001              B        |L9.52|
                  |L9.48|
;;;953      }
;;;954      else /* The IT  is in CR3 register */
;;;955      {
;;;956        itmask &= USARTx->CR3;
000030  8a96              LDRH     r6,[r2,#0x14]
000032  4031              ANDS     r1,r1,r6
                  |L9.52|
;;;957      }
;;;958      
;;;959      bitpos = USART_IT >> 0x08;
000034  121c              ASRS     r4,r3,#8
;;;960    
;;;961      bitpos = (u32)0x01 << bitpos;
000036  2601              MOVS     r6,#1
000038  fa06f404          LSL      r4,r6,r4
;;;962      bitpos &= USARTx->SR;
00003c  8816              LDRH     r6,[r2,#0]
00003e  4034              ANDS     r4,r4,r6
;;;963    
;;;964      if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
000040  b111              CBZ      r1,|L9.72|
000042  b10c              CBZ      r4,|L9.72|
;;;965      {
;;;966        bitstatus = SET;
000044  2001              MOVS     r0,#1
000046  e000              B        |L9.74|
                  |L9.72|
;;;967      }
;;;968      else
;;;969      {
;;;970        bitstatus = RESET;
000048  2000              MOVS     r0,#0
                  |L9.74|
;;;971      }
;;;972      
;;;973      return bitstatus;  
;;;974    }
00004a  bd70              POP      {r4-r6,pc}
;;;975    
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;751    *******************************************************************************/
;;;752    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L10.12|
;;;753    {
;;;754      /* Check the parameters */
;;;755      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;756      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;757      
;;;758      if (NewState != DISABLE)
;;;759      {
;;;760        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;761        USARTx->CR3 |= CR3_HDSEL_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420208          ORR      r2,r2,#8
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L10.22|
                  |L10.12|
;;;762      }
;;;763      else
;;;764      {
;;;765        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;766        USARTx->CR3 &= CR3_HDSEL_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L10.22|
;;;767      }
;;;768    }
000016  4770              BX       lr
;;;769    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;362    *******************************************************************************/
;;;363    void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
000000  b5f0              PUSH     {r4-r7,lr}
;;;364    {
000002  4603              MOV      r3,r0
;;;365      u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
000004  2400              MOVS     r4,#0
000006  2600              MOVS     r6,#0
000008  2500              MOVS     r5,#0
;;;366      u32 usartxbase = 0x00;
00000a  2000              MOVS     r0,#0
;;;367    
;;;368      /* Check the parameters */
;;;369      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;370      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;371      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
;;;372      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;373    
;;;374      usartxbase = (*(u32*)&(USARTx));
00000c  4618              MOV      r0,r3
;;;375    
;;;376      /* Get the USART register index */
;;;377      usartreg = (((u8)USART_IT) >> 0x05);
00000e  f3c11442          UBFX     r4,r1,#5,#3
;;;378    
;;;379      /* Get the interrupt position */
;;;380      itpos = USART_IT & IT_Mask;
000012  f001061f          AND      r6,r1,#0x1f
;;;381    
;;;382      itmask = (((u32)0x01) << itpos);
000016  2701              MOVS     r7,#1
000018  fa07f506          LSL      r5,r7,r6
;;;383        
;;;384      if (usartreg == 0x01) /* The IT is in CR1 register */
00001c  2c01              CMP      r4,#1
00001e  d101              BNE      |L11.36|
;;;385      {
;;;386        usartxbase += 0x0C;
000020  300c              ADDS     r0,r0,#0xc
000022  e004              B        |L11.46|
                  |L11.36|
;;;387      }
;;;388      else if (usartreg == 0x02) /* The IT is in CR2 register */
000024  2c02              CMP      r4,#2
000026  d101              BNE      |L11.44|
;;;389      {
;;;390        usartxbase += 0x10;
000028  3010              ADDS     r0,r0,#0x10
00002a  e000              B        |L11.46|
                  |L11.44|
;;;391      }
;;;392      else /* The IT is in CR3 register */
;;;393      {
;;;394        usartxbase += 0x14; 
00002c  3014              ADDS     r0,r0,#0x14
                  |L11.46|
;;;395      }
;;;396      if (NewState != DISABLE)
00002e  b11a              CBZ      r2,|L11.56|
;;;397      {
;;;398        *(vu32*)usartxbase  |= itmask;
000030  6807              LDR      r7,[r0,#0]
000032  432f              ORRS     r7,r7,r5
000034  6007              STR      r7,[r0,#0]
000036  e002              B        |L11.62|
                  |L11.56|
;;;399      }
;;;400      else
;;;401      {
;;;402        *(vu32*)usartxbase &= ~itmask;
000038  6807              LDR      r7,[r0,#0]
00003a  43af              BICS     r7,r7,r5
00003c  6007              STR      r7,[r0,#0]
                  |L11.62|
;;;403      }
;;;404    }
00003e  bdf0              POP      {r4-r7,pc}
;;;405    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;143    *******************************************************************************/
;;;144    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;145    {
000004  b086              SUB      sp,sp,#0x18
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;146      u32 tmpreg = 0x00, apbclock = 0x00;
00000a  2400              MOVS     r4,#0
00000c  46a2              MOV      r10,r4
;;;147      u32 integerdivider = 0x00;
00000e  bf00              NOP      
;;;148      u32 fractionaldivider = 0x00;
000010  bf00              NOP      
;;;149      u32 usartxbase = 0;
000012  2700              MOVS     r7,#0
;;;150      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;151    
;;;152      /* Check the parameters */
;;;153      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;154      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;155      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;156      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;157      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;158      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;159      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;160      /* The hardware flow control is available only for USART1, USART2 and USART3 */          
;;;161      assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
;;;162      
;;;163      usartxbase = (*(u32*)&USARTx);
000014  462f              MOV      r7,r5
;;;164    
;;;165    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;166      tmpreg = USARTx->CR2;
000016  8a2c              LDRH     r4,[r5,#0x10]
;;;167      /* Clear STOP[13:12] bits */
;;;168      tmpreg &= CR2_STOP_CLEAR_Mask;
000018  f64c70ff          MOV      r0,#0xcfff
00001c  4004              ANDS     r4,r4,r0
;;;169    
;;;170      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;171      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;172      tmpreg |= (u32)USART_InitStruct->USART_StopBits;
00001e  88f0              LDRH     r0,[r6,#6]
000020  4304              ORRS     r4,r4,r0
;;;173      
;;;174      /* Write to USART CR2 */
;;;175      USARTx->CR2 = (u16)tmpreg;
000022  822c              STRH     r4,[r5,#0x10]
;;;176    
;;;177    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;178      tmpreg = USARTx->CR1;
000024  89ac              LDRH     r4,[r5,#0xc]
;;;179      /* Clear M, PCE, PS, TE and RE bits */
;;;180      tmpreg &= CR1_CLEAR_Mask;
000026  f64e10f3          MOV      r0,#0xe9f3
00002a  4004              ANDS     r4,r4,r0
;;;181    
;;;182      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;183      /* Set the M bits according to USART_WordLength value */
;;;184      /* Set PCE and PS bits according to USART_Parity value */
;;;185      /* Set TE and RE bits according to USART_Mode value */
;;;186      tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00002c  88b0              LDRH     r0,[r6,#4]
00002e  8931              LDRH     r1,[r6,#8]
000030  4308              ORRS     r0,r0,r1
000032  8971              LDRH     r1,[r6,#0xa]
000034  4308              ORRS     r0,r0,r1
000036  4304              ORRS     r4,r4,r0
;;;187                USART_InitStruct->USART_Mode;
;;;188    
;;;189      /* Write to USART CR1 */
;;;190      USARTx->CR1 = (u16)tmpreg;
000038  81ac              STRH     r4,[r5,#0xc]
;;;191    
;;;192    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;193      tmpreg = USARTx->CR3;
00003a  8aac              LDRH     r4,[r5,#0x14]
;;;194      /* Clear CTSE and RTSE bits */
;;;195      tmpreg &= CR3_CLEAR_Mask;
00003c  f64f40ff          MOV      r0,#0xfcff
000040  4004              ANDS     r4,r4,r0
;;;196    
;;;197      /* Configure the USART HFC -------------------------------------------------*/
;;;198      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;199      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000042  89b0              LDRH     r0,[r6,#0xc]
000044  4304              ORRS     r4,r4,r0
;;;200    
;;;201      /* Write to USART CR3 */
;;;202      USARTx->CR3 = (u16)tmpreg;
000046  82ac              STRH     r4,[r5,#0x14]
;;;203    
;;;204    /*---------------------------- USART BRR Configuration -----------------------*/
;;;205      /* Configure the USART Baud Rate -------------------------------------------*/
;;;206      RCC_GetClocksFreq(&RCC_ClocksStatus);
000048  a801              ADD      r0,sp,#4
00004a  f7fffffe          BL       RCC_GetClocksFreq
;;;207      if (usartxbase == USART1_BASE)
00004e  4812              LDR      r0,|L12.152|
000050  4287              CMP      r7,r0
000052  d102              BNE      |L12.90|
;;;208      {
;;;209        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000054  f8dda010          LDR      r10,[sp,#0x10]
000058  e001              B        |L12.94|
                  |L12.90|
;;;210      }
;;;211      else
;;;212      {
;;;213        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
00005a  f8dda00c          LDR      r10,[sp,#0xc]
                  |L12.94|
;;;214      }
;;;215    
;;;216      /* Determine the integer part */
;;;217      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
00005e  eb0a00ca          ADD      r0,r10,r10,LSL #3
000062  eb00100a          ADD      r0,r0,r10,LSL #4
000066  6831              LDR      r1,[r6,#0]
000068  0089              LSLS     r1,r1,#2
00006a  fbb0f8f1          UDIV     r8,r0,r1
;;;218      tmpreg = (integerdivider / 0x64) << 0x04;
00006e  2064              MOVS     r0,#0x64
000070  fbb8f0f0          UDIV     r0,r8,r0
000074  0104              LSLS     r4,r0,#4
;;;219    
;;;220      /* Determine the fractional part */
;;;221      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
000076  0920              LSRS     r0,r4,#4
000078  2164              MOVS     r1,#0x64
00007a  fb018910          MLS      r9,r1,r0,r8
;;;222      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
00007e  2032              MOVS     r0,#0x32
000080  eb001009          ADD      r0,r0,r9,LSL #4
000084  fbb0f0f1          UDIV     r0,r0,r1
000088  f000000f          AND      r0,r0,#0xf
00008c  4304              ORRS     r4,r4,r0
;;;223    
;;;224      /* Write to USART BRR */
;;;225      USARTx->BRR = (u16)tmpreg;
00008e  812c              STRH     r4,[r5,#8]
;;;226    }
000090  b006              ADD      sp,sp,#0x18
000092  e8bd87f0          POP      {r4-r10,pc}
;;;227    
                          ENDP

000096  0000              DCW      0x0000
                  |L12.152|
                          DCD      0x40013800

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;805    *******************************************************************************/
;;;806    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;807    {
;;;808      /* Check the parameters */
;;;809      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;810      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;811        
;;;812      if (NewState != DISABLE)
;;;813      {
;;;814        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;815        USARTx->CR3 |= CR3_IREN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420202          ORR      r2,r2,#2
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;816      }
;;;817      else
;;;818      {
;;;819        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;820        USARTx->CR3 &= CR3_IREN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L13.22|
;;;821      }
;;;822    }
000016  4770              BX       lr
;;;823    
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;783    *******************************************************************************/
;;;784    void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;785    {
;;;786      /* Check the parameters */
;;;787      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;788      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;789        
;;;790      USARTx->CR3 &= CR3_IRLP_Mask;
000002  f64f73fb          MOV      r3,#0xfffb
000006  401a              ANDS     r2,r2,r3
000008  8282              STRH     r2,[r0,#0x14]
;;;791      USARTx->CR3 |= USART_IrDAMode;
00000a  8a82              LDRH     r2,[r0,#0x14]
00000c  430a              ORRS     r2,r2,r1
00000e  8282              STRH     r2,[r0,#0x14]
;;;792    }
000010  4770              BX       lr
;;;793    
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;535    *******************************************************************************/
;;;536    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;537    {
;;;538      /* Check the parameters */
;;;539      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;540      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;541      
;;;542      USARTx->CR2 &= CR2_LBDL_Mask;
000002  f64f73df          MOV      r3,#0xffdf
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;543      USARTx->CR2 |= USART_LINBreakDetectLength;  
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;544    }
000010  4770              BX       lr
;;;545    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;557    *******************************************************************************/
;;;558    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L16.12|
;;;559    {
;;;560      /* Check the parameters */
;;;561      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;562      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;563      
;;;564      if (NewState != DISABLE)
;;;565      {
;;;566        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;567        USARTx->CR2 |= CR2_LINEN_Set;
000002  8a02              LDRH     r2,[r0,#0x10]
000004  f4424280          ORR      r2,r2,#0x4000
000008  8202              STRH     r2,[r0,#0x10]
00000a  e004              B        |L16.22|
                  |L16.12|
;;;568      }
;;;569      else
;;;570      {
;;;571        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;572        USARTx->CR2 &= CR2_LINEN_Reset;
00000c  8a02              LDRH     r2,[r0,#0x10]
00000e  f64b73ff          MOV      r3,#0xbfff
000012  401a              ANDS     r2,r2,r3
000014  8202              STRH     r2,[r0,#0x10]
                  |L16.22|
;;;573      }
;;;574    }
000016  4770              BX       lr
;;;575    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;606    *******************************************************************************/
;;;607    u16 USART_ReceiveData(USART_TypeDef* USARTx)
000000  4601              MOV      r1,r0
;;;608    {
;;;609      /* Check the parameters */
;;;610      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;611      
;;;612      /* Receive Data */
;;;613      return (u16)(USARTx->DR & (u16)0x01FF);
000002  8888              LDRH     r0,[r1,#4]
000004  f3c00008          UBFX     r0,r0,#0,#9
;;;614    }
000008  4770              BX       lr
;;;615    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;502    *******************************************************************************/
;;;503    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L18.12|
;;;504    {
;;;505      /* Check the parameters */
;;;506      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;507      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;508      
;;;509      if (NewState != DISABLE)
;;;510      {
;;;511        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;512        USARTx->CR1 |= CR1_RWU_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420202          ORR      r2,r2,#2
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L18.22|
                  |L18.12|
;;;513      }
;;;514      else
;;;515      {
;;;516        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;517        USARTx->CR1 &= CR1_RWU_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L18.22|
;;;518      }
;;;519    }
000016  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;625    *******************************************************************************/
;;;626    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;627    {
;;;628      /* Check the parameters */
;;;629      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;630      
;;;631      /* Send break characters */
;;;632      USARTx->CR1 |= CR1_SBK_Set;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;633    }
000008  4770              BX       lr
;;;634    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;586    *******************************************************************************/
;;;587    void USART_SendData(USART_TypeDef* USARTx, u16 Data)
000000  f3c10208          UBFX     r2,r1,#0,#9
;;;588    {
;;;589      /* Check the parameters */
;;;590      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;591      assert_param(IS_USART_DATA(Data)); 
;;;592        
;;;593      /* Transmit Data */
;;;594      USARTx->DR = (Data & (u16)0x01FF);
000004  8082              STRH     r2,[r0,#4]
;;;595    }
000006  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;454    *******************************************************************************/
;;;455    void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;456    {
;;;457      /* Check the parameters */
;;;458      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;459      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;460        
;;;461      /* Clear the USART address */
;;;462      USARTx->CR2 &= CR2_Address_Mask;
000002  f64f73f0          MOV      r3,#0xfff0
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;463      /* Set the USART address node */
;;;464      USARTx->CR2 |= USART_Address;
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;465    }
000010  4770              BX       lr
;;;466    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;645    *******************************************************************************/
;;;646    void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;647    {    
;;;648      /* Check the parameters */
;;;649      assert_param(IS_USART_123_PERIPH(USARTx));
;;;650      
;;;651      /* Clear the USART Guard time */
;;;652      USARTx->GTPR &= GTPR_LSB_Mask;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;653      /* Set the USART guard time */
;;;654      USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422201          ORR      r2,r2,r1,LSL #8
00000c  8302              STRH     r2,[r0,#0x18]
;;;655    }
00000e  4770              BX       lr
;;;656    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;668    *******************************************************************************/
;;;669    void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;670    { 
;;;671      /* Check the parameters */
;;;672      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;673      
;;;674      /* Clear the USART prescaler */
;;;675      USARTx->GTPR &= GTPR_MSB_Mask;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;676      /* Set the USART prescaler */
;;;677      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;678    }
00000e  4770              BX       lr
;;;679    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;691    *******************************************************************************/
;;;692    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L24.12|
;;;693    {
;;;694      /* Check the parameters */
;;;695      assert_param(IS_USART_123_PERIPH(USARTx));
;;;696      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;697    
;;;698      if (NewState != DISABLE)
;;;699      {
;;;700        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;701        USARTx->CR3 |= CR3_SCEN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420220          ORR      r2,r2,#0x20
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L24.22|
                  |L24.12|
;;;702      }
;;;703      else
;;;704      {
;;;705        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;706        USARTx->CR3 &= CR3_SCEN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L24.22|
;;;707      }
;;;708    }
000016  4770              BX       lr
;;;709    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;721    *******************************************************************************/
;;;722    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L25.12|
;;;723    {
;;;724      /* Check the parameters */
;;;725      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;726      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;727    
;;;728      if (NewState != DISABLE)
;;;729      {
;;;730        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;731        USARTx->CR3 |= CR3_NACK_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420210          ORR      r2,r2,#0x10
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L25.22|
                  |L25.12|
;;;732      }
;;;733      else
;;;734      {
;;;735        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;736        USARTx->CR3 &= CR3_NACK_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L25.22|
;;;737      }
;;;738    }
000016  4770              BX       lr
;;;739    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;236    *******************************************************************************/
;;;237    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;238    {
;;;239      /* USART_InitStruct members default value */
;;;240      USART_InitStruct->USART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;241      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;242      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;243      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;244      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  210c              MOVS     r1,#0xc
000010  8141              STRH     r1,[r0,#0xa]
;;;245      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  2100              MOVS     r1,#0
000014  8181              STRH     r1,[r0,#0xc]
;;;246    }
000016  4770              BX       lr
;;;247    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;480    *******************************************************************************/
;;;481    void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;482    {
;;;483      /* Check the parameters */
;;;484      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;485      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;486      
;;;487      USARTx->CR1 &= CR1_WAKE_Mask;
000002  f24f73ff          MOV      r3,#0xf7ff
000006  401a              ANDS     r2,r2,r3
000008  8182              STRH     r2,[r0,#0xc]
;;;488      USARTx->CR1 |= USART_WakeUp;
00000a  8982              LDRH     r2,[r0,#0xc]
00000c  430a              ORRS     r2,r2,r1
00000e  8182              STRH     r2,[r0,#0xc]
;;;489    }
000010  4770              BX       lr
;;;490    
                          ENDP

