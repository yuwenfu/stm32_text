L 1 "lib\src\stm32f10x_tim1.c"
N/******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
N* File Name          : stm32f10x_tim1.c
N* Author             : MCD Application Team
N* Version            : V1.0
N* Date               : 10/08/2007
N* Description        : This file provides all the TIM1 software functions.
N********************************************************************************
N* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_tim1.h"
L 1 ".\lib\inc\stm32f10x_tim1.h" 1
N/******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
N* File Name          : stm32f10x_tim1.h
N* Author             : MCD Application Team
N* Version            : V1.0
N* Date               : 10/08/2007
N* Description        : This file contains all the functions prototypes for the 
N*                      TIM1 firmware library.
N********************************************************************************
N* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TIM1_H
N#define __STM32F10x_TIM1_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
L 1 ".\lib\inc\stm32f10x_map.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_map.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the peripheral register's definitions
N*                      and memory mapping.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_MAP_H
N#define __STM32F10x_MAP_H
N
N#ifndef EXT
N  #define EXT extern
N#endif /* EXT */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_conf.h"
L 1 ".\lib\inc\stm32f10x_conf.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_conf.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : Library configuration file.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
L 1 ".\lib\inc\stm32f10x_type.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_type.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the common data types used for the
N*                      STM32F10x firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TYPE_H
N#define __STM32F10x_TYPE_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
Ntypedef signed long  s32;
Ntypedef signed short s16;
Ntypedef signed char  s8;
N
Ntypedef signed long  const sc32;  /* Read Only */
Ntypedef signed short const sc16;  /* Read Only */
Ntypedef signed char  const sc8;   /* Read Only */
N
Ntypedef volatile signed long  vs32;
Ntypedef volatile signed short vs16;
Ntypedef volatile signed char  vs8;
N
Ntypedef volatile signed long  const vsc32;  /* Read Only */
Ntypedef volatile signed short const vsc16;  /* Read Only */
Ntypedef volatile signed char  const vsc8;   /* Read Only */
N
Ntypedef unsigned long  u32;
Ntypedef unsigned short u16;
Ntypedef unsigned char  u8;
N
Ntypedef unsigned long  const uc32;  /* Read Only */
Ntypedef unsigned short const uc16;  /* Read Only */
Ntypedef unsigned char  const uc8;   /* Read Only */
N
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
Ntypedef volatile unsigned char  vu8;
N
Ntypedef volatile unsigned long  const vuc32;  /* Read Only */
Ntypedef volatile unsigned short const vuc16;  /* Read Only */
Ntypedef volatile unsigned char  const vuc8;   /* Read Only */
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N#define U8_MAX     ((u8)255)
N#define S8_MAX     ((s8)127)
N#define S8_MIN     ((s8)-128)
N#define U16_MAX    ((u16)65535u)
N#define S16_MAX    ((s16)32767)
N#define S16_MIN    ((s16)-32768)
N#define U32_MAX    ((u32)4294967295uL)
N#define S32_MAX    ((s32)2147483647)
N#define S32_MIN    ((s32)-2147483648)
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_TYPE_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 24 ".\lib\inc\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
N   the "assert_param" macro in the firmware library code (see "Exported macro"
N   section below) */
N/* #define DEBUG    1*/
N
N/* Comment the line below to disable the specific peripheral inclusion */
N/************************************* ADC ************************************/
N#define _ADC
N#define _ADC1
N#define _ADC2
N#define _ADC3
N
N/************************************* BKP ************************************/
N#define _BKP 
N
N/************************************* CAN ************************************/
N#define _CAN
N
N/************************************* CRC ************************************/
N#define _CRC
N
N/************************************* DAC ************************************/
N#define _DAC
N
N/************************************* DBGMCU *********************************/
N#define _DBGMCU
N
N/************************************* DMA ************************************/
N#define _DMA
N#define _DMA1_Channel1
N#define _DMA1_Channel2
N#define _DMA1_Channel3
N#define _DMA1_Channel4
N#define _DMA1_Channel5
N#define _DMA1_Channel6
N#define _DMA1_Channel7
N#define _DMA2_Channel1
N#define _DMA2_Channel2
N#define _DMA2_Channel3
N#define _DMA2_Channel4
N#define _DMA2_Channel5
N
N/************************************* EXTI ***********************************/
N#define _EXTI
N
N/************************************* FLASH and Option Bytes *****************/
N#define _FLASH
N/* Uncomment the line below to enable FLASH program/erase/protections functions,
N   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
N   are enabled */
N #define _FLASH_PROG 
N
N/************************************* FSMC ***********************************/
N#define _FSMC
N
N/************************************* GPIO ***********************************/
N#define _GPIO
N#define _GPIOA
N#define _GPIOB
N#define _GPIOC
N#define _GPIOD
N#define _GPIOE
N#define _GPIOF
N#define _GPIOG
N#define _AFIO
N
N/************************************* I2C ************************************/
N#define _I2C
N#define _I2C1
N#define _I2C2
N
N/************************************* IWDG ***********************************/
N#define _IWDG
N
N/************************************* NVIC ***********************************/
N#define _NVIC
N
N/************************************* PWR ************************************/
N#define _PWR
N
N/************************************* RCC ************************************/
N#define _RCC
N
N/************************************* RTC ************************************/
N#define _RTC
N
N/************************************* SDIO ***********************************/
N#define _SDIO
N
N/************************************* SPI ************************************/
N#define _SPI
N#define _SPI1
N#define _SPI2
N#define _SPI3
N
N/************************************* SysTick ********************************/
N#define _SysTick
N
N/************************************* TIM1 ***********************************/
N#define _TIM1
N
N/************************************* TIM ************************************/
N#define _TIM
N#define _TIM2
N#define _TIM3
N#define _TIM4
N#define _TIM5
N#define _TIM6
N#define _TIM7
N#define _TIM8
N
N/************************************* USART **********************************/
N#define _USART
N#define _USART1
N#define _USART2
N#define _USART3
N#define _UART4
N#define _UART5
N
N/************************************* WWDG ***********************************/
N#define _WWDG
N
N/* In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application */
N#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  DEBUG
S/*******************************************************************************
S* Macro Name     : assert_param
S* Description    : The assert_param macro is used for function's parameters check.
S*                  It is used only if the library is compiled in DEBUG mode. 
S* Input          : - expr: If expr is false, it calls assert_failed function
S*                    which reports the name of the source file and the source
S*                    line number of the call that failed. 
S*                    If expr is true, it returns no value.
S* Return         : None
S*******************************************************************************/ 
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(u8* file, u32 line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* DEBUG */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 29 ".\lib\inc\stm32f10x_map.h" 2
N#include "stm32f10x_type.h"
N#include "cortexm3_macro.h"
L 1 ".\lib\inc\cortexm3_macro.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : cortexm3_macro.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : Header file for cortexm3_macro.s.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CORTEXM3_MACRO_H
N#define __CORTEXM3_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid __WFI(void);
Nvoid __WFE(void);
Nvoid __SEV(void);
Nvoid __ISB(void);
Nvoid __DSB(void);
Nvoid __DMB(void);
Nvoid __SVC(void);
Nu32 __MRS_CONTROL(void);
Nvoid __MSR_CONTROL(u32 Control);
Nu32 __MRS_PSP(void);
Nvoid __MSR_PSP(u32 TopOfProcessStack);
Nu32 __MRS_MSP(void);
Nvoid __MSR_MSP(u32 TopOfMainStack);
Nvoid __RESETPRIMASK(void);
Nvoid __SETPRIMASK(void);
Nu32 __READ_PRIMASK(void);
Nvoid __RESETFAULTMASK(void);
Nvoid __SETFAULTMASK(void);
Nu32 __READ_FAULTMASK(void);
Nvoid __BASEPRICONFIG(u32 NewPriority);
Nu32 __GetBASEPRI(void);
Nu16 __REV_HalfWord(u16 Data);
Nu32 __REV_Word(u32 Data);
N
N#endif /* __CORTEXM3_MACRO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 31 ".\lib\inc\stm32f10x_map.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/******************************************************************************/
N/*                         Peripheral registers structures                    */
N/******************************************************************************/
N
N/*------------------------ Analog to Digital Converter -----------------------*/
Ntypedef struct
N{
N  vu32 SR;	  // ADC状态寄存器 ；
N  vu32 CR1;	  // ADC控制寄存器1 ；
N  vu32 CR2;	  // ADC控制寄存器2 ；
N  vu32 SMPR1; // ADC采样时间寄存器1 ；
N  vu32 SMPR2; // ADC采样时间寄存器2 ；
N  vu32 JOFR1; // ADC注入通道偏移寄存器1 ；
N  vu32 JOFR2; // ADC注入通道偏移寄存器2 ；
N  vu32 JOFR3; // ADC注入通道偏移寄存器3 ；
N  vu32 JOFR4; // ADC注入通道偏移寄存器4 ；
N  vu32 HTR;	 // ADC看门狗高阈值寄存器 ；
N  vu32 LTR;	 // ADC看门狗低阈值寄存器 ；
N  vu32 SQR1; // ADC规则序列寄存器1 ；
N  vu32 SQR2; // ADC规则序列寄存器2 ；
N  vu32 SQR3; // ADC规则序列寄存器3 ；
N  vu32 JSQR; // ADC注入序列寄存器 ；
N  vu32 JDR1; // ADC规则数据寄存器1 ；
N  vu32 JDR2; // ADC规则数据寄存器2 ；
N  vu32 JDR3; // ADC规则数据寄存器3 ；
N  vu32 JDR4; // ADC规则数据寄存器4 ；
N  vu32 DR;	 // 规则数据寄存器 ;
N} ADC_TypeDef;
N
N/*------------------------ Backup Registers ----------------------------------*/
Ntypedef struct
N{
N  u32  RESERVED0;
N  vu16 DR1;		   // 数据后备寄存器 1 ； 
N  u16  RESERVED1;
N  vu16 DR2;		   // 数据后备寄存器 2 ；
N  u16  RESERVED2;
N  vu16 DR3;		   // 数据后备寄存器 3 ；
N  u16  RESERVED3;
N  vu16 DR4;		   // 数据后备寄存器 4 ；
N  u16  RESERVED4;
N  vu16 DR5;		   // 数据后备寄存器 5 ；
N  u16  RESERVED5;
N  vu16 DR6;		   // 数据后备寄存器 6 ；
N  u16  RESERVED6;
N  vu16 DR7;		   // 数据后备寄存器 7 ；
N  u16  RESERVED7;
N  vu16 DR8;		   // 数据后备寄存器 8 ；
N  u16  RESERVED8;
N  vu16 DR9;		   // 数据后备寄存器 9 ；
N  u16  RESERVED9;
N  vu16 DR10;	   // 数据后备寄存器 10 ；
N  u16  RESERVED10; 
N  vu16 RTCCR;	   // RTC时钟校准寄存器 ；
N  u16  RESERVED11;
N  vu16 CR;		   // 后备控制寄存器 ；
N  u16  RESERVED12;
N  vu16 CSR;		   // 后备控制状态寄存器 ；
N  u16  RESERVED13[5];
N  vu16 DR11;
N  u16  RESERVED14;
N  vu16 DR12;
N  u16  RESERVED15;
N  vu16 DR13;
N  u16  RESERVED16;
N  vu16 DR14;
N  u16  RESERVED17;
N  vu16 DR15;
N  u16  RESERVED18;
N  vu16 DR16;
N  u16  RESERVED19;
N  vu16 DR17;
N  u16  RESERVED20;
N  vu16 DR18;
N  u16  RESERVED21;
N  vu16 DR19;
N  u16  RESERVED22;
N  vu16 DR20;				  
N  u16  RESERVED23;
N  vu16 DR21;
N  u16  RESERVED24;
N  vu16 DR22;
N  u16  RESERVED25;
N  vu16 DR23;
N  u16  RESERVED26;
N  vu16 DR24;
N  u16  RESERVED27;
N  vu16 DR25;
N  u16  RESERVED28;
N  vu16 DR26;
N  u16  RESERVED29;
N  vu16 DR27;
N  u16  RESERVED30;
N  vu16 DR28;
N  u16  RESERVED31;
N  vu16 DR29;
N  u16  RESERVED32;
N  vu16 DR30;
N  u16  RESERVED33; 
N  vu16 DR31;
N  u16  RESERVED34;
N  vu16 DR32;
N  u16  RESERVED35;
N  vu16 DR33;
N  u16  RESERVED36;
N  vu16 DR34;
N  u16  RESERVED37;
N  vu16 DR35;
N  u16  RESERVED38;
N  vu16 DR36;
N  u16  RESERVED39;
N  vu16 DR37;
N  u16  RESERVED40;
N  vu16 DR38;
N  u16  RESERVED41;
N  vu16 DR39;
N  u16  RESERVED42;
N  vu16 DR40;
N  u16  RESERVED43;
N  vu16 DR41;
N  u16  RESERVED44;
N  vu16 DR42;
N  u16  RESERVED45;    
N} BKP_TypeDef;
N
N/*------------------------ Controller Area Network ---------------------------*/
Ntypedef struct
N{
N  vu32 TIR;
N  vu32 TDTR;
N  vu32 TDLR;
N  vu32 TDHR;
N} CAN_TxMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 RIR;
N  vu32 RDTR;
N  vu32 RDLR;
N  vu32 RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 FR1;
N  vu32 FR2;
N} CAN_FilterRegister_TypeDef;
N
Ntypedef struct
N{
N  vu32 MCR;
N  vu32 MSR;
N  vu32 TSR;
N  vu32 RF0R;
N  vu32 RF1R;
N  vu32 IER;
N  vu32 ESR;
N  vu32 BTR;
N  u32  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  u32  RESERVED1[12];
N  vu32 FMR;
N  vu32 FM1R;
N  u32  RESERVED2;
N  vu32 FS1R;
N  u32  RESERVED3;
N  vu32 FFA1R;
N  u32  RESERVED4;
N  vu32 FA1R;
N  u32  RESERVED5[8];
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N} CAN_TypeDef;
N
N/*------------------------ CRC calculation unit ------------------------------*/
Ntypedef struct
N{
N  vu32 DR;
N  vu8  IDR;
N  u8   RESERVED0;
N  u16  RESERVED1;
N  vu32 CR;
N} CRC_TypeDef;
N
N
N/*------------------------ Digital to Analog Converter -----------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 SWTRIGR;
N  vu32 DHR12R1;
N  vu32 DHR12L1;
N  vu32 DHR8R1;
N  vu32 DHR12R2;
N  vu32 DHR12L2;
N  vu32 DHR8R2;
N  vu32 DHR12RD;
N  vu32 DHR12LD;
N  vu32 DHR8RD;
N  vu32 DOR1;
N  vu32 DOR2;
N} DAC_TypeDef;
N
N/*------------------------ Debug MCU -----------------------------------------*/
Ntypedef struct
N{
N  vu32 IDCODE;
N  vu32 CR;	
N}DBGMCU_TypeDef;
N
N/*------------------------ DMA Controller ------------------------------------*/
Ntypedef struct
N{
N  vu32 CCR;	   // DMA通道X设置寄存器 ；
N  vu32 CNDTR;  // DMA通道X待传输数据数目寄存器 ；
N  vu32 CPAR;   // DMA通道X外设地址寄存器 ；
N  vu32 CMAR;   // DMA通道X内存地址寄存器 ；
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  vu32 ISR;	   // DMA中断状态寄存器 ；
N  vu32 IFCR;   // DMA中断标志位清除寄存器 ；
N} DMA_TypeDef;
N
N/*------------------------ External Interrupt/Event Controller ---------------*/
Ntypedef struct
N{
N  vu32 IMR;	  // 中断屏蔽寄存器 ；
N  vu32 EMR;	  // 事件屏蔽寄存器 ；
N  vu32 RTSR;  // 上升沿触发选择寄存器 ；
N  vu32 FTSR;  // 下降沿触发选择寄存器 ；
N  vu32 SWIER; // 软件中断事件寄存器 ；
N  vu32 PR;	  // 挂起寄存器 ；
N} EXTI_TypeDef;
N
N/*------------------------ FLASH and Option Bytes Registers ------------------*/
Ntypedef struct
N{
N  vu32 ACR;	    // FLASH访问控制寄存器 ；
N  vu32 KEYR;    // FPEC密钥寄存器 ；
N  vu32 OPTKEYR;	// 选择字节密钥寄存器 ；
N  vu32 SR;		// FLASH状态寄存器 ；
N  vu32 CR;		// FLASH控制寄存器 ；
N  vu32 AR;		// FLASH地址寄存器 ；
N  vu32 RESERVED; //
N  vu32 OBR;		// 选择字节和状态寄存器 ；
N  vu32 WRPR;	// 选择字节写保护寄存器 ；
N} FLASH_TypeDef;
N
Ntypedef struct
N{
N  vu16 RDP;	  // 读出选择字节 ；
N  vu16 USER;  // 用户选择字节 ；
N  vu16 Data0; // Data0选择字节 ；
N  vu16 Data1; // Data1选择字节 ；
N  vu16 WRP0;  // 写保护0选择字节 ；
N  vu16 WRP1;  // 写保护1选择字节
N  vu16 WRP2;  // 写保护2选择字节
N  vu16 WRP3;  // 写保护3选择字节
N} OB_TypeDef;
N
N/*------------------------ Flexible Static Memory Controller -----------------*/
Ntypedef struct
N{
N  vu32 BTCR[8];   
N} FSMC_Bank1_TypeDef; 
N
Ntypedef struct
N{
N  vu32 BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
Ntypedef struct
N{
N  vu32 PCR2;
N  vu32 SR2;
N  vu32 PMEM2;
N  vu32 PATT2;
N  u32  RESERVED0;   
N  vu32 ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
Ntypedef struct
N{
N  vu32 PCR3;
N  vu32 SR3;
N  vu32 PMEM3;
N  vu32 PATT3;
N  u32  RESERVED0;   
N  vu32 ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
Ntypedef struct
N{
N  vu32 PCR4;
N  vu32 SR4;
N  vu32 PMEM4;
N  vu32 PATT4;
N  vu32 PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/*------------------------ General Purpose and Alternate Function IO ---------*/
Ntypedef struct
N{
N  vu32 CRL;	  // 端口配置低寄存器 ；
N  vu32 CRH;	  // 端口配置高寄存器 ；
N  vu32 IDR;	  // 端口输入数据寄存器 ；
N  vu32 ODR;	  // 端口输出数据寄存器 ；
N  vu32 BSRR;  // 端口位设置/复位寄存器 ；
N  vu32 BRR;	  // 端口位复位寄存器 ；
N  vu32 LCKR;  // 端口配置锁定寄存器 ；
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  vu32 EVCR;     // 事件控制寄存器 ；
N  vu32 MAPR;	 // 复用重映射和调试I/O配置寄存器 ；
N  vu32 EXTICR[4];// 外部中断线路0-15配置寄存器 ；
N} AFIO_TypeDef;
N
N/*------------------------ Inter-integrated Circuit Interface ----------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 OAR1;
N  u16  RESERVED2;
N  vu16 OAR2;
N  u16  RESERVED3;
N  vu16 DR;
N  u16  RESERVED4;
N  vu16 SR1;
N  u16  RESERVED5;
N  vu16 SR2;
N  u16  RESERVED6;
N  vu16 CCR;
N  u16  RESERVED7;
N  vu16 TRISE;
N  u16  RESERVED8;
N} I2C_TypeDef;
N
N/*------------------------ Independent WATCHDOG ------------------------------*/
Ntypedef struct
N{
N  vu32 KR;	// IWDG键值寄存器 ；
N  vu32 PR;	// IWDG预分频寄存器 ；
N  vu32 RLR;	// IWDG重装载寄存器 ；
N  vu32 SR;	// IWDG状态寄存器 ；
N} IWDG_TypeDef;
N
N/*------------------------ Nested Vectored Interrupt Controller --------------*/
Ntypedef struct
N{
N  vu32 ISER[2];		  //
N  u32  RESERVED0[30]; //
N  vu32 ICER[2];		  //
N  u32  RSERVED1[30];  //
N  vu32 ISPR[2];		  //
N  u32  RESERVED2[30];
N  vu32 ICPR[2];
N  u32  RESERVED3[30];
N  vu32 IABR[2];
N  u32  RESERVED4[62];
N  vu32 IPR[15];
N} NVIC_TypeDef;
N
Ntypedef struct
N{
N  vuc32 CPUID;	 // CPU ID 基寄存器 ;
N  vu32 ICSR;	 //
N  vu32 VTOR;	 //
N  vu32 AIRCR;	 //
N  vu32 SCR;
N  vu32 CCR;
N  vu32 SHPR[3];
N  vu32 SHCSR;
N  vu32 CFSR;
N  vu32 HFSR;
N  vu32 DFSR;
N  vu32 MMFAR;
N  vu32 BFAR;
N  vu32 AFSR;
N} SCB_TypeDef;
N
N/*------------------------ Power Control -------------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CSR;
N} PWR_TypeDef;
N
N/*------------------------ Reset and Clock Control ---------------------------*/
Ntypedef struct
N{
N  vu32 CR;	     // 时钟控制寄存器 ；
N  vu32 CFGR;	 // 时钟配置寄存器 ；
N  vu32 CIR;		 // 时钟中断寄存器 ；
N  vu32 APB2RSTR; // APB2外设复位寄存器 ；
N  vu32 APB1RSTR; // APB1外设复位寄存器 ；
N  vu32 AHBENR;	 // AHB外设时钟使能寄存器 ；
N  vu32 APB2ENR;	 // APB2外设时钟使能寄存器 ；
N  vu32 APB1ENR;	 // APB1外设时钟使能寄存器 ；
N  vu32 BDCR;	 // 备份域控制寄存器 ；
N  vu32 CSR;		 // 控制/状态寄存器 ；
N} RCC_TypeDef;
N
N/*------------------------ Real-Time Clock -----------------------------------*/
Ntypedef struct
N{
N  vu16 CRH;	      // 控制寄存器高位 ；
N  u16  RESERVED0; //
N  vu16 CRL;		  // 控制寄存器低位 ；
N  u16  RESERVED1; //
N  vu16 PRLH;	  // 预分频装载寄存器高位 ；
N  u16  RESERVED2; //
N  vu16 PRLL;	  // 预分频装载寄存器低位 ；
N  u16  RESERVED3; //
N  vu16 DIVH;	  // 预分频分频因子寄存器高位 ；
N  u16  RESERVED4; //
N  vu16 DIVL;	  // 预分频分频因子寄存器低位 ；
N  u16  RESERVED5; //
N  vu16 CNTH;	  // 计数器寄存器高位 ；
N  u16  RESERVED6; //
N  vu16 CNTL;	  // 计数器寄存器低位 ；
N  u16  RESERVED7; //
N  vu16 ALRH;	  // 闹钟寄存器高位 ；
N  u16  RESERVED8; //
N  vu16 ALRL;	  // 闹钟寄存器低位 ；
N  u16  RESERVED9; //
N} RTC_TypeDef;
N
N/*------------------------ SD host Interface ---------------------------------*/
Ntypedef struct
N{
N  vu32 POWER;
N  vu32 CLKCR;
N  vu32 ARG;
N  vu32 CMD;
N  vuc32 RESPCMD;
N  vuc32 RESP1;
N  vuc32 RESP2;
N  vuc32 RESP3;
N  vuc32 RESP4;
N  vu32 DTIMER;
N  vu32 DLEN;
N  vu32 DCTRL;
N  vuc32 DCOUNT;
N  vuc32 STA;
N  vu32 ICR;
N  vu32 MASK;
N  u32  RESERVED0[2];
N  vuc32 FIFOCNT;
N  u32  RESERVED1[13];
N  vu32 FIFO;
N} SDIO_TypeDef;
N
N/*------------------------ Serial Peripheral Interface -----------------------*/
Ntypedef struct
N{
N  vu16 CR1;	      // SPI控制寄存器1 ；
N  u16  RESERVED0;
N  vu16 CR2;		  // SPI控制寄存器2 ；
N  u16  RESERVED1;
N  vu16 SR;		  // SPI状态寄存器 ；
N  u16  RESERVED2;
N  vu16 DR;		  // SPI数据寄存器 ；
N  u16  RESERVED3;
N  vu16 CRCPR;	  // SPI CRC多项式寄存器 ；
N  u16  RESERVED4;
N  vu16 RXCRCR;	  // SPI接收CRC寄存器 ；
N  u16  RESERVED5;
N  vu16 TXCRCR;	  // SPI发送CRC寄存器 ；
N  u16  RESERVED6;
N  vu16 I2SCFGR;
N  u16  RESERVED7;
N  vu16 I2SPR;
N  u16  RESERVED8;  
N} SPI_TypeDef;
N
N/*------------------------ SystemTick ----------------------------------------*/
Ntypedef struct
N{
N  vu32 CTRL;   // SysTick控制和状态寄存器 ；
N  vu32 LOAD;   // SysTick重装载值寄存器 ；
N  vu32 VAL;	   // SysTick当前值寄存器 ；
N  vuc32 CALIB; // SysTick校准值寄存器 ；
N} SysTick_TypeDef;
N
N/*------------------------ Advanced Control Timer ----------------------------*/
Ntypedef struct
N{
N  vu16 CR1;		  // 控制寄存器1 ；
N  u16  RESERVED0; 
N  vu16 CR2;		  // 控制寄存器2 ；
N  u16  RESERVED1; 
N  vu16 SMCR;	  // 从模式控制寄存器 ；
N  u16  RESERVED2;
N  vu16 DIER;	  // DMA/中断使能寄存器 ；
N  u16  RESERVED3;
N  vu16 SR;		  // 状态寄存器 ；
N  u16  RESERVED4;
N  vu16 EGR;		  // 事件产生寄存器 ；
N  u16  RESERVED5;
N  vu16 CCMR1;	  // 捕获/比较模式寄存器1 ；
N  u16  RESERVED6;
N  vu16 CCMR2;	  // 捕获/比较模式寄存器2 ；
N  u16  RESERVED7;
N  vu16 CCER;	  // 捕获/比较使能寄存器 ；
N  u16  RESERVED8;
N  vu16 CNT;		  // 计数器寄存器 ；
N  u16  RESERVED9;
N  vu16 PSC;		  // 预分频寄存器 ；
N  u16  RESERVED10;
N  vu16 ARR;		  // 自动重装载寄存器 ；
N  u16  RESERVED11;
N  vu16 RCR;		  // 周期计数寄存器 ；
N  u16  RESERVED12;
N  vu16 CCR1;	  // 捕获/比较寄存器1 ；
N  u16  RESERVED13;
N  vu16 CCR2;	  // 捕获/比较寄存器2 ；
N  u16  RESERVED14;
N  vu16 CCR3;	  // 捕获/比较寄存器3 ；
N  u16  RESERVED15;
N  vu16 CCR4;	  // 捕获/比较寄存器4 ；
N  u16  RESERVED16;
N  vu16 BDTR;	  // 刹车和死区寄存器 ；
N  u16  RESERVED17;
N  vu16 DCR;		  // DMA控制寄存器 ；
N  u16  RESERVED18;
N  vu16 DMAR;	  // 连续模式的DMA地址寄存器 ；
N  u16  RESERVED19;
N} TIM1_TypeDef;
N
N/*------------------------ TIM -----------------------------------------------*/
Ntypedef struct
N{
N  vu16 CR1;		// 控制寄存器1 ；
N  u16 RESERVED0;
N  vu16 CR2;	   // 控制寄存器2 ；
N  u16 RESERVED1;
N  vu16 SMCR;   // 从模式控制寄存器 ；
N  u16 RESERVED2;
N  vu16 DIER;   // DMA/中断使能寄存器 ；
N  u16 RESERVED3;
N  vu16 SR;		// 状态寄存器 ；
N  u16 RESERVED4;
N  vu16 EGR;		// 事件产生寄存器 ；
N  u16 RESERVED5;
N  vu16 CCMR1;  // 捕获/比较模式寄存器1 ；
N  u16 RESERVED6;
N  vu16 CCMR2;  // 捕获/比较模式寄存器2 ；
N  u16 RESERVED7;
N  vu16 CCER;  // 捕获/比较使能寄存器 ；
N  u16 RESERVED8;
N  vu16 CNT;	  // 计数器寄存器 ；
N  u16 RESERVED9;
N  vu16 PSC;	  // 预分频寄存器 ；
N  u16 RESERVED10;
N  vu16 ARR;	  // 自动重装载寄存器 ；
N  u16 RESERVED11[3];
N  vu16 CCR1;  // 捕获/比较寄存器1 ；
N  u16 RESERVED12;
N  vu16 CCR2;  // 捕获/比较寄存器2 ；
N  u16 RESERVED13;
N  vu16 CCR3;  // 捕获/比较寄存器3 ；
N  u16 RESERVED14;
N  vu16 CCR4;  // 捕获/比较寄存器4 ；
N  u16 RESERVED15[3];
N  vu16 DCR;	  // DMA控制寄存器 ；
N  u16 RESERVED16;
N  vu16 DMAR;  // 连续模式的DMA地址寄存器 ；
N  u16 RESERVED17; 
N 
N  vu16 RCR;		  // 周期计数寄存器 ；
N  vu16 BDTR;	  // 刹车和死区寄存器 ；
N} TIM_TypeDef;
N
N/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
Ntypedef struct
N{
N  vu16 SR;		 // USART状态寄存器 ；
N  u16  RESERVED0;
N  vu16 DR;		 // USART数据寄存器 ；
N  u16  RESERVED1;
N  vu16 BRR;		 // USART波特率寄存器 ；
N  u16  RESERVED2;
N  vu16 CR1;		 // USART控制寄存器1 ；
N  u16  RESERVED3;
N  vu16 CR2;		 // USART控制寄存器2 ；
N  u16  RESERVED4;
N  vu16 CR3;		 // USART控制寄存器3 ；
N  u16  RESERVED5;
N  vu16 GTPR;	 // USART保护时间和预分频寄存器 ；
N  u16  RESERVED6;
N} USART_TypeDef;
N
N/*------------------------ Window WATCHDOG -----------------------------------*/
Ntypedef struct
N{
N  vu32 CR;	// WWDG控制寄存器 ；
N  vu32 CFR;	// WWDG设置寄存器 ；
N  vu32 SR;  // WWDG状态寄存器 ；
N} WWDG_TypeDef;
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address in the alias region */
N#define PERIPH_BB_BASE        ((u32)0x42000000)
N#define SRAM_BB_BASE          ((u32)0x22000000)
N
N/* Peripheral and SRAM base address in the bit-band region */
N#define SRAM_BASE             ((u32)0x20000000)
N#define PERIPH_BASE           ((u32)0x40000000)
N
N/* FSMC registers base address */
N#define FSMC_R_BASE           ((u32)0xA0000000)
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N/* Flash registers base address */
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
N/* Flash Option Bytes base address */
N#define OB_BASE               ((u32)0x1FFFF800)
N
N/* FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE          ((u32)0xE0042000)
N
N/* System Control Space memory map */
N#define SCS_BASE              ((u32)0xE000E000)
N
N#define SysTick_BASE          (SCS_BASE + 0x0010)
N#define NVIC_BASE             (SCS_BASE + 0x0100)
N#define SCB_BASE              (SCS_BASE + 0x0D00)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/*------------------------ Non Debug Mode ------------------------------------*/
N#ifndef DEBUG
N#ifdef _TIM2
N  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#endif /*_TIM2 */
N
N#ifdef _TIM3
N  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#endif /*_TIM3 */
N
N#ifdef _TIM4
N  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#endif /*_TIM4 */
N
N#ifdef _TIM5
N  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#endif /*_TIM5 */
N
N#ifdef _TIM6
N  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#endif /*_TIM6 */
N
N#ifdef _TIM7
N  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#endif /*_TIM7 */
N
N#ifdef _RTC
N  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#endif /*_RTC */
N
N#ifdef _WWDG
N  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#endif /*_WWDG */
N
N#ifdef _IWDG
N  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#endif /*_IWDG */
N
N#ifdef _SPI2
N  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#endif /*_SPI2 */
N
N#ifdef _SPI3
N  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#endif /*_SPI3 */
N
N#ifdef _USART2
N  #define USART2              ((USART_TypeDef *) USART2_BASE)
N#endif /*_USART2 */
N
N#ifdef _USART3
N  #define USART3              ((USART_TypeDef *) USART3_BASE)
N#endif /*_USART3 */
N
N#ifdef _UART4
N  #define UART4              ((USART_TypeDef *) UART4_BASE)
N#endif /*_UART4 */
N
N#ifdef _UART5
N  #define UART5              ((USART_TypeDef *) UART5_BASE)
N#endif /*_USART5 */
N
N#ifdef _I2C1
N  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#endif /*_I2C1 */
N
N#ifdef _I2C2
N  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#endif /*_I2C2 */
N
N#ifdef _CAN
N  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#endif /*_CAN */
N
N#ifdef _BKP
N  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#endif /*_BKP */
N
N#ifdef _PWR
N  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#endif /*_PWR */
N
N#ifdef _DAC
N  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#endif /*_DAC */
N
N#ifdef _AFIO
N  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#endif /*_AFIO */
N
N#ifdef _EXTI
N  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#endif /*_EXTI */
N
N#ifdef _GPIOA
N  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#endif /*_GPIOA */
N
N#ifdef _GPIOB
N  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#endif /*_GPIOB */
N
N#ifdef _GPIOC
N  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#endif /*_GPIOC */
N
N#ifdef _GPIOD
N  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#endif /*_GPIOD */
N
N#ifdef _GPIOE
N  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#endif /*_GPIOE */
N
N#ifdef _GPIOF
N  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#endif /*_GPIOF */
N
N#ifdef _GPIOG
N  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#endif /*_GPIOG */
N
N#ifdef _ADC1
N  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#endif /*_ADC1 */
N
N#ifdef _ADC2
N  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#endif /*_ADC2 */
N
N#ifdef _TIM1
N  #define TIM1                ((TIM1_TypeDef *) TIM1_BASE)
N#endif /*_TIM1 */
N
N#ifdef _SPI1
N  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#endif /*_SPI1 */
N
N#ifdef _TIM8
N  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#endif /*_TIM8 */
N
N#ifdef _USART1
N  #define USART1              ((USART_TypeDef *) USART1_BASE)
N#endif /*_USART1 */
N
N#ifdef _ADC3
N  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#endif /*_ADC3 */
N
N#ifdef _SDIO
N  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#endif /*_SDIO */
N
N#ifdef _DMA
N  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#endif /*_DMA */
N
N#ifdef _DMA1_Channel1
N  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#endif /*_DMA1_Channel1 */
N
N#ifdef _DMA1_Channel2
N  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#endif /*_DMA1_Channel2 */
N
N#ifdef _DMA1_Channel3
N  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#endif /*_DMA1_Channel3 */
N
N#ifdef _DMA1_Channel4
N  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#endif /*_DMA1_Channel4 */
N
N#ifdef _DMA1_Channel5
N  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#endif /*_DMA1_Channel5 */
N
N#ifdef _DMA1_Channel6
N  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#endif /*_DMA1_Channel6 */
N
N#ifdef _DMA1_Channel7
N  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#endif /*_DMA1_Channel7 */
N
N#ifdef _DMA2_Channel1
N  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#endif /*_DMA2_Channel1 */
N
N#ifdef _DMA2_Channel2
N  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#endif /*_DMA2_Channel2 */
N
N#ifdef _DMA2_Channel3
N  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#endif /*_DMA2_Channel3 */
N
N#ifdef _DMA2_Channel4
N  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#endif /*_DMA2_Channel4 */
N
N#ifdef _DMA2_Channel5
N  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#endif /*_DMA2_Channel5 */
N
N#ifdef _RCC
N  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#endif /*_RCC */
N
N#ifdef _CRC
N  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#endif /*_CRC */
N
N#ifdef _FLASH
N  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N  #define OB                  ((OB_TypeDef *) OB_BASE) 
N#endif /*_FLASH */
N
N#ifdef _FSMC
N  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
N  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
N  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /*_FSMC */
N
N#ifdef _DBGMCU
N  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#endif /*_DBGMCU */
N
N#ifdef _SysTick
N  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
N#endif /*_SysTick */
N
N#ifdef _NVIC
N  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
N  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
N#endif /*_NVIC */
N
N/*------------------------ Debug Mode ----------------------------------------*/
N#else   /* DEBUG */
S#ifdef _TIM2
S  EXT TIM_TypeDef             *TIM2;
S#endif /*_TIM2 */
S
S#ifdef _TIM3
S  EXT TIM_TypeDef             *TIM3;
S#endif /*_TIM3 */
S
S#ifdef _TIM4
S  EXT TIM_TypeDef             *TIM4;
S#endif /*_TIM4 */
S
S#ifdef _TIM5
S  EXT TIM_TypeDef             *TIM5;
S#endif /*_TIM5 */
S
S#ifdef _TIM6
S  EXT TIM_TypeDef             *TIM6;
S#endif /*_TIM6 */
S
S#ifdef _TIM7
S  EXT TIM_TypeDef             *TIM7;
S#endif /*_TIM7 */
S
S#ifdef _RTC
S  EXT RTC_TypeDef             *RTC;
S#endif /*_RTC */
S
S#ifdef _WWDG
S  EXT WWDG_TypeDef            *WWDG;
S#endif /*_WWDG */
S
S#ifdef _IWDG
S  EXT IWDG_TypeDef            *IWDG;
S#endif /*_IWDG */
S
S#ifdef _SPI2
S  EXT SPI_TypeDef             *SPI2;
S#endif /*_SPI2 */
S
S#ifdef _SPI3
S  EXT SPI_TypeDef             *SPI3;
S#endif /*_SPI3 */
S
S#ifdef _USART2
S  EXT USART_TypeDef           *USART2;
S#endif /*_USART2 */
S
S#ifdef _USART3
S  EXT USART_TypeDef           *USART3;
S#endif /*_USART3 */
S
S#ifdef _UART4
S  EXT USART_TypeDef           *UART4;
S#endif /*_UART4 */
S
S#ifdef _UART5
S  EXT USART_TypeDef           *UART5;
S#endif /*_UART5 */
S
S#ifdef _I2C1
S  EXT I2C_TypeDef             *I2C1;
S#endif /*_I2C1 */
S
S#ifdef _I2C2
S  EXT I2C_TypeDef             *I2C2;
S#endif /*_I2C2 */
S
S#ifdef _CAN
S  EXT CAN_TypeDef             *CAN;
S#endif /*_CAN */
S
S#ifdef _BKP
S  EXT BKP_TypeDef             *BKP;
S#endif /*_BKP */
S
S#ifdef _PWR
S  EXT PWR_TypeDef             *PWR;
S#endif /*_PWR */
S
S#ifdef _DAC
S  EXT DAC_TypeDef             *DAC;
S#endif /*_DAC */
S
S#ifdef _AFIO
S  EXT AFIO_TypeDef            *AFIO;
S#endif /*_AFIO */
S
S#ifdef _EXTI
S  EXT EXTI_TypeDef            *EXTI;
S#endif /*_EXTI */
S
S#ifdef _GPIOA
S  EXT GPIO_TypeDef            *GPIOA;
S#endif /*_GPIOA */
S
S#ifdef _GPIOB
S  EXT GPIO_TypeDef            *GPIOB;
S#endif /*_GPIOB */
S
S#ifdef _GPIOC
S  EXT GPIO_TypeDef            *GPIOC;
S#endif /*_GPIOC */
S
S#ifdef _GPIOD
S  EXT GPIO_TypeDef            *GPIOD;
S#endif /*_GPIOD */
S
S#ifdef _GPIOE
S  EXT GPIO_TypeDef            *GPIOE;
S#endif /*_GPIOE */
S
S#ifdef _GPIOF
S  EXT GPIO_TypeDef            *GPIOF;
S#endif /*_GPIOF */
S
S#ifdef _GPIOG
S  EXT GPIO_TypeDef            *GPIOG;
S#endif /*_GPIOG */
S
S#ifdef _ADC1
S  EXT ADC_TypeDef             *ADC1;
S#endif /*_ADC1 */
S
S#ifdef _ADC2
S  EXT ADC_TypeDef             *ADC2;
S#endif /*_ADC2 */
S
S#ifdef _TIM1
S  EXT TIM_TypeDef             *TIM1;
S#endif /*_TIM1 */
S
S#ifdef _SPI1
S  EXT SPI_TypeDef             *SPI1;
S#endif /*_SPI1 */
S
S#ifdef _TIM8
S  EXT TIM_TypeDef             *TIM8;
S#endif /*_TIM8 */
S
S#ifdef _USART1
S  EXT USART_TypeDef           *USART1;
S#endif /*_USART1 */
S
S#ifdef _ADC3
S  EXT ADC_TypeDef             *ADC3;
S#endif /*_ADC3 */
S
S#ifdef _SDIO
S  EXT SDIO_TypeDef            *SDIO;
S#endif /*_SDIO */
S
S#ifdef _DMA
S  EXT DMA_TypeDef             *DMA1;
S  EXT DMA_TypeDef             *DMA2;
S#endif /*_DMA */
S
S#ifdef _DMA1_Channel1
S  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
S#endif /*_DMA1_Channel1 */
S
S#ifdef _DMA1_Channel2
S  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
S#endif /*_DMA1_Channel2 */
S
S#ifdef _DMA1_Channel3
S  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
S#endif /*_DMA1_Channel3 */
S
S#ifdef _DMA1_Channel4
S  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
S#endif /*_DMA1_Channel4 */
S
S#ifdef _DMA1_Channel5
S  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
S#endif /*_DMA1_Channel5 */
S
S#ifdef _DMA1_Channel6
S  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
S#endif /*_DMA1_Channel6 */
S
S#ifdef _DMA1_Channel7
S  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
S#endif /*_DMA1_Channel7 */
S
S#ifdef _DMA2_Channel1
S  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
S#endif /*_DMA2_Channel1 */
S
S#ifdef _DMA2_Channel2
S  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
S#endif /*_DMA2_Channel2 */
S
S#ifdef _DMA2_Channel3
S  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
S#endif /*_DMA2_Channel3 */
S
S#ifdef _DMA2_Channel4
S  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
S#endif /*_DMA2_Channel4 */
S
S#ifdef _DMA2_Channel5
S  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
S#endif /*_DMA2_Channel5 */
S
S#ifdef _RCC
S  EXT RCC_TypeDef             *RCC;
S#endif /*_RCC */
S
S#ifdef _CRC
S  EXT CRC_TypeDef             *CRC;
S#endif /*_CRC */
S
S#ifdef _FLASH
S  EXT FLASH_TypeDef            *FLASH;
S  EXT OB_TypeDef               *OB;  
S#endif /*_FLASH */
S
S#ifdef _FSMC
S  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
S  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
S  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
S  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
S  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
S#endif /*_FSMC */
S
S#ifdef _DBGMCU
S  EXT DBGMCU_TypeDef          *DBGMCU;
S#endif /*_DBGMCU */
S
S#ifdef _SysTick
S  EXT SysTick_TypeDef         *SysTick;
S#endif /*_SysTick */
S
S#ifdef _NVIC
S  EXT NVIC_TypeDef            *NVIC;
S  EXT SCB_TypeDef             *SCB;
S#endif /*_NVIC */
S
N#endif  /* DEBUG */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_MAP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 23 ".\lib\inc\stm32f10x_tim1.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N
N/* TIM1 Time Base Init structure definition */
Ntypedef struct
N{
N  u16 TIM1_Prescaler;  // 设置了用来作为TIM1时钟频率除数的预分频值 ；
N  u16 TIM1_CounterMode;	// 选择了计数器模式 ；
N  u16 TIM1_Period;	// 设置了在下一个更新事件装入活动的自动重装载寄存器周期的值 ；
N  u16 TIM1_ClockDivision; // 设置了时钟分割 ；
N  u8 TIM1_RepetitionCounter;  // 设置了周期计数器值。
N} TIM1_TimeBaseInitTypeDef;
N
N/* TIM1 Output Compare Init structure definition */
Ntypedef struct
N{
N  u16 TIM1_OCMode;	 //	选择定时器模式。
N  u16 TIM1_OutputState;	// 选择输出比较状态。
N  u16 TIM1_OutputNState; //	选择互补输出比较状态。
N  u16 TIM1_Pulse;  // 设置了待装入捕获比较寄存器的脉冲值 ；
N  u16 TIM1_OCPolarity; // 输出极性 ；
N  u16 TIM1_OCNPolarity; // 互补输出极性 ；
N  u16 TIM1_OCIdleState;	// 选择空闲状态下的非工作状态 ；
N  u16 TIM1_OCNIdleState; // 选择空闲状态下的非工作状态 ；
N
N} TIM1_OCInitTypeDef;
N
N/* TIM1 Input Capture Init structure definition */
Ntypedef struct
N{
N  u16 TIM1_Channel;	 //	选择通道。 
N  u16 TIM1_ICPolarity;  // 输入活动沿。
N  u16 TIM1_ICSelection; // 选择输入 ；
N  u16 TIM1_ICPrescaler;	// 设置输入捕获预分频器 ；
N  u8 TIM1_ICFilter;	   // 选择输入比较滤波器 ；
N} TIM1_ICInitTypeDef;
N
N/* BDTR structure definition */
Ntypedef struct
N{
N  u16 TIM1_OSSRState; // 设置在运行模式下非工作状态选项 ；
N  u16 TIM1_OSSIState; // 设置在运行模式下非工作状态选项	；
N  u16 TIM1_LOCKLevel; // 设置了锁电平参数 ；
N  u16 TIM1_DeadTime;  // 指定了输出打开和关闭状态之间的延时。
N  u16 TIM1_Break;	  // 使能或者失能TIM1刹车输入。
N  u16 TIM1_BreakPolarity; // 设置TIM1刹车输入管脚极性。
N  u16 TIM1_AutomaticOutput; // 使能或者失能自动输出功能该参数取值 ；
N} TIM1_BDTRInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* TIM1 Output Compare and PWM modes ----------------------------------------*/
N#define TIM1_OCMode_Timing                 ((u16)0x0000) // TIM1输出比较时间模式 ；
N#define TIM1_OCMode_Active                 ((u16)0x0010) //	TIM1输出比较主动模式 ；
N#define TIM1_OCMode_Inactive               ((u16)0x0020) //	TIM1输出比较非主动模式 ；
N#define TIM1_OCMode_Toggle                 ((u16)0x0030) //	TIM1输出比较触发模式 ；
N#define TIM1_OCMode_PWM1                   ((u16)0x0060) //	TIM1脉冲宽度调制模式1 ；
N#define TIM1_OCMode_PWM2                   ((u16)0x0070) //	TIM1脉冲宽度调制模式2 ；
N
N#define IS_TIM1_OC_MODE(MODE) ((MODE == TIM1_OCMode_Timing) || \
N                               (MODE == TIM1_OCMode_Active) || \
N                               (MODE == TIM1_OCMode_Inactive) || \
N                               (MODE == TIM1_OCMode_Toggle)|| \
N                               (MODE == TIM1_OCMode_PWM1) || \
N                               (MODE == TIM1_OCMode_PWM2))
X#define IS_TIM1_OC_MODE(MODE) ((MODE == TIM1_OCMode_Timing) ||                                (MODE == TIM1_OCMode_Active) ||                                (MODE == TIM1_OCMode_Inactive) ||                                (MODE == TIM1_OCMode_Toggle)||                                (MODE == TIM1_OCMode_PWM1) ||                                (MODE == TIM1_OCMode_PWM2))
N
N#define IS_TIM1_OCM(MODE)((MODE == TIM1_OCMode_Timing) || \
N                          (MODE == TIM1_OCMode_Active) || \
N                          (MODE == TIM1_OCMode_Inactive) || \
N                          (MODE == TIM1_OCMode_Toggle)|| \
N                          (MODE == TIM1_OCMode_PWM1) || \
N                          (MODE == TIM1_OCMode_PWM2) ||	\
N                          (MODE == TIM1_ForcedAction_Active) || \
N                          (MODE == TIM1_ForcedAction_InActive))
X#define IS_TIM1_OCM(MODE)((MODE == TIM1_OCMode_Timing) ||                           (MODE == TIM1_OCMode_Active) ||                           (MODE == TIM1_OCMode_Inactive) ||                           (MODE == TIM1_OCMode_Toggle)||                           (MODE == TIM1_OCMode_PWM1) ||                           (MODE == TIM1_OCMode_PWM2) ||	                          (MODE == TIM1_ForcedAction_Active) ||                           (MODE == TIM1_ForcedAction_InActive))
N/* TIM1 One Pulse Mode ------------------------------------------------------*/
N#define TIM1_OPMode_Single                 ((u16)0x0001) //	生成单一的脉冲：计数器在下一个更新事件停止 ；
N#define TIM1_OPMode_Repetitive             ((u16)0x0000) //	生成重复的脉冲：在更新事件时计数器不停止 ；
N
N#define IS_TIM1_OPM_MODE(MODE) ((MODE == TIM1_OPMode_Single) || \
N                                (MODE == TIM1_OPMode_Repetitive))
X#define IS_TIM1_OPM_MODE(MODE) ((MODE == TIM1_OPMode_Single) ||                                 (MODE == TIM1_OPMode_Repetitive))
N
N/* TIM1 Channel -------------------------------------------------------------*/
N#define TIM1_Channel_1                     ((u16)0x0000) // 使用TIM1通道1 ；
N#define TIM1_Channel_2                     ((u16)0x0001) // 使用TIM1通道2 ；
N#define TIM1_Channel_3                     ((u16)0x0002) // 使用TIM1通道3 ；
N#define TIM1_Channel_4                     ((u16)0x0003) // 使用TIM1通道4 ；
N
N#define IS_TIM1_CHANNEL(CHANNEL) ((CHANNEL == TIM1_Channel_1) || \
N                                  (CHANNEL == TIM1_Channel_2) || \
N                                  (CHANNEL == TIM1_Channel_3) || \
N                                  (CHANNEL == TIM1_Channel_4))
X#define IS_TIM1_CHANNEL(CHANNEL) ((CHANNEL == TIM1_Channel_1) ||                                   (CHANNEL == TIM1_Channel_2) ||                                   (CHANNEL == TIM1_Channel_3) ||                                   (CHANNEL == TIM1_Channel_4))
N
N#define IS_TIM1_PWMI_CHANNEL(CHANNEL) ((CHANNEL == TIM1_Channel_1) || \
N                                       (CHANNEL == TIM1_Channel_2))
X#define IS_TIM1_PWMI_CHANNEL(CHANNEL) ((CHANNEL == TIM1_Channel_1) ||                                        (CHANNEL == TIM1_Channel_2))
N
N#define IS_TIM1_COMPLEMENTARY_CHANNEL(CHANNEL) ((CHANNEL == TIM1_Channel_1) || \
N                                                (CHANNEL == TIM1_Channel_2) || \
N                                                (CHANNEL == TIM1_Channel_3))
X#define IS_TIM1_COMPLEMENTARY_CHANNEL(CHANNEL) ((CHANNEL == TIM1_Channel_1) ||                                                 (CHANNEL == TIM1_Channel_2) ||                                                 (CHANNEL == TIM1_Channel_3))
N/* TIM1 Clock Division CKD --------------------------------------------------*/
N#define TIM1_CKD_DIV1                      ((u16)0x0000) // TDTS = Tck_TIM1 ；
N#define TIM1_CKD_DIV2                      ((u16)0x0100) // TDTS = 2Tck_TIM1 ；
N#define TIM1_CKD_DIV4                      ((u16)0x0200) // TDTS = 4Tck_TIM1 ；
N
N#define IS_TIM1_CKD_DIV(DIV) ((DIV == TIM1_CKD_DIV1) || \
N                              (DIV == TIM1_CKD_DIV2) || \
N                              (DIV == TIM1_CKD_DIV4))
X#define IS_TIM1_CKD_DIV(DIV) ((DIV == TIM1_CKD_DIV1) ||                               (DIV == TIM1_CKD_DIV2) ||                               (DIV == TIM1_CKD_DIV4))
N
N/* TIM1 Counter Mode --------------------------------------------------------*/
N#define TIM1_CounterMode_Up                ((u16)0x0000) // TIM1向上计数模式 ；
N#define TIM1_CounterMode_Down              ((u16)0x0010) //	TIM1向下计数模式 ；
N#define TIM1_CounterMode_CenterAligned1    ((u16)0x0020) //	TIM1中央对齐模式1计数模式 ；
N#define TIM1_CounterMode_CenterAligned2    ((u16)0x0040) //	TIM1中央对齐模式2计数模式 ；
N#define TIM1_CounterMode_CenterAligned3    ((u16)0x0060) //	TIM1中央对齐模式3计数模式 ；
N
N#define IS_TIM1_COUNTER_MODE(MODE) ((MODE == TIM1_CounterMode_Up) ||  \
N                                    (MODE == TIM1_CounterMode_Down) || \
N                                    (MODE == TIM1_CounterMode_CenterAligned1) || \
N                                    (MODE == TIM1_CounterMode_CenterAligned2) || \
N                                    (MODE == TIM1_CounterMode_CenterAligned3))
X#define IS_TIM1_COUNTER_MODE(MODE) ((MODE == TIM1_CounterMode_Up) ||                                      (MODE == TIM1_CounterMode_Down) ||                                     (MODE == TIM1_CounterMode_CenterAligned1) ||                                     (MODE == TIM1_CounterMode_CenterAligned2) ||                                     (MODE == TIM1_CounterMode_CenterAligned3))
N
N/* TIM1 Output Compare Polarity ---------------------------------------------*/
N#define TIM1_OCPolarity_High               ((u16)0x0000) // TIM1输出比较极性高 ；
N#define TIM1_OCPolarity_Low                ((u16)0x0001) // TIM1输出比较极性低 ；
N
N#define IS_TIM1_OC_POLARITY(POLARITY) ((POLARITY == TIM1_OCPolarity_High) || \
N                                       (POLARITY == TIM1_OCPolarity_Low))
X#define IS_TIM1_OC_POLARITY(POLARITY) ((POLARITY == TIM1_OCPolarity_High) ||                                        (POLARITY == TIM1_OCPolarity_Low))
N
N/* TIM1 Output Compare N Polarity -------------------------------------------*/
N#define TIM1_OCNPolarity_High              ((u16)0x0000) //	TIM1输出比较N极性高 ；
N#define TIM1_OCNPolarity_Low               ((u16)0x0001) //	TIM1输出比较N极性低 ；
N
N#define IS_TIM1_OCN_POLARITY(POLARITY) ((POLARITY == TIM1_OCNPolarity_High) || \
N                                        (POLARITY == TIM1_OCNPolarity_Low))
X#define IS_TIM1_OCN_POLARITY(POLARITY) ((POLARITY == TIM1_OCNPolarity_High) ||                                         (POLARITY == TIM1_OCNPolarity_Low))
N
N/* TIM1 Output Compare states -----------------------------------------------*/
N#define TIM1_OutputState_Disable           ((u16)0x0000) // 失能输出比较状态 ；
N#define TIM1_OutputState_Enable            ((u16)0x0001) // 使能输出比较状态 ；
N
N#define IS_TIM1_OUTPUT_STATE(STATE) ((STATE == TIM1_OutputState_Disable) || \
N                                     (STATE == TIM1_OutputState_Enable))
X#define IS_TIM1_OUTPUT_STATE(STATE) ((STATE == TIM1_OutputState_Disable) ||                                      (STATE == TIM1_OutputState_Enable))
N
N/* TIM1 Output Compare N States ---------------------------------------------*/
N#define TIM1_OutputNState_Disable          ((u16)0x0000) //	失能输出比较N状态 ；
N#define TIM1_OutputNState_Enable           ((u16)0x0001) //	使能输出比较N状态 ；
N
N#define IS_TIM1_OUTPUTN_STATE(STATE) ((STATE == TIM1_OutputNState_Disable) || \
N                                      (STATE == TIM1_OutputNState_Enable))
X#define IS_TIM1_OUTPUTN_STATE(STATE) ((STATE == TIM1_OutputNState_Disable) ||                                       (STATE == TIM1_OutputNState_Enable))
N
N/* Break Input enable/disable -----------------------------------------------*/
N#define TIM1_Break_Enable                  ((u16)0x1000) // 使能TIM1刹车输入 ；
N#define TIM1_Break_Disable                 ((u16)0x0000) // 失能TIM1刹车输入 ；
N
N#define IS_TIM1_BREAK_STATE(STATE) ((STATE == TIM1_Break_Enable) || \
N                                    (STATE == TIM1_Break_Disable))
X#define IS_TIM1_BREAK_STATE(STATE) ((STATE == TIM1_Break_Enable) ||                                     (STATE == TIM1_Break_Disable))
N
N/* Break Polarity -----------------------------------------------------------*/
N#define TIM1_BreakPolarity_Low             ((u16)0x0000) // TIM1刹车输入管脚极性低 ；
N#define TIM1_BreakPolarity_High            ((u16)0x2000) // TIM1刹车输入管脚极性高 ；
N
N#define IS_TIM1_BREAK_POLARITY(POLARITY) ((POLARITY == TIM1_BreakPolarity_Low) || \
N                                          (POLARITY == TIM1_BreakPolarity_High))
X#define IS_TIM1_BREAK_POLARITY(POLARITY) ((POLARITY == TIM1_BreakPolarity_Low) ||                                           (POLARITY == TIM1_BreakPolarity_High))
N
N/* TIM1 AOE Bit Set/Reset ---------------------------------------------------*/
N#define TIM1_AutomaticOutput_Enable        ((u16)0x4000) // 自动输出功能使能 ；
N#define TIM1_AutomaticOutput_Disable       ((u16)0x0000) // 自动输出功能失能 ；
N
N#define IS_TIM1_AUTOMATIC_OUTPUT_STATE(STATE) ((STATE == TIM1_AutomaticOutput_Enable) || \
N                                               (STATE == TIM1_AutomaticOutput_Disable))
X#define IS_TIM1_AUTOMATIC_OUTPUT_STATE(STATE) ((STATE == TIM1_AutomaticOutput_Enable) ||                                                (STATE == TIM1_AutomaticOutput_Disable))
N/* Lock levels --------------------------------------------------------------*/
N#define TIM1_LOCKLevel_OFF                 ((u16)0x0000) // 不锁任何位 ；
N#define TIM1_LOCKLevel_1                   ((u16)0x0100) //	使用锁电平1 ；
N#define TIM1_LOCKLevel_2                   ((u16)0x0200) //	使用锁电平2	；
N#define TIM1_LOCKLevel_3                   ((u16)0x0300) //	使用锁电平3	；
N
N#define IS_TIM1_LOCK_LEVEL(LEVEL) ((LEVEL == TIM1_LOCKLevel_OFF) || \
N                                   (LEVEL == TIM1_LOCKLevel_1) || \
N                                   (LEVEL == TIM1_LOCKLevel_2) || \
N                                   (LEVEL == TIM1_LOCKLevel_3))
X#define IS_TIM1_LOCK_LEVEL(LEVEL) ((LEVEL == TIM1_LOCKLevel_OFF) ||                                    (LEVEL == TIM1_LOCKLevel_1) ||                                    (LEVEL == TIM1_LOCKLevel_2) ||                                    (LEVEL == TIM1_LOCKLevel_3))
N
N/* OSSI: Off-State Selection for Idle mode states ---------------------------*/
N#define TIM1_OSSIState_Enable              ((u16)0x0400) // 使能TIM1 OSSI状态 ；
N#define TIM1_OSSIState_Disable             ((u16)0x0000) // 失能TIM1 OSSI状态 ；
N
N#define IS_TIM1_OSSI_STATE(STATE) ((STATE == TIM1_OSSIState_Enable) || \
N                                   (STATE == TIM1_OSSIState_Disable))
X#define IS_TIM1_OSSI_STATE(STATE) ((STATE == TIM1_OSSIState_Enable) ||                                    (STATE == TIM1_OSSIState_Disable))
N
N/* OSSR: Off-State Selection for Run mode states ----------------------------*/
N#define TIM1_OSSRState_Enable              ((u16)0x0800) // 使能TIM1 OSSR状态 ；
N#define TIM1_OSSRState_Disable             ((u16)0x0000) // 失能TIM1 OSSR状态 ；
N
N#define IS_TIM1_OSSR_STATE(STATE) ((STATE == TIM1_OSSRState_Enable) || \
N                                   (STATE == TIM1_OSSRState_Disable))
X#define IS_TIM1_OSSR_STATE(STATE) ((STATE == TIM1_OSSRState_Enable) ||                                    (STATE == TIM1_OSSRState_Disable))
N
N/* TIM1 Output Compare Idle State -------------------------------------------*/
N#define TIM1_OCIdleState_Set               ((u16)0x0001) // 
N#define TIM1_OCIdleState_Reset             ((u16)0x0000) // 当MOE=0设置TIM1输出比较空闲状态
N
N#define IS_TIM1_OCIDLE_STATE(STATE) ((STATE == TIM1_OCIdleState_Set) || \
N                                     (STATE == TIM1_OCIdleState_Reset))
X#define IS_TIM1_OCIDLE_STATE(STATE) ((STATE == TIM1_OCIdleState_Set) ||                                      (STATE == TIM1_OCIdleState_Reset))
N
N/* TIM1 Output Compare N Idle State -----------------------------------------*/
N#define TIM1_OCNIdleState_Set              ((u16)0x0001) //
N#define TIM1_OCNIdleState_Reset            ((u16)0x0000) // 当MOE=0设置TIM1输出比较N空闲状态 ；
N
N#define IS_TIM1_OCNIDLE_STATE(STATE) ((STATE == TIM1_OCNIdleState_Set) || \
N                                      (STATE == TIM1_OCNIdleState_Reset))
X#define IS_TIM1_OCNIDLE_STATE(STATE) ((STATE == TIM1_OCNIdleState_Set) ||                                       (STATE == TIM1_OCNIdleState_Reset))
N
N/* TIM1 Input Capture Polarity ----------------------------------------------*/
N#define  TIM1_ICPolarity_Rising            ((u16)0x0000) // TIM1输入捕获上升沿 ；
N#define  TIM1_ICPolarity_Falling           ((u16)0x0001) // TIM1输入捕获下降沿 ；
N
N#define IS_TIM1_IC_POLARITY(POLARITY) ((POLARITY == TIM1_ICPolarity_Rising) || \
N                                       (POLARITY == TIM1_ICPolarity_Falling))
X#define IS_TIM1_IC_POLARITY(POLARITY) ((POLARITY == TIM1_ICPolarity_Rising) ||                                        (POLARITY == TIM1_ICPolarity_Falling))
N
N/* TIM1 Input Capture Selection ---------------------------------------------*/
N#define TIM1_ICSelection_DirectTI          ((u16)0x0001) // TIM1输入2，3或4选择对应地与IC1或IC2或IC3或IC4相连 ；
N#define TIM1_ICSelection_IndirectTI        ((u16)0x0002) // TIM1输入2，3或4选择对应地与IC2或IC1或IC4或IC3相连 ；
N#define TIM1_ICSelection_TRC               ((u16)0x0003) // TIM1输入2，3或4选择与TRC相连 ；
N
N#define IS_TIM1_IC_SELECTION(SELECTION) ((SELECTION == TIM1_ICSelection_DirectTI) || \
N                                         (SELECTION == TIM1_ICSelection_IndirectTI) || \
N                                         (SELECTION == TIM1_ICSelection_TRC))
X#define IS_TIM1_IC_SELECTION(SELECTION) ((SELECTION == TIM1_ICSelection_DirectTI) ||                                          (SELECTION == TIM1_ICSelection_IndirectTI) ||                                          (SELECTION == TIM1_ICSelection_TRC))
N
N/* TIM1 Input Capture Prescaler ---------------------------------------------*/
N#define TIM1_ICPSC_DIV1                    ((u16)0x0000) // TIM1捕获在捕获输入上每探测到一个边沿执行一次 ；
N#define TIM1_ICPSC_DIV2                    ((u16)0x0004) //	TIM1捕获每2个事件执行一次 ；
N#define TIM1_ICPSC_DIV4                    ((u16)0x0008) //	TIM1捕获每3个事件执行一次 ；
N#define TIM1_ICPSC_DIV8                    ((u16)0x000C) //	TIM1捕获每4个事件执行一次 ；
N
N#define IS_TIM1_IC_PRESCALER(PRESCALER) ((PRESCALER == TIM1_ICPSC_DIV1) || \
N                                         (PRESCALER == TIM1_ICPSC_DIV2) || \
N                                         (PRESCALER == TIM1_ICPSC_DIV4) || \
N                                         (PRESCALER == TIM1_ICPSC_DIV8))
X#define IS_TIM1_IC_PRESCALER(PRESCALER) ((PRESCALER == TIM1_ICPSC_DIV1) ||                                          (PRESCALER == TIM1_ICPSC_DIV2) ||                                          (PRESCALER == TIM1_ICPSC_DIV4) ||                                          (PRESCALER == TIM1_ICPSC_DIV8))
N                                         
N/* TIM1 Input Capture Filer Value ---------------------------------------------*/
N#define IS_TIM1_IC_FILTER(ICFILTER) (ICFILTER <= 0xF)                                              
N
N/* TIM1 interrupt sources ---------------------------------------------------*/
N#define TIM1_IT_Update                     ((u16)0x0001) //	TIM1中断源 ；
N#define TIM1_IT_CC1                        ((u16)0x0002) //	TIM1捕获/比较1中断源 ；
N#define TIM1_IT_CC2                        ((u16)0x0004) //	TIM1捕获/比较2中断源 ；
N#define TIM1_IT_CC3                        ((u16)0x0008) // TIM1捕获/比较3中断源 ；
N#define TIM1_IT_CC4                        ((u16)0x0010) //	TIM1捕获/比较4中断源 ；
N#define TIM1_IT_COM                        ((u16)0x0020) //	TIM1 COM中断源 ；
N#define TIM1_IT_Trigger                    ((u16)0x0040) //	TIM1触发中断源 ；
N#define TIM1_IT_Break                      ((u16)0x0080) //	TIM1刹车中断源 ；
N
N#define IS_TIM1_IT(IT) (((IT & (u16)0xFF00) == 0x0000) && (IT != 0x0000))
N
N#define IS_TIM1_GET_IT(IT) ((IT == TIM1_IT_Update) || \
N                            (IT == TIM1_IT_CC1) || \
N                            (IT == TIM1_IT_CC2) || \
N                            (IT == TIM1_IT_CC3) || \
N                            (IT == TIM1_IT_CC4) || \
N                            (IT == TIM1_IT_COM) || \
N                            (IT == TIM1_IT_Trigger) || \
N                            (IT == TIM1_IT_Break))
X#define IS_TIM1_GET_IT(IT) ((IT == TIM1_IT_Update) ||                             (IT == TIM1_IT_CC1) ||                             (IT == TIM1_IT_CC2) ||                             (IT == TIM1_IT_CC3) ||                             (IT == TIM1_IT_CC4) ||                             (IT == TIM1_IT_COM) ||                             (IT == TIM1_IT_Trigger) ||                             (IT == TIM1_IT_Break))
N
N/* TIM1 DMA Base address ----------------------------------------------------*/
N#define TIM1_DMABase_CR1                   ((u16)0x0000) // TIM1 CR1寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CR2                   ((u16)0x0001) //	TIM1 CR2寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_SMCR                  ((u16)0x0002) //	TIM1 SMCR寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_DIER                  ((u16)0x0003) //	TIM1 DIER寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_SR                    ((u16)0x0004) //	TIM1 SR寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_EGR                   ((u16)0x0005) //	TIM1 EGR寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CCMR1                 ((u16)0x0006) //	TIM1 CCMR1寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CCMR2                 ((u16)0x0007) //	TIM1 CCMR2寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CCER                  ((u16)0x0008) //	TIM1 CCER寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CNT                   ((u16)0x0009) //	TIM1 CNT寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_PSC                   ((u16)0x000A) //	TIM1 PSC寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_ARR                   ((u16)0x000B) //	TIM1 APR寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_RCR                   ((u16)0x000C) //	TIM1 RCR寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CCR1                  ((u16)0x000D) //	TIM1 CCR1寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CCR2                  ((u16)0x000E) //	TIM1 CCR2寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CCR3                  ((u16)0x000F) //	TIM1 CCR3寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_CCR4                  ((u16)0x0010) //	TIM1 CCR4寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_BDTR                  ((u16)0x0011) //	TIM1 BDTR寄存器作为DMA传输起始 ；
N#define TIM1_DMABase_DCR                   ((u16)0x0012) //	TIM1 DCR寄存器作为DMA传输起始 ；
N
N#define IS_TIM1_DMA_BASE(BASE) ((BASE == TIM1_DMABase_CR1) || \
N                                (BASE == TIM1_DMABase_CR2) || \
N                                (BASE == TIM1_DMABase_SMCR) || \
N                                (BASE == TIM1_DMABase_DIER) || \
N                                (BASE == TIM1_DMABase_SR) || \
N                                (BASE == TIM1_DMABase_EGR) || \
N                                (BASE == TIM1_DMABase_CCMR1) || \
N                                (BASE == TIM1_DMABase_CCMR2) || \
N                                (BASE == TIM1_DMABase_CCER) || \
N                                (BASE == TIM1_DMABase_CNT) || \
N                                (BASE == TIM1_DMABase_PSC) || \
N                                (BASE == TIM1_DMABase_ARR) || \
N                                (BASE == TIM1_DMABase_RCR) || \
N                                (BASE == TIM1_DMABase_CCR1) || \
N                                (BASE == TIM1_DMABase_CCR2) || \
N                                (BASE == TIM1_DMABase_CCR3) || \
N                                (BASE == TIM1_DMABase_CCR4) || \
N                                (BASE == TIM1_DMABase_BDTR) || \
N                                (BASE == TIM1_DMABase_DCR))
X#define IS_TIM1_DMA_BASE(BASE) ((BASE == TIM1_DMABase_CR1) ||                                 (BASE == TIM1_DMABase_CR2) ||                                 (BASE == TIM1_DMABase_SMCR) ||                                 (BASE == TIM1_DMABase_DIER) ||                                 (BASE == TIM1_DMABase_SR) ||                                 (BASE == TIM1_DMABase_EGR) ||                                 (BASE == TIM1_DMABase_CCMR1) ||                                 (BASE == TIM1_DMABase_CCMR2) ||                                 (BASE == TIM1_DMABase_CCER) ||                                 (BASE == TIM1_DMABase_CNT) ||                                 (BASE == TIM1_DMABase_PSC) ||                                 (BASE == TIM1_DMABase_ARR) ||                                 (BASE == TIM1_DMABase_RCR) ||                                 (BASE == TIM1_DMABase_CCR1) ||                                 (BASE == TIM1_DMABase_CCR2) ||                                 (BASE == TIM1_DMABase_CCR3) ||                                 (BASE == TIM1_DMABase_CCR4) ||                                 (BASE == TIM1_DMABase_BDTR) ||                                 (BASE == TIM1_DMABase_DCR))
N
N/* TIM1 DMA Burst Length ----------------------------------------------------*/
N#define TIM1_DMABurstLength_1Byte          ((u16)0x0000) // TIM1 DMA连续传送长度1字 ；
N#define TIM1_DMABurstLength_2Bytes         ((u16)0x0100) // TIM1 DMA连续传送长度2字 ；
N#define TIM1_DMABurstLength_3Bytes         ((u16)0x0200) // TIM1 DMA连续传送长度3字 ；
N#define TIM1_DMABurstLength_4Bytes         ((u16)0x0300) // TIM1 DMA连续传送长度4字 ；
N#define TIM1_DMABurstLength_5Bytes         ((u16)0x0400) // TIM1 DMA连续传送长度5字 ；
N#define TIM1_DMABurstLength_6Bytes         ((u16)0x0500) // TIM1 DMA连续传送长度6字 ；
N#define TIM1_DMABurstLength_7Bytes         ((u16)0x0600) // TIM1 DMA连续传送长度7字 ；
N#define TIM1_DMABurstLength_8Bytes         ((u16)0x0700) // TIM1 DMA连续传送长度8字 ；
N#define TIM1_DMABurstLength_9Bytes         ((u16)0x0800) // TIM1 DMA连续传送长度9字 ；
N#define TIM1_DMABurstLength_10Bytes        ((u16)0x0900) // TIM1 DMA连续传送长度10字 ；
N#define TIM1_DMABurstLength_11Bytes        ((u16)0x0A00) // TIM1 DMA连续传送长度11字 ；
N#define TIM1_DMABurstLength_12Bytes        ((u16)0x0B00) // TIM1 DMA连续传送长度12字 ；
N#define TIM1_DMABurstLength_13Bytes        ((u16)0x0C00) // TIM1 DMA连续传送长度13字 ；
N#define TIM1_DMABurstLength_14Bytes        ((u16)0x0D00) // TIM1 DMA连续传送长度14字 ；
N#define TIM1_DMABurstLength_15Bytes        ((u16)0x0E00) // TIM1 DMA连续传送长度15字 ；
N#define TIM1_DMABurstLength_16Bytes        ((u16)0x0F00) // TIM1 DMA连续传送长度16字 ；
N#define TIM1_DMABurstLength_17Bytes        ((u16)0x1000) // TIM1 DMA连续传送长度17字 ；
N#define TIM1_DMABurstLength_18Bytes        ((u16)0x1100) // TIM1 DMA连续传送长度18字 ；
N
N#define IS_TIM1_DMA_LENGTH(LENGTH) ((LENGTH == TIM1_DMABurstLength_1Byte) || \
N                                    (LENGTH == TIM1_DMABurstLength_2Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_3Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_4Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_5Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_6Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_7Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_8Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_9Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_10Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_11Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_12Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_13Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_14Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_15Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_16Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_17Bytes) || \
N                                    (LENGTH == TIM1_DMABurstLength_18Bytes))
X#define IS_TIM1_DMA_LENGTH(LENGTH) ((LENGTH == TIM1_DMABurstLength_1Byte) ||                                     (LENGTH == TIM1_DMABurstLength_2Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_3Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_4Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_5Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_6Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_7Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_8Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_9Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_10Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_11Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_12Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_13Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_14Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_15Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_16Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_17Bytes) ||                                     (LENGTH == TIM1_DMABurstLength_18Bytes))
N
N/* TIM1 DMA sources ---------------------------------------------------------*/
N#define TIM1_DMA_Update                    ((u16)0x0100) // TIM1更新DMA源 ;
N#define TIM1_DMA_CC1                       ((u16)0x0200) // TIM1捕获/比较 1DMA源 ；
N#define TIM1_DMA_CC2                       ((u16)0x0400) // TIM1捕获/比较 2DMA源 ；
N#define TIM1_DMA_CC3                       ((u16)0x0800) // TIM1捕获/比较 3DMA源 ；
N#define TIM1_DMA_CC4                       ((u16)0x1000) // TIM1捕获/比较 4DMA源 ；
N#define TIM1_DMA_COM                       ((u16)0x2000) //	TIM1 COM DMA源 ；
N#define TIM1_DMA_Trigger                   ((u16)0x4000) //	TIM1触发DMA源 ；
N
N#define IS_TIM1_DMA_SOURCE(SOURCE) (((SOURCE & (u16)0x80FF) == 0x0000) && (SOURCE != 0x0000))
N
N/* TIM1 External Trigger Prescaler ------------------------------------------*/
N#define TIM1_ExtTRGPSC_OFF                 ((u16)0x0000) // TIM1 ETRP 预分频 OFF ；
N#define TIM1_ExtTRGPSC_DIV2                ((u16)0x1000) //	TIM1 ETRP频率除以2 ；
N#define TIM1_ExtTRGPSC_DIV4                ((u16)0x2000) //	TIM1 ETRP频率除以4 ；
N#define TIM1_ExtTRGPSC_DIV8                ((u16)0x3000) //	TIM1 ETRP频率除以8 ；
N
N#define IS_TIM1_EXT_PRESCALER(PRESCALER) ((PRESCALER == TIM1_ExtTRGPSC_OFF) || \
N                                          (PRESCALER == TIM1_ExtTRGPSC_DIV2) || \
N                                          (PRESCALER == TIM1_ExtTRGPSC_DIV4) || \
N                                          (PRESCALER == TIM1_ExtTRGPSC_DIV8))
X#define IS_TIM1_EXT_PRESCALER(PRESCALER) ((PRESCALER == TIM1_ExtTRGPSC_OFF) ||                                           (PRESCALER == TIM1_ExtTRGPSC_DIV2) ||                                           (PRESCALER == TIM1_ExtTRGPSC_DIV4) ||                                           (PRESCALER == TIM1_ExtTRGPSC_DIV8))
N
N/* TIM1 Internal Trigger Selection ------------------------------------------*/
N#define TIM1_TS_ITR0                       ((u16)0x0000) // TIM1内部触发0 ；
N#define TIM1_TS_ITR1                       ((u16)0x0010) // TIM1内部触发1 ；
N#define TIM1_TS_ITR2                       ((u16)0x0020) // TIM1内部触发2 ；
N#define TIM1_TS_ITR3                       ((u16)0x0030) // TIM1内部触发3 ；
N#define TIM1_TS_TI1F_ED	                   ((u16)0x0040) //	TIM1 IC1连接到TI1：使用边沿探测 ；
N#define TIM1_TS_TI1FP1                     ((u16)0x0050) //	TIM1 IC1连接到TI1 ；
N#define TIM1_TS_TI2FP2                     ((u16)0x0060) //	TIM1 IC2连接到TI2 ；
N#define TIM1_TS_ETRF                       ((u16)0x0070) //	TIM1外部触发输入 ；
N
N#define IS_TIM1_TRIGGER_SELECTION(SELECTION) ((SELECTION == TIM1_TS_ITR0) || \
N                                              (SELECTION == TIM1_TS_ITR1) || \
N                                              (SELECTION == TIM1_TS_ITR2) || \
N                                              (SELECTION == TIM1_TS_ITR3) || \
N                                              (SELECTION == TIM1_TS_TI1F_ED) || \
N                                              (SELECTION == TIM1_TS_TI1FP1) || \
N                                              (SELECTION == TIM1_TS_TI2FP2) || \
N                                              (SELECTION == TIM1_TS_ETRF))
X#define IS_TIM1_TRIGGER_SELECTION(SELECTION) ((SELECTION == TIM1_TS_ITR0) ||                                               (SELECTION == TIM1_TS_ITR1) ||                                               (SELECTION == TIM1_TS_ITR2) ||                                               (SELECTION == TIM1_TS_ITR3) ||                                               (SELECTION == TIM1_TS_TI1F_ED) ||                                               (SELECTION == TIM1_TS_TI1FP1) ||                                               (SELECTION == TIM1_TS_TI2FP2) ||                                               (SELECTION == TIM1_TS_ETRF))
N
N#define IS_TIM1_INTERNAL_TRIGGER_SELECTION(SELECTION) ((SELECTION == TIM1_TS_ITR0) || \
N                                                       (SELECTION == TIM1_TS_ITR1) || \
N                                                       (SELECTION == TIM1_TS_ITR2) || \
N                                                       (SELECTION == TIM1_TS_ITR3))
X#define IS_TIM1_INTERNAL_TRIGGER_SELECTION(SELECTION) ((SELECTION == TIM1_TS_ITR0) ||                                                        (SELECTION == TIM1_TS_ITR1) ||                                                        (SELECTION == TIM1_TS_ITR2) ||                                                        (SELECTION == TIM1_TS_ITR3))
N
N#define IS_TIM1_TIX_TRIGGER_SELECTION(SELECTION) ((SELECTION == TIM1_TS_TI1F_ED) || \
N                                                  (SELECTION == TIM1_TS_TI1FP1) || \
N                                                  (SELECTION == TIM1_TS_TI2FP2))
X#define IS_TIM1_TIX_TRIGGER_SELECTION(SELECTION) ((SELECTION == TIM1_TS_TI1F_ED) ||                                                   (SELECTION == TIM1_TS_TI1FP1) ||                                                   (SELECTION == TIM1_TS_TI2FP2))
N
N/* TIM1 External Trigger Polarity -------------------------------------------*/
N#define TIM1_ExtTRGPolarity_Inverted       ((u16)0x8000) //	TIM1外部触发极性翻转：低电平或下降沿有效 ；
N#define TIM1_ExtTRGPolarity_NonInverted    ((u16)0x0000) //	TIM1外部触发极性非翻转：高电平或上升沿有效 ；
N
N#define IS_TIM1_EXT_POLARITY(POLARITY) ((POLARITY == TIM1_ExtTRGPolarity_Inverted) || \
N                                        (POLARITY == TIM1_ExtTRGPolarity_NonInverted))
X#define IS_TIM1_EXT_POLARITY(POLARITY) ((POLARITY == TIM1_ExtTRGPolarity_Inverted) ||                                         (POLARITY == TIM1_ExtTRGPolarity_NonInverted))
N
N/* TIM1 Prescaler Reload Mode -----------------------------------------------*/
N#define TIM1_PSCReloadMode_Update          ((u16)0x0000) // TIM1预分频值在更新事件装入 ；
N#define TIM1_PSCReloadMode_Immediate       ((u16)0x0001) // TIM1预分频值即时装入 ；
N
N#define IS_TIM1_PRESCALER_RELOAD(RELOAD) ((RELOAD == TIM1_PSCReloadMode_Update) || \
N                                          (RELOAD == TIM1_PSCReloadMode_Immediate))
X#define IS_TIM1_PRESCALER_RELOAD(RELOAD) ((RELOAD == TIM1_PSCReloadMode_Update) ||                                           (RELOAD == TIM1_PSCReloadMode_Immediate))
N
N/* TIM1 Forced Action -------------------------------------------------------*/
N#define TIM1_ForcedAction_Active           ((u16)0x0050) //	置为OCxREF上的活动电平 ；
N#define TIM1_ForcedAction_InActive         ((u16)0x0040) //	置为OCxREF上的非活动电平 ；
N
N#define IS_TIM1_FORCED_ACTION(ACTION) ((ACTION == TIM1_ForcedAction_Active) || \
N                                       (ACTION == TIM1_ForcedAction_InActive))
X#define IS_TIM1_FORCED_ACTION(ACTION) ((ACTION == TIM1_ForcedAction_Active) ||                                        (ACTION == TIM1_ForcedAction_InActive))
N
N/* TIM1 Encoder Mode --------------------------------------------------------*/ 
N#define TIM1_EncoderMode_TI1               ((u16)0x0001) // 使用TIM1编码模式1 ；
N#define TIM1_EncoderMode_TI2               ((u16)0x0002) // 使用TIM1编码模式2 ；
N#define TIM1_EncoderMode_TI12              ((u16)0x0003) // 使用TIM1编码模式3 ；
N
N#define IS_TIM1_ENCODER_MODE(MODE) ((MODE == TIM1_EncoderMode_TI1) || \
N                                    (MODE == TIM1_EncoderMode_TI2) || \
N                                    (MODE == TIM1_EncoderMode_TI12))
X#define IS_TIM1_ENCODER_MODE(MODE) ((MODE == TIM1_EncoderMode_TI1) ||                                     (MODE == TIM1_EncoderMode_TI2) ||                                     (MODE == TIM1_EncoderMode_TI12))
N
N/* TIM1 Event Source --------------------------------------------------------*/
N#define TIM1_EventSource_Update            ((u16)0x0001) // TIM更新事件源 ；
N#define TIM1_EventSource_CC1               ((u16)0x0002) // TIM捕获比较 1 事件源 ；
N#define TIM1_EventSource_CC2               ((u16)0x0004) // TIM捕获比较 2 事件源 ；
N#define TIM1_EventSource_CC3               ((u16)0x0008) // TIM捕获比较 3 事件源 ；
N#define TIM1_EventSource_CC4               ((u16)0x0010) // TIM捕获比较 4 事件源 ；
N#define TIM1_EventSource_COM               ((u16)0x0020) //
N#define TIM1_EventSource_Trigger           ((u16)0x0040) //	TIM触发事件源 ；
N#define TIM1_EventSource_Break             ((u16)0x0080) //
N
N#define IS_TIM1_EVENT_SOURCE(SOURCE) (((SOURCE & (u16)0xFF00) == 0x0000) && (SOURCE != 0x0000))
N                                      
N
N/* TIM1 Update Source --------------------------------------------------------*/
N#define TIM1_UpdateSource_Global           ((u16)0x0000) // 生成重复的脉冲：在更新事件时计数器不停止 ；
N#define TIM1_UpdateSource_Regular          ((u16)0x0001) //	生成单一的脉冲：计数器在下一个更新事件停止 ；
N
N#define IS_TIM1_UPDATE_SOURCE(SOURCE) ((SOURCE == TIM1_UpdateSource_Global) || \
N                                       (SOURCE == TIM1_UpdateSource_Regular))
X#define IS_TIM1_UPDATE_SOURCE(SOURCE) ((SOURCE == TIM1_UpdateSource_Global) ||                                        (SOURCE == TIM1_UpdateSource_Regular))
N
N/* TIM1 Ouput Compare Preload State ------------------------------------------*/
N#define TIM1_OCPreload_Enable              ((u16)0x0001) //	TIM1在CCR1上的预装载寄存器使能 ；
N#define TIM1_OCPreload_Disable             ((u16)0x0000) //	TIM1在CCR1上的预装载寄存器失能 ；
N
N#define IS_TIM1_OCPRELOAD_STATE(STATE) ((STATE == TIM1_OCPreload_Enable) || \
N                                        (STATE == TIM1_OCPreload_Disable))
X#define IS_TIM1_OCPRELOAD_STATE(STATE) ((STATE == TIM1_OCPreload_Enable) ||                                         (STATE == TIM1_OCPreload_Disable))
N
N/* TIM1 Ouput Compare Fast State ---------------------------------------------*/
N#define TIM1_OCFast_Enable                 ((u16)0x0001) //	TIM1输出比较快速特征性能使能 ；
N#define TIM1_OCFast_Disable                ((u16)0x0000) //	TIM1输出比较快速特征性能失能 ；
N
N#define IS_TIM1_OCFAST_STATE(STATE) ((STATE == TIM1_OCFast_Enable) || \
N                                     (STATE == TIM1_OCFast_Disable))
X#define IS_TIM1_OCFAST_STATE(STATE) ((STATE == TIM1_OCFast_Enable) ||                                      (STATE == TIM1_OCFast_Disable))
N                                     
N/* TIM1 Ouput Compare Clear State --------------------------------------------*/
N#define TIM1_OCClear_Enable                ((u16)0x0001) // TIM1输出比较清除使能 ；
N#define TIM1_OCClear_Disable               ((u16)0x0000) // TIM1输出比较清除失能 ；
N
N#define IS_TIM1_OCCLEAR_STATE(STATE) ((STATE == TIM1_OCClear_Enable) || \
N                                      (STATE == TIM1_OCClear_Disable))                                     
X#define IS_TIM1_OCCLEAR_STATE(STATE) ((STATE == TIM1_OCClear_Enable) ||                                       (STATE == TIM1_OCClear_Disable))                                     
N
N/* TIM1 Trigger Output Source ------------------------------------------------*/ 
N#define TIM1_TRGOSource_Reset              ((u16)0x0000) //	使用寄存器TIM1_EGR的UG位作为触发输出（TRGO） ；
N#define TIM1_TRGOSource_Enable             ((u16)0x0010) //	使用计数器使能CEN作为触发输出（TRGO） ；
N#define TIM1_TRGOSource_Update             ((u16)0x0020) //	使用更新事件作为触发输出（TRGO） ；
N#define TIM1_TRGOSource_OC1                ((u16)0x0030) //	一旦捕获或者比较匹配发生，当标志位CC1F被设置时触发输出发送一个肯定脉冲（TRGO）；
N#define TIM1_TRGOSource_OC1Ref             ((u16)0x0040) // 使用OC1REF作为触发输出（TRGO）；
N#define TIM1_TRGOSource_OC2Ref             ((u16)0x0050) //	使用OC2REF作为触发输出（TRGO）；
N#define TIM1_TRGOSource_OC3Ref             ((u16)0x0060) //	使用OC3REF作为触发输出（TRGO）；
N#define TIM1_TRGOSource_OC4Ref             ((u16)0x0070) //	使用OC4REF作为触发输出（TRGO）；
N
N#define IS_TIM1_TRGO_SOURCE(SOURCE) ((SOURCE == TIM1_TRGOSource_Reset) || \
N                                     (SOURCE == TIM1_TRGOSource_Enable) || \
N                                     (SOURCE == TIM1_TRGOSource_Update) || \
N                                     (SOURCE == TIM1_TRGOSource_OC1) || \
N                                     (SOURCE == TIM1_TRGOSource_OC1Ref) || \
N                                     (SOURCE == TIM1_TRGOSource_OC2Ref) || \
N                                     (SOURCE == TIM1_TRGOSource_OC3Ref) || \
N                                     (SOURCE == TIM1_TRGOSource_OC4Ref))
X#define IS_TIM1_TRGO_SOURCE(SOURCE) ((SOURCE == TIM1_TRGOSource_Reset) ||                                      (SOURCE == TIM1_TRGOSource_Enable) ||                                      (SOURCE == TIM1_TRGOSource_Update) ||                                      (SOURCE == TIM1_TRGOSource_OC1) ||                                      (SOURCE == TIM1_TRGOSource_OC1Ref) ||                                      (SOURCE == TIM1_TRGOSource_OC2Ref) ||                                      (SOURCE == TIM1_TRGOSource_OC3Ref) ||                                      (SOURCE == TIM1_TRGOSource_OC4Ref))
N
N/* TIM1 Slave Mode ----------------------------------------------------------*/
N#define TIM1_SlaveMode_Reset               ((u16)0x0004) //	选中触发信号（TRGI）的上升沿重初始化计数器并触发寄存器的更新 ；
N#define TIM1_SlaveMode_Gated               ((u16)0x0005) //	当触发信号（TRGI）为高电平计数器时钟使能  ；
N#define TIM1_SlaveMode_Trigger             ((u16)0x0006) //	计数器在触发（TRGI）的上升沿开始 ；
N#define TIM1_SlaveMode_External1           ((u16)0x0007) //	选中触发（TRGI）的上升沿作为计数器时钟 ；
N
N#define IS_TIM1_SLAVE_MODE(MODE) ((MODE == TIM1_SlaveMode_Reset) || \
N                                  (MODE == TIM1_SlaveMode_Gated) || \
N                                  (MODE == TIM1_SlaveMode_Trigger) || \
N                                  (MODE == TIM1_SlaveMode_External1))
X#define IS_TIM1_SLAVE_MODE(MODE) ((MODE == TIM1_SlaveMode_Reset) ||                                   (MODE == TIM1_SlaveMode_Gated) ||                                   (MODE == TIM1_SlaveMode_Trigger) ||                                   (MODE == TIM1_SlaveMode_External1))
N
N/* TIM1 TIx External Clock Source -------------------------------------------*/
N#define TIM1_TIxExternalCLK1Source_TI1     ((u16)0x0050)
N#define TIM1_TIxExternalCLK1Source_TI2     ((u16)0x0060)
N#define TIM1_TIxExternalCLK1Source_TI1ED   ((u16)0x0040)
N
N#define IS_TIM1_TIXCLK_SOURCE(SOURCE) ((SOURCE == TIM1_TIxExternalCLK1Source_TI1) || \
N                                       (SOURCE == TIM1_TIxExternalCLK1Source_TI2) || \
N                                       (SOURCE == TIM1_TIxExternalCLK1Source_TI1ED))
X#define IS_TIM1_TIXCLK_SOURCE(SOURCE) ((SOURCE == TIM1_TIxExternalCLK1Source_TI1) ||                                        (SOURCE == TIM1_TIxExternalCLK1Source_TI2) ||                                        (SOURCE == TIM1_TIxExternalCLK1Source_TI1ED))
N
N/* TIM1 Master Slave Mode ---------------------------------------------------*/
N#define TIM1_MasterSlaveMode_Enable        ((u16)0x0001) //	TIM1主/从模式使能 ；
N#define TIM1_MasterSlaveMode_Disable       ((u16)0x0000) //	TIM1主/从模式失能 ；
N
N#define IS_TIM1_MSM_STATE(STATE) ((STATE == TIM1_MasterSlaveMode_Enable) || \
N                                  (STATE == TIM1_MasterSlaveMode_Disable))
X#define IS_TIM1_MSM_STATE(STATE) ((STATE == TIM1_MasterSlaveMode_Enable) ||                                   (STATE == TIM1_MasterSlaveMode_Disable))
N
N/* TIM1 Flags ---------------------------------------------------------------*/
N#define TIM1_FLAG_Update                   ((u16)0x0001) // TIM1更新标志位 ；
N#define TIM1_FLAG_CC1                      ((u16)0x0002) // TIM1捕获/比较 1 标志位 ；
N#define TIM1_FLAG_CC2                      ((u16)0x0004) // TIM1捕获/比较 2 标志位 ；
N#define TIM1_FLAG_CC3                      ((u16)0x0008) // TIM1捕获/比较 3 标志位 ；
N#define TIM1_FLAG_CC4                      ((u16)0x0010) // TIM1捕获/比较 4 标志位 ；
N#define TIM1_FLAG_COM                      ((u16)0x0020) // TIM1 COM标志位 ；
N#define TIM1_FLAG_Trigger                  ((u16)0x0040) //	TIM1触发标志位 ；
N#define TIM1_FLAG_Break                    ((u16)0x0080) //	TIM1刹车标志位 ；
N#define TIM1_FLAG_CC1OF                    ((u16)0x0200) // TIM1捕获/比较 1 溢出标志位 ；
N#define TIM1_FLAG_CC2OF                    ((u16)0x0400) // TIM1捕获/比较 2 溢出标志位 ；
N#define TIM1_FLAG_CC3OF                    ((u16)0x0800) // TIM1捕获/比较 3 溢出标志位 ；
N#define TIM1_FLAG_CC4OF                    ((u16)0x1000) // TIM1捕获/比较 4 溢出标志位 ；
N
N#define IS_TIM1_GET_FLAG(FLAG) ((FLAG == TIM1_FLAG_Update) || \
N                                (FLAG == TIM1_FLAG_CC1) || \
N                                (FLAG == TIM1_FLAG_CC2) || \
N                                (FLAG == TIM1_FLAG_CC3) || \
N                                (FLAG == TIM1_FLAG_CC4) || \
N                                (FLAG == TIM1_FLAG_COM) || \
N                                (FLAG == TIM1_FLAG_Trigger) || \
N                                (FLAG == TIM1_FLAG_Break) || \
N                                (FLAG == TIM1_FLAG_CC1OF) || \
N                                (FLAG == TIM1_FLAG_CC2OF) || \
N                                (FLAG == TIM1_FLAG_CC3OF) || \
N                                (FLAG == TIM1_FLAG_CC4OF))
X#define IS_TIM1_GET_FLAG(FLAG) ((FLAG == TIM1_FLAG_Update) ||                                 (FLAG == TIM1_FLAG_CC1) ||                                 (FLAG == TIM1_FLAG_CC2) ||                                 (FLAG == TIM1_FLAG_CC3) ||                                 (FLAG == TIM1_FLAG_CC4) ||                                 (FLAG == TIM1_FLAG_COM) ||                                 (FLAG == TIM1_FLAG_Trigger) ||                                 (FLAG == TIM1_FLAG_Break) ||                                 (FLAG == TIM1_FLAG_CC1OF) ||                                 (FLAG == TIM1_FLAG_CC2OF) ||                                 (FLAG == TIM1_FLAG_CC3OF) ||                                 (FLAG == TIM1_FLAG_CC4OF))
N
N#define IS_TIM1_CLEAR_FLAG(FLAG) (((FLAG & (u16)0xE100) == 0x0000) && (FLAG != 0x0000))
N                                  
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
Nvoid TIM1_DeInit(void);
Nvoid TIM1_TimeBaseInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct);
Nvoid TIM1_OC1Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct);
Nvoid TIM1_OC2Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct);
Nvoid TIM1_OC3Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct);
Nvoid TIM1_OC4Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct);
Nvoid TIM1_BDTRConfig(TIM1_BDTRInitTypeDef *TIM1_BDTRInitStruct);
Nvoid TIM1_ICInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct);
Nvoid TIM1_PWMIConfig(TIM1_ICInitTypeDef* TIM1_ICInitStruct);
Nvoid TIM1_TimeBaseStructInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct);
Nvoid TIM1_OCStructInit(TIM1_OCInitTypeDef* TIM1_OCInitStruct);
Nvoid TIM1_ICStructInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct);
Nvoid TIM1_BDTRStructInit(TIM1_BDTRInitTypeDef* TIM1_BDTRInitStruct);
Nvoid TIM1_Cmd(FunctionalState NewState);
Nvoid TIM1_CtrlPWMOutputs(FunctionalState Newstate);
Nvoid TIM1_ITConfig(u16 TIM1_IT, FunctionalState NewState);
Nvoid TIM1_DMAConfig(u16 TIM1_DMABase, u16 TIM1_DMABurstLength);
Nvoid TIM1_DMACmd(u16 TIM1_DMASource, FunctionalState Newstate);
Nvoid TIM1_InternalClockConfig(void);
Nvoid TIM1_ETRClockMode1Config(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity, 
N                             u16 ExtTRGFilter);
Nvoid TIM1_ETRClockMode2Config(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
N                             u16 ExtTRGFilter);
Nvoid TIM1_ETRConfig(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
N                    u16 ExtTRGFilter);
Nvoid TIM1_ITRxExternalClockConfig(u16 TIM1_InputTriggerSource);
Nvoid TIM1_TIxExternalClockConfig(u16 TIM1_TIxExternalCLKSource, u16 TIM1_ICPolarity, 
N                                u8 ICFilter);
Nvoid TIM1_SelectInputTrigger(u16 TIM1_InputTriggerSource);
Nvoid TIM1_UpdateDisableConfig(FunctionalState Newstate);
Nvoid TIM1_UpdateRequestConfig(u8 TIM1_UpdateSource);
Nvoid TIM1_SelectHallSensor(FunctionalState Newstate);
Nvoid TIM1_SelectOnePulseMode(u16 TIM1_OPMode);
Nvoid TIM1_SelectOutputTrigger(u16 TIM1_TRGOSource);
Nvoid TIM1_SelectSlaveMode(u16 TIM1_SlaveMode);
Nvoid TIM1_SelectMasterSlaveMode(u16 TIM1_MasterSlaveMode);
Nvoid TIM1_EncoderInterfaceConfig(u16 TIM1_EncoderMode, u16 TIM1_IC1Polarity, 
N                                u16 TIM1_IC2Polarity);
Nvoid TIM1_PrescalerConfig(u16 Prescaler, u16 TIM1_PSCReloadMode);
Nvoid TIM1_CounterModeConfig(u16 TIM1_CounterMode);
Nvoid TIM1_ForcedOC1Config(u16 TIM1_ForcedAction);
Nvoid TIM1_ForcedOC2Config(u16 TIM1_ForcedAction);
Nvoid TIM1_ForcedOC3Config(u16 TIM1_ForcedAction);
Nvoid TIM1_ForcedOC4Config(u16 TIM1_ForcedAction);
Nvoid TIM1_ARRPreloadConfig(FunctionalState Newstate);
Nvoid TIM1_SelectCOM(FunctionalState Newstate);
Nvoid TIM1_SelectCCDMA(FunctionalState Newstate);
Nvoid TIM1_CCPreloadControl(FunctionalState Newstate);
Nvoid TIM1_OC1PreloadConfig(u16 TIM1_OCPreload);
Nvoid TIM1_OC2PreloadConfig(u16 TIM1_OCPreload);
Nvoid TIM1_OC3PreloadConfig(u16 TIM1_OCPreload);
Nvoid TIM1_OC4PreloadConfig(u16 TIM1_OCPreload);
Nvoid TIM1_OC1FastConfig(u16 TIM1_OCFast);
Nvoid TIM1_OC2FastConfig(u16 TIM1_OCFast);
Nvoid TIM1_OC3FastConfig(u16 TIM1_OCFast);
Nvoid TIM1_OC4FastConfig(u16 TIM1_OCFast);
Nvoid TIM1_ClearOC1Ref(u16 TIM1_OCClear);
Nvoid TIM1_ClearOC2Ref(u16 TIM1_OCClear);
Nvoid TIM1_ClearOC3Ref(u16 TIM1_OCClear);
Nvoid TIM1_ClearOC4Ref(u16 TIM1_OCClear);
Nvoid TIM1_GenerateEvent(u16 TIM1_EventSource);
Nvoid TIM1_OC1PolarityConfig(u16 TIM1_OCPolarity);
Nvoid TIM1_OC1NPolarityConfig(u16 TIM1_OCNPolarity);
Nvoid TIM1_OC2PolarityConfig(u16 TIM1_OCPolarity);
Nvoid TIM1_OC2NPolarityConfig(u16 TIM1_OCNPolarity);
Nvoid TIM1_OC3PolarityConfig(u16 TIM1_OCPolarity);
Nvoid TIM1_OC3NPolarityConfig(u16 TIM1_OCNPolarity);
Nvoid TIM1_OC4PolarityConfig(u16 TIM1_OCPolarity);
Nvoid TIM1_CCxCmd(u16 TIM1_Channel, FunctionalState Newstate);
Nvoid TIM1_CCxNCmd(u16 TIM1_Channel, FunctionalState Newstate);
Nvoid TIM1_SelectOCxM(u16 TIM1_Channel, u16 TIM1_OCMode);
Nvoid TIM1_SetCounter(u16 Counter);
Nvoid TIM1_SetAutoreload(u16 Autoreload);
Nvoid TIM1_SetCompare1(u16 Compare1);
Nvoid TIM1_SetCompare2(u16 Compare2);
Nvoid TIM1_SetCompare3(u16 Compare3);
Nvoid TIM1_SetCompare4(u16 Compare4);
Nvoid TIM1_SetIC1Prescaler(u16 TIM1_IC1Prescaler);
Nvoid TIM1_SetIC2Prescaler(u16 TIM1_IC2Prescaler);
Nvoid TIM1_SetIC3Prescaler(u16 TIM1_IC3Prescaler);
Nvoid TIM1_SetIC4Prescaler(u16 TIM1_IC4Prescaler);
Nvoid TIM1_SetClockDivision(u16 TIM1_CKD);
Nu16 TIM1_GetCapture1(void);
Nu16 TIM1_GetCapture2(void);
Nu16 TIM1_GetCapture3(void);
Nu16 TIM1_GetCapture4(void);
Nu16 TIM1_GetCounter(void);
Nu16 TIM1_GetPrescaler(void);
NFlagStatus TIM1_GetFlagStatus(u16 TIM1_FLAG); 
Nvoid TIM1_ClearFlag(u16 TIM1_Flag);
NITStatus TIM1_GetITStatus(u16 TIM1_IT);
Nvoid TIM1_ClearITPendingBit(u16 TIM1_IT);
N
N#endif /*__STM32F10x_TIM1_H */
N
N/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
L 18 "lib\src\stm32f10x_tim1.c" 2
N#include "stm32f10x_rcc.h"
L 1 ".\lib\inc\stm32f10x_rcc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_rcc.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      RCC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RCC_H
N#define __STM32F10x_RCC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef struct
N{
N  u32 SYSCLK_Frequency;
N  u32 HCLK_Frequency;
N  u32 PCLK1_Frequency;
N  u32 PCLK2_Frequency;
N  u32 ADCCLK_Frequency;
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* HSE configuration */
N#define RCC_HSE_OFF                      ((u32)0x00000000)
N#define RCC_HSE_ON                       ((u32)0x00010000)
N#define RCC_HSE_Bypass                   ((u32)0x00040000)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/* PLL entry clock source */
N#define RCC_PLLSource_HSI_Div2           ((u32)0x00000000)	// PLL的输入时钟 = HSI时钟频率除以2 ；
N#define RCC_PLLSource_HSE_Div1           ((u32)0x00010000)	// PLL的输入时钟 = HSE时钟频率 ；
N#define RCC_PLLSource_HSE_Div2           ((u32)0x00030000)	// PLL的输入时钟 = HSE时钟频率除以2 ；
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div1) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div2))
N
N/* PLL multiplication factor */
N#define RCC_PLLMul_2                     ((u32)0x00000000)	// PLL 输入时钟 * 2
N#define RCC_PLLMul_3                     ((u32)0x00040000)	// PLL 输入时钟 * 3
N#define RCC_PLLMul_4                     ((u32)0x00080000)	// PLL 输入时钟 * 4
N#define RCC_PLLMul_5                     ((u32)0x000C0000)	// PLL 输入时钟 * 5
N#define RCC_PLLMul_6                     ((u32)0x00100000)	// PLL 输入时钟 * 6
N#define RCC_PLLMul_7                     ((u32)0x00140000)	// PLL 输入时钟 * 7
N#define RCC_PLLMul_8                     ((u32)0x00180000)	// PLL 输入时钟 * 8
N#define RCC_PLLMul_9                     ((u32)0x001C0000)	// PLL 输入时钟 * 9
N#define RCC_PLLMul_10                    ((u32)0x00200000)	// PLL 输入时钟 * 10
N#define RCC_PLLMul_11                    ((u32)0x00240000)	// PLL 输入时钟 * 11
N#define RCC_PLLMul_12                    ((u32)0x00280000)	// PLL 输入时钟 * 12
N#define RCC_PLLMul_13                    ((u32)0x002C0000)	// PLL 输入时钟 * 13
N#define RCC_PLLMul_14                    ((u32)0x00300000)	// PLL 输入时钟 * 14
N#define RCC_PLLMul_15                    ((u32)0x00340000)	// PLL 输入时钟 * 15
N#define RCC_PLLMul_16                    ((u32)0x00380000)	// PLL 输入时钟 * 16
N
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N
N/* System clock source */
N#define RCC_SYSCLKSource_HSI             ((u32)0x00000000)
N#define RCC_SYSCLKSource_HSE             ((u32)0x00000001)
N#define RCC_SYSCLKSource_PLLCLK          ((u32)0x00000002)
N
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N
N/* AHB clock source */
N#define RCC_SYSCLK_Div1                  ((u32)0x00000000) // AHB 时钟 = 系统时钟 ；
N#define RCC_SYSCLK_Div2                  ((u32)0x00000080) // AHB 时钟 = 系统时钟/2 ；
N#define RCC_SYSCLK_Div4                  ((u32)0x00000090) // AHB 时钟 = 系统时钟/4 ；
N#define RCC_SYSCLK_Div8                  ((u32)0x000000A0) // AHB 时钟 = 系统时钟/8 ；
N#define RCC_SYSCLK_Div16                 ((u32)0x000000B0) // AHB 时钟 = 系统时钟/16 ；
N#define RCC_SYSCLK_Div64                 ((u32)0x000000C0) // AHB 时钟 = 系统时钟/64 ；
N#define RCC_SYSCLK_Div128                ((u32)0x000000D0) // AHB 时钟 = 系统时钟/128 ；
N#define RCC_SYSCLK_Div256                ((u32)0x000000E0) // AHB 时钟 = 系统时钟/256 ；
N#define RCC_SYSCLK_Div512                ((u32)0x000000F0) // AHB 时钟 = 系统时钟/512 ；
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N
N/* APB1/APB2 clock source */
N#define RCC_HCLK_Div1                    ((u32)0x00000000) // APBx 时钟 = HCLK ；
N#define RCC_HCLK_Div2                    ((u32)0x00000400) // APBx 时钟 = HCLK/2 ；
N#define RCC_HCLK_Div4                    ((u32)0x00000500) // APBx 时钟 = HCLK/4 ；
N#define RCC_HCLK_Div8                    ((u32)0x00000600) // APBx 时钟 = HCLK/8 ；
N#define RCC_HCLK_Div16                   ((u32)0x00000700) // APBx 时钟 = HCLK/16 ；
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N
N/* RCC Interrupt source */
N#define RCC_IT_LSIRDY                    ((u8)0x01)	 // LSI晶振就绪中断 ；
N#define RCC_IT_LSERDY                    ((u8)0x02)	 // LSE晶振就绪中断 ；
N#define RCC_IT_HSIRDY                    ((u8)0x04)	 // HSI晶振就绪中断 ；
N#define RCC_IT_HSERDY                    ((u8)0x08)	 // HSE晶振就绪中断 ；
N#define RCC_IT_PLLRDY                    ((u8)0x10)	 // PLL就绪中断 ；
N#define RCC_IT_CSS                       ((u8)0x80)	 // 时钟安全系统时钟 ；
N
N#define IS_RCC_IT(IT) ((((IT) & (u8)0xE0) == 0x00) && ((IT) != 0x00))
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
N#define IS_RCC_CLEAR_IT(IT) ((((IT) & (u8)0x60) == 0x00) && ((IT) != 0x00))
N
N/* USB clock source */
N#define RCC_USBCLKSource_PLLCLK_1Div5    ((u8)0x00)	 // USB 时钟 = PLL时钟除以1.5 ；
N#define RCC_USBCLKSource_PLLCLK_Div1     ((u8)0x01)	 // USB 时钟 = PLL时钟	；
N
N#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
N                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
N
N/* ADC clock source */
N#define RCC_PCLK2_Div2                   ((u32)0x00000000) // ADC 时钟 = PCLK/2 ；
N#define RCC_PCLK2_Div4                   ((u32)0x00004000) // ADC 时钟 = PCLK/4 ；
N#define RCC_PCLK2_Div6                   ((u32)0x00008000) // ADC 时钟 = PCLK/6 ；
N#define RCC_PCLK2_Div8                   ((u32)0x0000C000) // ADC 时钟 = PCLK/8 ；
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
N                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
N
N/* LSE configuration */
N#define RCC_LSE_OFF                      ((u8)0x00)	  // LSE晶振 OFF ；
N#define RCC_LSE_ON                       ((u8)0x01)	  // LSE晶振 ON  ；
N#define RCC_LSE_Bypass                   ((u8)0x04)	  // LSE晶振被外部时钟旁路 ；
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N
N/* RTC clock source */
N#define RCC_RTCCLKSource_LSE             ((u32)0x00000100) // 选者LSE作为RTC时钟 ；
N#define RCC_RTCCLKSource_LSI             ((u32)0x00000200) // 选者LSI作为RTC时钟 ；
N#define RCC_RTCCLKSource_HSE_Div128      ((u32)0x00000300) // 选择HSE时钟频率除以128作为RTC时钟 ；
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
N
N/* AHB peripheral */
N#define RCC_AHBPeriph_DMA1               ((u32)0x00000001)	// DMA时钟 ；
N#define RCC_AHBPeriph_DMA2               ((u32)0x00000002)
N#define RCC_AHBPeriph_SRAM               ((u32)0x00000004)	// SRAM时钟 ；
N#define RCC_AHBPeriph_FLITF              ((u32)0x00000010)	// FLITF时钟 ；
N#define RCC_AHBPeriph_CRC                ((u32)0x00000040)
N#define RCC_AHBPeriph_FSMC               ((u32)0x00000100)
N#define RCC_AHBPeriph_SDIO               ((u32)0x00000400)
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB2 peripheral */
N#define RCC_APB2Periph_AFIO              ((u32)0x00000001)  // 功能复用IO时钟 ；
N#define RCC_APB2Periph_GPIOA             ((u32)0x00000004)	// GPIOA 时钟 ；
N#define RCC_APB2Periph_GPIOB             ((u32)0x00000008)	// GPIOB 时钟 ；
N#define RCC_APB2Periph_GPIOC             ((u32)0x00000010)	// GPIOC 时钟 ；
N#define RCC_APB2Periph_GPIOD             ((u32)0x00000020)	// GPIOD 时钟 ；
N#define RCC_APB2Periph_GPIOE             ((u32)0x00000040)	// GPIOE 时钟 ；
N#define RCC_APB2Periph_GPIOF             ((u32)0x00000080)	// GPIOF 时钟 ；
N#define RCC_APB2Periph_GPIOG             ((u32)0x00000100)	// GPIOG 时钟 ；
N#define RCC_APB2Periph_ADC1              ((u32)0x00000200)	// ADC1 时钟 ；
N#define RCC_APB2Periph_ADC2              ((u32)0x00000400)	// ADC2 时钟 ；
N#define RCC_APB2Periph_TIM1              ((u32)0x00000800)	// TIM1 时钟 ；
N#define RCC_APB2Periph_SPI1              ((u32)0x00001000)	// SPI1 时钟 ；
N#define RCC_APB2Periph_TIM8              ((u32)0x00002000)	// TIM8 时钟 ；
N#define RCC_APB2Periph_USART1            ((u32)0x00004000)	// USART1 时钟 ；
N#define RCC_APB2Periph_ADC3              ((u32)0x00008000)	// ADC3 时钟 ；
N#define RCC_APB2Periph_ALL               ((u32)0x0000FFFD)	// 全部APB2外设时钟 ；
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFF0002) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB1 peripheral */
N#define RCC_APB1Periph_TIM2              ((u32)0x00000001)  // TIM2 时钟 ；
N#define RCC_APB1Periph_TIM3              ((u32)0x00000002)	// TIM3 时钟 ；
N#define RCC_APB1Periph_TIM4              ((u32)0x00000004)	// TIM4 时钟 ；
N#define RCC_APB1Periph_TIM5              ((u32)0x00000008)  // TIM5 时钟 ；
N#define RCC_APB1Periph_TIM6              ((u32)0x00000010)	// TIM6 时钟 ；
N#define RCC_APB1Periph_TIM7              ((u32)0x00000020)	// TIM7 时钟 ；
N#define RCC_APB1Periph_WWDG              ((u32)0x00000800)	// WWDG 时钟 ；
N#define RCC_APB1Periph_SPI2              ((u32)0x00004000)	// SPI2 时钟 ；
N#define RCC_APB1Periph_SPI3              ((u32)0x00008000)	// SPI3 时钟 ；
N#define RCC_APB1Periph_USART2            ((u32)0x00020000)	// USART2 时钟 ；
N#define RCC_APB1Periph_USART3            ((u32)0x00040000)	// USART3 时钟 ；
N#define RCC_APB1Periph_UART4             ((u32)0x00080000)	// UART4 时钟 ；
N#define RCC_APB1Periph_UART5             ((u32)0x00100000)	// UART5 时钟 ；
N#define RCC_APB1Periph_I2C1              ((u32)0x00200000)  // I2C1 时钟 ；
N#define RCC_APB1Periph_I2C2              ((u32)0x00400000)	// I2C2 时钟 ；
N#define RCC_APB1Periph_USB               ((u32)0x00800000)	// USB 时钟 ；
N#define RCC_APB1Periph_CAN               ((u32)0x02000000)	// CAN 时钟 ；
N#define RCC_APB1Periph_BKP               ((u32)0x08000000)	// BKP 时钟 ；
N#define RCC_APB1Periph_PWR               ((u32)0x10000000)	// PWR 时钟 ；
N#define RCC_APB1Periph_DAC               ((u32)0x20000000)  // DAC 时钟 ；
N#define RCC_APB1Periph_ALL               ((u32)0x3AFEC83F)	// 全部APB1外设时钟 ；
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0xC50137C0) == 0x00) && ((PERIPH) != 0x00))
N
N/* Clock source to output on MCO pin */
N#define RCC_MCO_NoClock                  ((u8)0x00)	 // 无时钟被选中 ；
N#define RCC_MCO_SYSCLK                   ((u8)0x04)	 // 选中系统时钟 ；
N#define RCC_MCO_HSI                      ((u8)0x05)	 // 选中HSI ；
N#define RCC_MCO_HSE                      ((u8)0x06)	 // 选中HSE ；
N#define RCC_MCO_PLLCLK_Div2              ((u8)0x07)	 // 选中PLL时钟除以2 ；
N
N#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
N                         ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
N                         ((MCO) == RCC_MCO_PLLCLK_Div2))
X#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) ||                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) ||                          ((MCO) == RCC_MCO_PLLCLK_Div2))
N
N/* RCC Flag */
N#define RCC_FLAG_HSIRDY                  ((u8)0x20)	 // HSI晶振就绪 ；
N#define RCC_FLAG_HSERDY                  ((u8)0x31)	 // HSE晶振就绪 ；
N#define RCC_FLAG_PLLRDY                  ((u8)0x39)	 // PLL 就绪 ；
N#define RCC_FLAG_LSERDY                  ((u8)0x41)	 // LSI晶振就绪 ；
N#define RCC_FLAG_LSIRDY                  ((u8)0x61)	 // LSE晶振就绪 ；
N#define RCC_FLAG_PINRST                  ((u8)0x7A)	 // 管脚复位 ；
N#define RCC_FLAG_PORRST                  ((u8)0x7B)	 // POR/PDR复位 ；
N#define RCC_FLAG_SFTRST                  ((u8)0x7C)	 // 软件复位 ；
N#define RCC_FLAG_IWDGRST                 ((u8)0x7D)	 // IWDG复位 ；
N#define RCC_FLAG_WWDGRST                 ((u8)0x7E)	 // WWDG复位 ；
N#define RCC_FLAG_LPWRRST                 ((u8)0x7F)	 // 低功耗复位 ；
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
N                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
N                           ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
N                           ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_LPWRRST))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) ||                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) ||                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)||                            ((FLAG) == RCC_FLAG_LPWRRST))
N
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid RCC_DeInit(void);
Nvoid RCC_HSEConfig(u32 RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_SYSCLKConfig(u32 RCC_SYSCLKSource);
Nu8 RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(u32 RCC_SYSCLK);
Nvoid RCC_PCLK1Config(u32 RCC_HCLK);
Nvoid RCC_PCLK2Config(u32 RCC_HCLK);
Nvoid RCC_ITConfig(u8 RCC_IT, FunctionalState NewState);
Nvoid RCC_USBCLKConfig(u32 RCC_USBCLKSource);
Nvoid RCC_ADCCLKConfig(u32 RCC_PCLK2);
Nvoid RCC_LSEConfig(u8 RCC_LSE);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_RTCCLKConfig(u32 RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
Nvoid RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(u8 RCC_MCO);
NFlagStatus RCC_GetFlagStatus(u8 RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(u8 RCC_IT);
Nvoid RCC_ClearITPendingBit(u8 RCC_IT);
N
N#endif /* __STM32F10x_RCC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 19 "lib\src\stm32f10x_tim1.c" 2
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N
N/* ------------ TIM1 registers bit address in the alias region ----------- */
N#define TIM1_OFFSET    (TIM1_BASE - PERIPH_BASE)
N
N/* --- TIM1 CR1 Register ---*/
N/* Alias word address of CEN bit */
N#define CR1_OFFSET        (TIM1_OFFSET + 0x00)
N#define CEN_BitNumber     0x00
N#define CR1_CEN_BB        (PERIPH_BB_BASE + (CR1_OFFSET * 32) + (CEN_BitNumber * 4))
N
N/* Alias word address of UDIS bit */
N#define UDIS_BitNumber    0x01
N#define CR1_UDIS_BB       (PERIPH_BB_BASE + (CR1_OFFSET * 32) + (UDIS_BitNumber * 4))
N
N/* Alias word address of URS bit */
N#define URS_BitNumber     0x02
N#define CR1_URS_BB        (PERIPH_BB_BASE + (CR1_OFFSET * 32) + (URS_BitNumber * 4))
N
N/* Alias word address of OPM bit */
N#define OPM_BitNumber     0x03
N#define CR1_OPM_BB        (PERIPH_BB_BASE + (CR1_OFFSET * 32) + (OPM_BitNumber * 4))
N
N/* Alias word address of ARPE bit */
N#define ARPE_BitNumber    0x07
N#define CR1_ARPE_BB       (PERIPH_BB_BASE + (CR1_OFFSET * 32) + (ARPE_BitNumber * 4))
N
N/* --- TIM1 CR2 Register --- */
N/* Alias word address of CCPC bit */
N#define CR2_OFFSET        (TIM1_OFFSET + 0x04)
N#define CCPC_BitNumber    0x00
N#define CR2_CCPC_BB       (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (CCPC_BitNumber * 4))
N
N/* Alias word address of CCUS bit */
N#define CCUS_BitNumber    0x02
N#define CR2_CCUS_BB       (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (CCUS_BitNumber * 4))
N
N/* Alias word address of CCDS bit */
N#define CCDS_BitNumber    0x03
N#define CR2_CCDS_BB       (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (CCDS_BitNumber * 4))
N
N/* Alias word address of TI1S bit */
N#define TI1S_BitNumber    0x07
N#define CR2_TI1S_BB       (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (TI1S_BitNumber * 4))
N
N/* Alias word address of OIS1 bit */
N#define OIS1_BitNumber    0x08
N#define CR2_OIS1_BB       (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (OIS1_BitNumber * 4))
N
N/* Alias word address of OIS1N bit */
N#define OIS1N_BitNumber   0x09
N#define CR2_OIS1N_BB      (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (OIS1N_BitNumber * 4))
N
N/* Alias word address of OIS2 bit */
N#define OIS2_BitNumber    0x0A
N#define CR2_OIS2_BB      (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (OIS2_BitNumber * 4))
N
N/* Alias word address of OIS2N bit */
N#define OIS2N_BitNumber   0x0B
N#define CR2_OIS2N_BB      (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (OIS2N_BitNumber * 4))
N
N/* Alias word address of OIS3 bit */
N#define OIS3_BitNumber    0x0C
N#define CR2_OIS3_BB       (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (OIS3_BitNumber * 4))
N
N/* Alias word address of OIS3N bit */
N#define OIS3N_BitNumber   0x0D
N#define CR2_OIS3N_BB      (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (OIS3N_BitNumber * 4))
N
N/* Alias word address of OIS4 bit */
N#define OIS4_BitNumber    0x0E
N#define CR2_OIS4_BB       (PERIPH_BB_BASE + (CR2_OFFSET * 32) + (OIS4_BitNumber * 4))
N
N/* --- TIM1 SMCR Register --- */
N/* Alias word address of MSM bit */
N#define SMCR_OFFSET       (TIM1_OFFSET + 0x08)
N#define MSM_BitNumber     0x07
N#define SMCR_MSM_BB       (PERIPH_BB_BASE + (SMCR_OFFSET * 32) + (MSM_BitNumber * 4))
N
N/* Alias word address of ECE bit */
N#define ECE_BitNumber     0x0E
N#define SMCR_ECE_BB       (PERIPH_BB_BASE + (SMCR_OFFSET * 32) + (ECE_BitNumber * 4))
N
N/* --- TIM1 EGR Register --- */
N/* Alias word address of UG bit */
N#define EGR_OFFSET        (TIM1_OFFSET + 0x14)
N#define UG_BitNumber      0x00
N#define EGR_UG_BB         (PERIPH_BB_BASE + (EGR_OFFSET * 32) + (UG_BitNumber * 4))
N
N/* --- TIM1 CCER Register --- */
N/* Alias word address of CC1E bit */
N#define CCER_OFFSET       (TIM1_OFFSET + 0x20)
N#define CC1E_BitNumber    0x00
N#define CCER_CC1E_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC1E_BitNumber * 4))
N
N/* Alias word address of CC1P bit */
N#define CC1P_BitNumber    0x01
N#define CCER_CC1P_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC1P_BitNumber * 4))
N
N/* Alias word address of CC1NE bit */
N#define CC1NE_BitNumber   0x02
N#define CCER_CC1NE_BB     (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC1NE_BitNumber * 4))
N
N/* Alias word address of CC1NP bit */
N#define CC1NP_BitNumber   0x03
N#define CCER_CC1NP_BB     (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC1NP_BitNumber * 4))
N
N/* Alias word address of CC2E bit */
N#define CC2E_BitNumber    0x04
N#define CCER_CC2E_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC2E_BitNumber * 4))
N
N/* Alias word address of CC2P bit */
N#define CC2P_BitNumber    0x05
N#define CCER_CC2P_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC2P_BitNumber * 4))
N
N/* Alias word address of CC2NE bit */
N#define CC2NE_BitNumber   0x06
N#define CCER_CC2NE_BB     (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC2NE_BitNumber * 4))
N
N/* Alias word address of CC2NP bit */
N#define CC2NP_BitNumber   0x07
N#define CCER_CC2NP_BB     (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC2NP_BitNumber * 4))
N
N/* Alias word address of CC3E bit */
N#define CC3E_BitNumber    0x08
N#define CCER_CC3E_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC3E_BitNumber * 4))
N
N/* Alias word address of CC3P bit */
N#define CC3P_BitNumber    0x09
N#define CCER_CC3P_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC3P_BitNumber * 4))
N
N/* Alias word address of CC3NE bit */
N#define CC3NE_BitNumber   0x0A
N#define CCER_CC3NE_BB     (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC3NE_BitNumber * 4))
N
N/* Alias word address of CC3NP bit */
N#define CC3NP_BitNumber   0x0B
N#define CCER_CC3NP_BB     (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC3NP_BitNumber * 4))
N
N/* Alias word address of CC4E bit */
N#define CC4E_BitNumber    0x0C
N#define CCER_CC4E_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC4E_BitNumber * 4))
N
N/* Alias word address of CC4P bit */
N#define CC4P_BitNumber    0x0D
N#define CCER_CC4P_BB      (PERIPH_BB_BASE + (CCER_OFFSET * 32) + (CC4P_BitNumber * 4))
N
N/* --- TIM1 BDTR Register --- */
N/* Alias word address of MOE bit */
N#define BDTR_OFFSET       (TIM1_OFFSET + 0x44)
N#define MOE_BitNumber     0x0F
N#define BDTR_MOE_BB       (PERIPH_BB_BASE + (BDTR_OFFSET * 32) + (MOE_BitNumber * 4))
N
N/* --- TIM1 CCMR1 Register --- */
N/* Alias word address of OC1FE bit */
N#define CCMR1_OFFSET      (TIM1_OFFSET + 0x18)
N#define OC1FE_BitNumber   0x02
N#define CCMR1_OC1FE_BB    (PERIPH_BB_BASE + (CCMR1_OFFSET * 32) + (OC1FE_BitNumber * 4))
N
N/* Alias word address of OC1PE bit */
N#define OC1PE_BitNumber   0x03
N#define CCMR1_OC1PE_BB    (PERIPH_BB_BASE + (CCMR1_OFFSET * 32) + (OC1PE_BitNumber * 4))
N
N/* Alias word address of OC1CE bit */
N#define OC1CE_BitNumber   0x07
N#define CCMR1_OC1CE_BB    (PERIPH_BB_BASE + (CCMR1_OFFSET * 32) + (OC1CE_BitNumber * 4))
N
N/* Alias word address of OC2FE bit */
N#define OC2FE_BitNumber   0x0A
N#define CCMR1_OC2FE_BB    (PERIPH_BB_BASE + (CCMR1_OFFSET * 32) + (OC2FE_BitNumber * 4))
N
N/* Alias word address of OC2PE bit */
N#define OC2PE_BitNumber   0x0B
N#define CCMR1_OC2PE_BB    (PERIPH_BB_BASE + (CCMR1_OFFSET * 32) + (OC2PE_BitNumber * 4))
N
N/* Alias word address of OC2CE bit */
N#define OC2CE_BitNumber   0x0F
N#define CCMR1_OC2CE_BB    (PERIPH_BB_BASE + (CCMR1_OFFSET * 32) + (OC2CE_BitNumber * 4))
N
N/* --- TIM1 CCMR2 Register ---- */
N/* Alias word address of OC3FE bit */
N#define CCMR2_OFFSET      (TIM1_OFFSET + 0x1C)
N#define OC3FE_BitNumber   0x02
N#define CCMR2_OC3FE_BB    (PERIPH_BB_BASE + (CCMR2_OFFSET * 32) + (OC3FE_BitNumber * 4))
N
N/* Alias word address of OC3PE bit */
N#define OC3PE_BitNumber   0x03
N#define CCMR2_OC3PE_BB    (PERIPH_BB_BASE + (CCMR2_OFFSET * 32) + (OC3PE_BitNumber * 4))
N
N/* Alias word address of OC3CE bit */
N#define OC3CE_BitNumber   0x07
N#define CCMR2_OC3CE_BB    (PERIPH_BB_BASE + (CCMR2_OFFSET * 32) + (OC3CE_BitNumber * 4))
N
N/* Alias word address of OC4FE bit */
N#define OC4FE_BitNumber   0x0A
N#define CCMR2_OC4FE_BB    (PERIPH_BB_BASE + (CCMR2_OFFSET * 32) + (OC4FE_BitNumber * 4))
N
N/* Alias word address of OC4PE bit */
N#define OC4PE_BitNumber   0x0B
N#define CCMR2_OC4PE_BB    (PERIPH_BB_BASE + (CCMR2_OFFSET * 32) + (OC4PE_BitNumber * 4))
N
N/* Alias word address of OC4CE bit */
N#define OC4CE_BitNumber   0x0F
N#define CCMR2_OC4CE_BB    (PERIPH_BB_BASE + (CCMR2_OFFSET * 32) + (OC4CE_BitNumber * 4))
N
N/* --------------------- TIM1 registers bit mask ------------------------- */
N/* TIM1 CR1 Mask */
N#define CR1_CounterMode_Mask                ((u16)0x039F)
N#define CR1_CKD_Mask                        ((u16)0x00FF)
N
N/* TIM1 CR2 Mask */
N#define CR2_MMS_Mask                        ((u16)0x0080)
N
N/* TIM1 SMCR Mask */
N#define SMCR_SMS_Mask                       ((u16)0xFFF0)
N#define SMCR_ETR_Mask                       ((u16)0x40F7)
N#define SMCR_TS_Mask                        ((u16)0xFF87)
N#define SMCR_ECE_Set                        ((u16)0x0001)
N
N/* TIM1 CCMRx Mask */
N#define CCMR_CC13S_Mask                     ((u16)0xFFFC)
N#define CCMR_CC24S_Mask                     ((u16)0xFCFF)
N#define CCMR_TI13Direct_Set                 ((u16)0x0001)
N#define CCMR_TI24Direct_Set                 ((u16)0x0100)
N#define CCMR_OCM13_Mask                     ((u16)0x7F0F)
N#define CCMR_OCM24_Mask                     ((u16)0x0F7F)
N#define CCMR_IC13PSC_Mask                   ((u16)0xFFF3)
N#define CCMR_IC24PSC_Mask                   ((u16)0xF3FF)
N#define CCMR_IC13F_Mask                     ((u16)0xFF0F)
N#define CCMR_IC24F_Mask                     ((u16)0x0FFF)
N#define OC13Mode_Mask		                ((u16)0xFF00)
N#define OC24Mode_Mask		                ((u16)0x00FF)
N
N/* TIM1 CCER Set/Reset Bit */
N#define CCER_CCE_Set                        ((u16)0x0001)
N#define CCER_CCE_Reset                      ((u16)0x0000)
N
N/* TIM1 DMA Mask */
N#define DCR_DMA_Mask                        ((u16)0x0000)
N
N/* TIM1 private Masks */
N#define TIM1_Period_Reset_Mask               ((u16)0xFFFF)
N#define TIM1_Prescaler_Reset_Mask            ((u16)0x0000)
N#define TIM1_RepetitionCounter_Reset_Mask    ((u16)0x0000)
N#define TIM1_Pulse_Reset_Mask                ((u16)0x0000)
N#define TIM1_ICFilter_Mask                   ((u8)0x00)
N#define TIM1_DeadTime_Reset_Mask             ((u16)0x0000)
N
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
Nstatic void TI1_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter);
Nstatic void TI2_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter);
Nstatic void TI3_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter);
Nstatic void TI4_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter);
N
N/*******************************************************************************
N* Function Name  : TIM1_DeInit
N* Description    : Deinitializes the TIM1 peripheral registers to their default
N*                  reset values.
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 将外设TIM1寄存器重设为缺省值 ；
N*******************************************************************************/
Nvoid TIM1_DeInit(void)
N{
N  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
X  RCC_APB2PeriphResetCmd(((u32)0x00000800), ENABLE);
N  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);
X  RCC_APB2PeriphResetCmd(((u32)0x00000800), DISABLE);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_TimeBaseInit
N* Description    : Initializes the TIM1 Time Base Unit according to the specified
N*                  parameters in the TIM1_TimeBaseInitStruct.
N* Input          : - TIM1_TimeBaseInitStruct: pointer to a TIM1_TimeBaseInitTypeDef
N*                    structure that contains the configuration information for
N*                    the specified TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据TIM1_TIM1BaseInitStruct中指定的参数初始化TIM1的时间基数单位 ；
N*******************************************************************************/
Nvoid TIM1_TimeBaseInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct)
N{
N /* Check the parameters */
N  assert_param(IS_TIM1_COUNTER_MODE(TIM1_TimeBaseInitStruct->TIM1_CounterMode));
X  ((void)0);
N  assert_param(IS_TIM1_CKD_DIV(TIM1_TimeBaseInitStruct->TIM1_ClockDivision));
X  ((void)0);
N
N  /* Set the Autoreload value */
N  TIM1->ARR = TIM1_TimeBaseInitStruct->TIM1_Period ;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->ARR = TIM1_TimeBaseInitStruct->TIM1_Period ;
N
N  /* Set the Prescaler value */
N  TIM1->PSC = TIM1_TimeBaseInitStruct->TIM1_Prescaler;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->PSC = TIM1_TimeBaseInitStruct->TIM1_Prescaler;
N
N  /* Select the Counter Mode and set the clock division */
N  TIM1->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR1 &= ((u16)0x00FF) & ((u16)0x039F);
N  TIM1->CR1 |= (u32)TIM1_TimeBaseInitStruct->TIM1_ClockDivision |
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR1 |= (u32)TIM1_TimeBaseInitStruct->TIM1_ClockDivision |
N               TIM1_TimeBaseInitStruct->TIM1_CounterMode;
N
N  /* Set the Repetition Counter value */
N  TIM1->RCR = TIM1_TimeBaseInitStruct->TIM1_RepetitionCounter;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->RCR = TIM1_TimeBaseInitStruct->TIM1_RepetitionCounter;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC1Init
N* Description    : Initializes the TIM1 Channel1 according to the specified
N*                  parameters in the TIM1_OCInitStruct.
N* Input          : - TIM1_OCInitStruct: pointer to a TIM1_OCInitTypeDef structure that
N*                    contains the configuration information for the TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据TIM1_OCInitStruct中指定的参数初始化TIM1通道1 ；
N*******************************************************************************/
Nvoid TIM1_OC1Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
N{
N  u16 tmpccmr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
X  ((void)0);
N  assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
X  ((void)0);
N  assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OCInitStruct->TIM1_OutputNState));
X  ((void)0);
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCInitStruct->TIM1_OCNPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
X  ((void)0);
N  assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCInitStruct->TIM1_OCNIdleState)); 
X  ((void)0); 
N
N  tmpccmr = TIM1->CCMR1;
X  tmpccmr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Disable the Channel 1: Reset the CCE Bit */
N  *(vu32 *) CCER_CC1E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x00 * 4)) = ((u16)0x0000);
N
N  /* Reset the Output Compare Bits */
N   tmpccmr &= OC13Mode_Mask;
X   tmpccmr &= ((u16)0xFF00);
N
N  /* Set the Ouput Compare Mode */
N  tmpccmr |= TIM1_OCInitStruct->TIM1_OCMode;
N
N  TIM1->CCMR1 = tmpccmr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = tmpccmr;
N
N  /* Set the Output State */
N  *(vu32 *) CCER_CC1E_BB = TIM1_OCInitStruct->TIM1_OutputState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x00 * 4)) = TIM1_OCInitStruct->TIM1_OutputState;
N
N  /* Set the Output N State */
N  *(vu32 *) CCER_CC1NE_BB = TIM1_OCInitStruct->TIM1_OutputNState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x02 * 4)) = TIM1_OCInitStruct->TIM1_OutputNState;
N
N  /* Set the Output Polarity */
N  *(vu32 *) CCER_CC1P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x01 * 4)) = TIM1_OCInitStruct->TIM1_OCPolarity;
N
N  /* Set the Output N Polarity */
N  *(vu32 *) CCER_CC1NP_BB = TIM1_OCInitStruct->TIM1_OCNPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x03 * 4)) = TIM1_OCInitStruct->TIM1_OCNPolarity;
N
N  /* Set the Output Idle state */
N  *(vu32 *) CR2_OIS1_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x08 * 4)) = TIM1_OCInitStruct->TIM1_OCIdleState;
N
N  /* Set the Output N Idle state */
N  *(vu32 *) CR2_OIS1N_BB = TIM1_OCInitStruct->TIM1_OCNIdleState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x09 * 4)) = TIM1_OCInitStruct->TIM1_OCNIdleState;
N
N  /* Set the Pulse value */
N  TIM1->CCR1 = TIM1_OCInitStruct->TIM1_Pulse;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR1 = TIM1_OCInitStruct->TIM1_Pulse;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC2Init
N* Description    : Initializes the TIM1 Channel2 according to the specified
N*                  parameters in the TIM1_OCInitStruct.
N* Input          : - TIM1_OCInitStruct: pointer to a TIM1_OCInitTypeDef structure that
N*                    contains the configuration information for the TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据TIM1_OCInitStruct中指定的参数初始化TIM1通道2 ；
N*******************************************************************************/
Nvoid TIM1_OC2Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
N{
N  u32 tmpccmr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
X  ((void)0);
N  assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
X  ((void)0);
N  assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OCInitStruct->TIM1_OutputNState));
X  ((void)0);
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCInitStruct->TIM1_OCNPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
X  ((void)0);
N  assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCInitStruct->TIM1_OCNIdleState));
X  ((void)0);
N
N  tmpccmr = TIM1->CCMR1;
X  tmpccmr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Disable the Channel 2: Reset the CCE Bit */
N  *(vu32 *) CCER_CC2E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x04 * 4)) = ((u16)0x0000);
N
N  /* Reset the Output Compare Bits */
N   tmpccmr &= OC24Mode_Mask;
X   tmpccmr &= ((u16)0x00FF);
N
N  /* Set the Ouput Compare Mode */
N  tmpccmr |= (u32)TIM1_OCInitStruct->TIM1_OCMode << 8;
N
N  TIM1->CCMR1 = (u16)tmpccmr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr;
N
N  /* Set the Output State */
N  *(vu32 *) CCER_CC2E_BB = TIM1_OCInitStruct->TIM1_OutputState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x04 * 4)) = TIM1_OCInitStruct->TIM1_OutputState;
N
N  /* Set the Output N State */
N  *(vu32 *) CCER_CC2NE_BB = TIM1_OCInitStruct->TIM1_OutputNState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x06 * 4)) = TIM1_OCInitStruct->TIM1_OutputNState;
N
N  /* Set the Output Polarity */
N  *(vu32 *) CCER_CC2P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x05 * 4)) = TIM1_OCInitStruct->TIM1_OCPolarity;
N
N  /* Set the Output N Polarity */
N  *(vu32 *) CCER_CC2NP_BB = TIM1_OCInitStruct->TIM1_OCNPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x07 * 4)) = TIM1_OCInitStruct->TIM1_OCNPolarity;
N
N  /* Set the Output Idle state */
N  *(vu32 *) CR2_OIS2_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x0A * 4)) = TIM1_OCInitStruct->TIM1_OCIdleState;
N
N  /* Set the Output N Idle state */
N  *(vu32 *) CR2_OIS2N_BB = TIM1_OCInitStruct->TIM1_OCNIdleState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x0B * 4)) = TIM1_OCInitStruct->TIM1_OCNIdleState;
N
N  /* Set the Pulse value */
N  TIM1->CCR2 = TIM1_OCInitStruct->TIM1_Pulse;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR2 = TIM1_OCInitStruct->TIM1_Pulse;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC3Init
N* Description    : Initializes the TIM1 Channel3 according to the specified
N*                  parameters in the TIM1_OCInitStruct.
N* Input          : - TIM1_OCInitStruct: pointer to a TIM1_OCInitTypeDef structure that
N*                    contains the configuration information for the TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据TIM1_OCInitStruct中指定的参数初始化TIM1通道3 ；
N*******************************************************************************/
Nvoid TIM1_OC3Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
N{
N  u16 tmpccmr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
X  ((void)0);
N  assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
X  ((void)0);
N  assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OCInitStruct->TIM1_OutputNState));
X  ((void)0);
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCInitStruct->TIM1_OCNPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
X  ((void)0);
N  assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCInitStruct->TIM1_OCNIdleState));
X  ((void)0);
N
N  tmpccmr = TIM1->CCMR2;
X  tmpccmr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2;
N
N  /* Disable the Channel 3: Reset the CCE Bit */
N  *(vu32 *) CCER_CC3E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x08 * 4)) = ((u16)0x0000);
N
N  /* Reset the Output Compare Bits */
N   tmpccmr &= OC13Mode_Mask;
X   tmpccmr &= ((u16)0xFF00);
N
N  /* Set the Ouput Compare Mode */
N  tmpccmr |= TIM1_OCInitStruct->TIM1_OCMode;
N
N  TIM1->CCMR2 = tmpccmr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = tmpccmr;
N
N  /* Set the Output State */
N  *(vu32 *) CCER_CC3E_BB = TIM1_OCInitStruct->TIM1_OutputState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x08 * 4)) = TIM1_OCInitStruct->TIM1_OutputState;
N
N  /* Set the Output N State */
N  *(vu32 *) CCER_CC3NE_BB = TIM1_OCInitStruct->TIM1_OutputNState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0A * 4)) = TIM1_OCInitStruct->TIM1_OutputNState;
N
N  /* Set the Output Polarity */
N  *(vu32 *) CCER_CC3P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x09 * 4)) = TIM1_OCInitStruct->TIM1_OCPolarity;
N
N  /* Set the Output N Polarity */
N  *(vu32 *) CCER_CC3NP_BB = TIM1_OCInitStruct->TIM1_OCNPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0B * 4)) = TIM1_OCInitStruct->TIM1_OCNPolarity;
N
N  /* Set the Output Idle state */
N  *(vu32 *) CR2_OIS3_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x0C * 4)) = TIM1_OCInitStruct->TIM1_OCIdleState;
N
N  /* Set the Output N Idle state */
N  *(vu32 *) CR2_OIS3N_BB = TIM1_OCInitStruct->TIM1_OCNIdleState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x0D * 4)) = TIM1_OCInitStruct->TIM1_OCNIdleState;
N
N  /* Set the Pulse value */
N  TIM1->CCR3 = TIM1_OCInitStruct->TIM1_Pulse;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR3 = TIM1_OCInitStruct->TIM1_Pulse;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC4Init
N* Description    : Initializes the TIM1 Channel4 according to the specified
N*                  parameters in the TIM1_OCInitStruct.
N* Input          : - TIM1_OCInitStruct: pointer to a TIM1_OCInitTypeDef structure that
N*                    contains the configuration information for the TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据TIM1_OCInitStruct中指定的参数初始化TIM1通道4 ；
N*******************************************************************************/
Nvoid TIM1_OC4Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
N{
N  u32 tmpccmr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
X  ((void)0);
N  assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
X  ((void)0);
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
X  ((void)0);
N
N  tmpccmr = TIM1->CCMR2;
X  tmpccmr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2;
N
N  /* Disable the Channel 4: Reset the CCE Bit */
N  *(vu32 *) CCER_CC4E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0C * 4)) = ((u16)0x0000);
N
N  /* Reset the Output Compare Bits */
N   tmpccmr &= OC24Mode_Mask;
X   tmpccmr &= ((u16)0x00FF);
N
N  /* Set the Ouput Compare Mode */
N  tmpccmr |= (u32)TIM1_OCInitStruct->TIM1_OCMode << 8;
N
N  TIM1->CCMR2 = (u16)tmpccmr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = (u16)tmpccmr;
N
N  /* Set the Output State */
N  *(vu32 *) CCER_CC4E_BB = TIM1_OCInitStruct->TIM1_OutputState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0C * 4)) = TIM1_OCInitStruct->TIM1_OutputState;
N
N  /* Set the Output Polarity */
N  *(vu32 *) CCER_CC4P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0D * 4)) = TIM1_OCInitStruct->TIM1_OCPolarity;
N
N  /* Set the Output Idle state */
N  *(vu32 *) CR2_OIS4_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x0E * 4)) = TIM1_OCInitStruct->TIM1_OCIdleState;
N
N  /* Set the Pulse value */
N  TIM1->CCR4 = TIM1_OCInitStruct->TIM1_Pulse;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR4 = TIM1_OCInitStruct->TIM1_Pulse;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_BDTRConfig
N* Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
N*                  the OSSR State and the AOE(automatic output enable).
N* Input          : - TIM1_BDTRInitStruct: pointer to a TIM1_BDTRInitTypeDef
N*                    structure that contains the BDTR Register configuration
N*                    information for the TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 设置刹车特性，死区时间，锁电平，OSSI，OSSR状态和AOE（自动输出使能） ；
N*******************************************************************************/
Nvoid TIM1_BDTRConfig(TIM1_BDTRInitTypeDef *TIM1_BDTRInitStruct)
N{
N  u16 tmpbdtr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_OSSR_STATE(TIM1_BDTRInitStruct->TIM1_OSSRState));
X  ((void)0);
N  assert_param(IS_TIM1_OSSI_STATE(TIM1_BDTRInitStruct->TIM1_OSSIState));
X  ((void)0);
N  assert_param(IS_TIM1_LOCK_LEVEL(TIM1_BDTRInitStruct->TIM1_LOCKLevel));
X  ((void)0);
N  assert_param(IS_TIM1_BREAK_STATE(TIM1_BDTRInitStruct->TIM1_Break));
X  ((void)0);
N  assert_param(IS_TIM1_BREAK_POLARITY(TIM1_BDTRInitStruct->TIM1_BreakPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_AUTOMATIC_OUTPUT_STATE(TIM1_BDTRInitStruct->TIM1_AutomaticOutput));
X  ((void)0);
N
N  tmpbdtr = TIM1->BDTR;
X  tmpbdtr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->BDTR;
N
N  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
N     the OSSI State, the dead time value and the Automatic Output Enable Bit */
N
N  tmpbdtr = (u32)TIM1_BDTRInitStruct->TIM1_OSSRState | TIM1_BDTRInitStruct->TIM1_OSSIState |
N             TIM1_BDTRInitStruct->TIM1_LOCKLevel | TIM1_BDTRInitStruct->TIM1_DeadTime |
N			 TIM1_BDTRInitStruct->TIM1_Break | TIM1_BDTRInitStruct->TIM1_BreakPolarity |
N             TIM1_BDTRInitStruct->TIM1_AutomaticOutput;
N
N  TIM1->BDTR = tmpbdtr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->BDTR = tmpbdtr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ICInit
N* Description    : Initializes the TIM1 peripheral according to the specified
N*                  parameters in the TIM1_ICInitStruct.
N* Input          : - TIM1_ICInitStruct: pointer to a TIM1_ICInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据TIM1_ICInitStruct中指定的参数初始化外设TIM1 ；
N*******************************************************************************/
Nvoid TIM1_ICInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_CHANNEL(TIM1_ICInitStruct->TIM1_Channel));
X  ((void)0);
N  assert_param(IS_TIM1_IC_POLARITY(TIM1_ICInitStruct->TIM1_ICPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_IC_SELECTION(TIM1_ICInitStruct->TIM1_ICSelection));
X  ((void)0);
N  assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICInitStruct->TIM1_ICPrescaler));
X  ((void)0);
N  assert_param(IS_TIM1_IC_FILTER(TIM1_ICInitStruct->TIM1_ICFilter));
X  ((void)0);
N
N  if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_1)
X  if (TIM1_ICInitStruct->TIM1_Channel == ((u16)0x0000))
N  {
N    /* TI1 Configuration */
N    TI1_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
N               TIM1_ICInitStruct->TIM1_ICSelection,
N               TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC1Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N  }
N  else if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_2)
X  else if (TIM1_ICInitStruct->TIM1_Channel == ((u16)0x0001))
N  {
N    /* TI2 Configuration */
N    TI2_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
N               TIM1_ICInitStruct->TIM1_ICSelection,
N               TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC2Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N  }
N  else if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_3)
X  else if (TIM1_ICInitStruct->TIM1_Channel == ((u16)0x0002))
N  {
N    /* TI3 Configuration */
N    TI3_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
N               TIM1_ICInitStruct->TIM1_ICSelection,
N               TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC3Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N  }
N  else
N  {
N    /* TI4 Configuration */
N    TI4_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
N               TIM1_ICInitStruct->TIM1_ICSelection,
N               TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC4Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_PWMIConfig
N* Description    : Configures the TIM1 peripheral in PWM Input Mode according 
N*                  to the specified parameters in the TIM1_ICInitStruct.
N* Input          : - TIM1_ICInitStruct: pointer to a TIM1_ICInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM1 peripheral.
N* Output         : None
N* Return         : None
N* 功能           : 根据TIM1_ICInitStruct中指定的参数设置外设TIM1工作在PWM输入模式 ；
N*******************************************************************************/
Nvoid TIM1_PWMIConfig(TIM1_ICInitTypeDef* TIM1_ICInitStruct)
N{
N  u8 ICPolarity = TIM1_ICPolarity_Rising;
X  u8 ICPolarity = ((u16)0x0000);
N  u8 ICSelection = TIM1_ICSelection_DirectTI;
X  u8 ICSelection = ((u16)0x0001);
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_PWMI_CHANNEL(TIM1_ICInitStruct->TIM1_Channel));
X  ((void)0);
N  assert_param(IS_TIM1_IC_POLARITY(TIM1_ICInitStruct->TIM1_ICPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_IC_SELECTION(TIM1_ICInitStruct->TIM1_ICSelection));
X  ((void)0);
N  assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICInitStruct->TIM1_ICPrescaler));
X  ((void)0);
N
N  /* Select the Opposite Input Polarity */
N  if (TIM1_ICInitStruct->TIM1_ICPolarity == TIM1_ICPolarity_Rising)
X  if (TIM1_ICInitStruct->TIM1_ICPolarity == ((u16)0x0000))
N  {
N    ICPolarity = TIM1_ICPolarity_Falling;
X    ICPolarity = ((u16)0x0001);
N  }
N  else
N  {
N    ICPolarity = TIM1_ICPolarity_Rising;
X    ICPolarity = ((u16)0x0000);
N  }
N
N  /* Select the Opposite Input */
N  if (TIM1_ICInitStruct->TIM1_ICSelection == TIM1_ICSelection_DirectTI)
X  if (TIM1_ICInitStruct->TIM1_ICSelection == ((u16)0x0001))
N  {
N    ICSelection = TIM1_ICSelection_IndirectTI;
X    ICSelection = ((u16)0x0002);
N  }
N  else
N  {
N    ICSelection = TIM1_ICSelection_DirectTI;
X    ICSelection = ((u16)0x0001);
N  }
N
N  if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_1)
X  if (TIM1_ICInitStruct->TIM1_Channel == ((u16)0x0000))
N  {
N    /* TI1 Configuration */
N    TI1_Config(TIM1_ICInitStruct->TIM1_ICPolarity, TIM1_ICInitStruct->TIM1_ICSelection,
N               TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC1Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N
N    /* TI2 Configuration */
N    TI2_Config(ICPolarity, ICSelection, TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC2Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N  }
N  else
N  {	 
N    /* TI2 Configuration */
N    TI2_Config(TIM1_ICInitStruct->TIM1_ICPolarity, TIM1_ICInitStruct->TIM1_ICSelection,
N               TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC2Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N
N    /* TI1 Configuration */
N    TI1_Config(ICPolarity, ICSelection, TIM1_ICInitStruct->TIM1_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM1_SetIC1Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
N  }
N}
N/*******************************************************************************
N* Function Name  : TIM1_OCStructInit
N* Description    : Fills each TIM1_OCInitStruct member with its default value.
N* Input          : - TIM1_OCInitStruct : pointer to a TIM1_OCInitTypeDef structure
N*                    which will be initialized.
N* Output         : None
N* Return         : None
N* 功能           : 把TIM1_OCInitStruct中的每一个参数按缺省值填入 ；
N*******************************************************************************/
Nvoid TIM1_OCStructInit(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
N{
N  /* Set the default configuration */
N  TIM1_OCInitStruct->TIM1_OCMode = TIM1_OCMode_Timing;
X  TIM1_OCInitStruct->TIM1_OCMode = ((u16)0x0000);
N  TIM1_OCInitStruct->TIM1_OutputState = TIM1_OutputState_Disable;
X  TIM1_OCInitStruct->TIM1_OutputState = ((u16)0x0000);
N  TIM1_OCInitStruct->TIM1_OutputNState = TIM1_OutputNState_Disable;
X  TIM1_OCInitStruct->TIM1_OutputNState = ((u16)0x0000);
N  TIM1_OCInitStruct->TIM1_Pulse = TIM1_Pulse_Reset_Mask;
X  TIM1_OCInitStruct->TIM1_Pulse = ((u16)0x0000);
N  TIM1_OCInitStruct->TIM1_OCPolarity = TIM1_OCPolarity_High;
X  TIM1_OCInitStruct->TIM1_OCPolarity = ((u16)0x0000);
N  TIM1_OCInitStruct->TIM1_OCNPolarity = TIM1_OCPolarity_High;
X  TIM1_OCInitStruct->TIM1_OCNPolarity = ((u16)0x0000);
N  TIM1_OCInitStruct->TIM1_OCIdleState = TIM1_OCIdleState_Reset;
X  TIM1_OCInitStruct->TIM1_OCIdleState = ((u16)0x0000);
N  TIM1_OCInitStruct->TIM1_OCNIdleState = TIM1_OCNIdleState_Reset;
X  TIM1_OCInitStruct->TIM1_OCNIdleState = ((u16)0x0000);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ICStructInit
N* Description    : Fills each TIM1_ICInitStruct member with its default value.
N* Input          : - TIM1_ICInitStruct : pointer to a TIM1_ICInitTypeDef structure
N*                    which will be initialized.
N* Output         : None
N* Return         : None
N* 功能           : 把TIM1_ICInitStruct中的每一个参数按缺省值填入 ；
N*******************************************************************************/
Nvoid TIM1_ICStructInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct)
N{
N  /* Set the default configuration */
N  TIM1_ICInitStruct->TIM1_Channel = TIM1_Channel_1;
X  TIM1_ICInitStruct->TIM1_Channel = ((u16)0x0000);
N  TIM1_ICInitStruct->TIM1_ICSelection = TIM1_ICSelection_DirectTI;
X  TIM1_ICInitStruct->TIM1_ICSelection = ((u16)0x0001);
N  TIM1_ICInitStruct->TIM1_ICPolarity = TIM1_ICPolarity_Rising;
X  TIM1_ICInitStruct->TIM1_ICPolarity = ((u16)0x0000);
N  TIM1_ICInitStruct->TIM1_ICPrescaler = TIM1_ICPSC_DIV1;
X  TIM1_ICInitStruct->TIM1_ICPrescaler = ((u16)0x0000);
N  TIM1_ICInitStruct->TIM1_ICFilter = TIM1_ICFilter_Mask;
X  TIM1_ICInitStruct->TIM1_ICFilter = ((u8)0x00);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_TimeBaseStructInit
N* Description    : Fills each TIM1_TimeBaseInitStruct member with its default value.
N* Input          : - TIM1_TimeBaseInitStruct : pointer to a TIM1_TimeBaseInitTypeDef
N*                    structure which will be initialized.
N* Output         : None
N* Return         : None
N* 功能           : 把TIM1_TIM1BaseInitStruct中的每一个参数按缺省值填入 ；
N*******************************************************************************/
Nvoid TIM1_TimeBaseStructInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct)
N{
N  /* Set the default configuration */
N  TIM1_TimeBaseInitStruct->TIM1_Period = TIM1_Period_Reset_Mask;
X  TIM1_TimeBaseInitStruct->TIM1_Period = ((u16)0xFFFF);
N  TIM1_TimeBaseInitStruct->TIM1_Prescaler = TIM1_Prescaler_Reset_Mask;
X  TIM1_TimeBaseInitStruct->TIM1_Prescaler = ((u16)0x0000);
N  TIM1_TimeBaseInitStruct->TIM1_ClockDivision = TIM1_CKD_DIV1;
X  TIM1_TimeBaseInitStruct->TIM1_ClockDivision = ((u16)0x0000);
N  TIM1_TimeBaseInitStruct->TIM1_CounterMode = TIM1_CounterMode_Up;
X  TIM1_TimeBaseInitStruct->TIM1_CounterMode = ((u16)0x0000);
N  TIM1_TimeBaseInitStruct->TIM1_RepetitionCounter = TIM1_RepetitionCounter_Reset_Mask;
X  TIM1_TimeBaseInitStruct->TIM1_RepetitionCounter = ((u16)0x0000);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_BDTRStructInit
N* Description    : Fills each TIM1_BDTRInitStruct member with its default value.
N* Input          : - TIM1_BDTRInitStruct : pointer to a TIM1_BDTRInitTypeDef
N*                    structure which will be initialized.
N* Output         : None
N* Return         : None
N* 功能           : 把TIM1_BDTRInitStruct中的每一个参数按缺省值填入 ；
N*******************************************************************************/
Nvoid TIM1_BDTRStructInit(TIM1_BDTRInitTypeDef* TIM1_BDTRInitStruct)
N{
N  /* Set the default configuration */
N  TIM1_BDTRInitStruct->TIM1_OSSRState = TIM1_OSSRState_Disable;
X  TIM1_BDTRInitStruct->TIM1_OSSRState = ((u16)0x0000);
N  TIM1_BDTRInitStruct->TIM1_OSSIState = TIM1_OSSIState_Disable;
X  TIM1_BDTRInitStruct->TIM1_OSSIState = ((u16)0x0000);
N  TIM1_BDTRInitStruct->TIM1_LOCKLevel = TIM1_LOCKLevel_OFF;
X  TIM1_BDTRInitStruct->TIM1_LOCKLevel = ((u16)0x0000);
N  TIM1_BDTRInitStruct->TIM1_DeadTime = TIM1_DeadTime_Reset_Mask;
X  TIM1_BDTRInitStruct->TIM1_DeadTime = ((u16)0x0000);
N  TIM1_BDTRInitStruct->TIM1_Break = TIM1_Break_Disable;
X  TIM1_BDTRInitStruct->TIM1_Break = ((u16)0x0000);
N  TIM1_BDTRInitStruct->TIM1_BreakPolarity = TIM1_BreakPolarity_Low;
X  TIM1_BDTRInitStruct->TIM1_BreakPolarity = ((u16)0x0000);
N  TIM1_BDTRInitStruct->TIM1_AutomaticOutput = TIM1_AutomaticOutput_Disable;
X  TIM1_BDTRInitStruct->TIM1_AutomaticOutput = ((u16)0x0000);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_Cmd
N* Description    : Enables or disables the TIM1 peripheral.
N* Input          : - Newstate: new state of the TIM1 peripheral.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1外设 ；
N*******************************************************************************/
Nvoid TIM1_Cmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  /* set or Reset the CEN Bit */
N  *(vu32 *) CR1_CEN_BB = (u16)NewState;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x00) * 32) + (0x00 * 4)) = (u16)NewState;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_CtrlPWMOutputs
N* Description    : Enables or disables the TIM1 peripheral Main Outputs.
N* Input          : - Newstate: new state of the TIM1 peripheral Main Outputs.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1外设的主输出 ；
N*******************************************************************************/
Nvoid TIM1_CtrlPWMOutputs(FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  /* Set or Reset the MOE Bit */
N  *(vu32 *) BDTR_MOE_BB = (u16)Newstate;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x44) * 32) + (0x0F * 4)) = (u16)Newstate;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ITConfig
N* Description    : Enables or disables the specified TIM1 interrupts.
N* Input          : - TIM1_IT: specifies the TIM1 interrupts sources to be enabled
N*                    or disabled.
N*                    This parameter can be any combination of the following values:
N*                       - TIM1_IT_Update: TIM1 update Interrupt source
N*                       - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
N*                       - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
N*                       - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
N*                       - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
N*                       - TIM1_IT_CCUpdate: TIM1 Capture Compare Update Interrupt
N*                         source
N*                       - TIM1_IT_Trigger: TIM1 Trigger Interrupt source
N*                       - TIM1_IT_Break: TIM1 Break Interrupt source
N*                  - Newstate: new state of the TIM1 interrupts.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能指定的TIM1中断 ；
N*******************************************************************************/
Nvoid TIM1_ITConfig(u16 TIM1_IT, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_IT(TIM1_IT));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState == ENABLE)
N  {
N    /* Enable the Interrupt sources */
N    TIM1->DIER |= TIM1_IT;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->DIER |= TIM1_IT;
N  }
N  else
N  {
N    /* Disable the Interrupt sources */
N    TIM1->DIER &= (u16)~TIM1_IT;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->DIER &= (u16)~TIM1_IT;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_DMAConfig
N* Description    : Configures the TIM1s DMA interface.
N* Input          : - TIM1_DMABase: DMA Base address.
N*                    This parameter can be one of the following values:
N*                       - TIM1_DMABase_CR1, TIM1_DMABase_CR2, TIM1_DMABase_SMCR,
N*                         TIM1_DMABase_DIER, TIM1_DMABase_SR, TIM1_DMABase_EGR,
N*                         TIM1_DMABase_CCMR1, TIM1_DMABase_CCMR2, TIM1_DMABase_CCER,
N*                         TIM1_DMABase_CNT, TIM1_DMABase_PSC, TIM1_DMABase_ARR,
N*                         TIM1_DMABase_RCR, TIM1_DMABase_CCR1, TIM1_DMABase_CCR2,
N*                         TIM1_DMABase_CCR3, TIM1_DMABase_CCR4, TIM1_DMABase_BDTR,
N*                         TIM1_DMABase_DCR.
N*                   - TIM1_DMABurstLength: DMA Burst length.
N*                     This parameter can be one value between:
N*                     TIM1_DMABurstLength_1Byte and TIM1_DMABurstLength_18Bytes.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1的DMA接口 ；
N*******************************************************************************/
Nvoid TIM1_DMAConfig(u16 TIM1_DMABase, u16 TIM1_DMABurstLength)
N{
N  u32 tmpdcr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_DMA_BASE(TIM1_DMABase));
X  ((void)0);
N  assert_param(IS_TIM1_DMA_LENGTH(TIM1_DMABurstLength));
X  ((void)0);
N
N  tmpdcr = TIM1->DCR;
X  tmpdcr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->DCR;
N
N  /* Reset the DBA and the DBL Bits */
N  tmpdcr &= DCR_DMA_Mask;
X  tmpdcr &= ((u16)0x0000);
N
N  /* Set the DMA Base and the DMA Burst Length */
N  tmpdcr |= TIM1_DMABase | TIM1_DMABurstLength;
N
N  TIM1->DCR = (u16)tmpdcr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->DCR = (u16)tmpdcr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_DMACmd
N* Description    : Enables or disables the TIM1s DMA Requests.
N* Input          : - TIM1_DMASources: specifies the DMA Request sources.
N*                    This parameter can be any combination of the following values:
N*                       - TIM1_DMA_Update: TIM1 update Interrupt source
N*                       - TIM1_DMA_CC1: TIM1 Capture Compare 1 DMA source
N*                       - TIM1_DMA_CC2: TIM1 Capture Compare 2 DMA source
N*                       - TIM1_DMA_CC3: TIM1 Capture Compare 3 DMA source
N*                       - TIM1_DMA_CC4: TIM1 Capture Compare 4 DMA source
N*                       - TIM1_DMA_COM: TIM1 Capture Compare Update DMA
N*                         source
N*                       - TIM1_DMA_Trigger: TIM1 Trigger DMA source
N*                  - Newstate: new state of the DMA Request sources.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能指定的TIM1的DMA请求 ；
N*******************************************************************************/
Nvoid TIM1_DMACmd(u16 TIM1_DMASource, FunctionalState Newstate)
N{
N  u32 tmpdier = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_DMA_SOURCE(TIM1_DMASource));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  tmpdier = TIM1->DIER;
X  tmpdier = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->DIER;
N
N  if (Newstate == ENABLE)
N  {
N    /* Enable the DMA sources */
N    tmpdier |= TIM1_DMASource;
N  }
N  else
N  {
N    /* Disable the DMA sources */
N    tmpdier &= (u16)~TIM1_DMASource;
N  }
N  TIM1->DIER = (u16)tmpdier;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->DIER = (u16)tmpdier;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_InternalClockConfig
N* Description    : Configures the TIM1 interrnal Clock
N* Input          : None
N* Output         : None
N* Return         : None
N* 功能           : 设置DMA内部时钟 ；
N*******************************************************************************/
Nvoid TIM1_InternalClockConfig(void)
N{
N  /* Disable slave mode to clock the prescaler directly with the internal clock */
N  TIM1->SMCR &=  SMCR_SMS_Mask;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR &=  ((u16)0xFFF0);
N}
N/*******************************************************************************
N* Function Name  : TIM1_ETRClockMode1Config
N* Description    : Configures the TIM1 External clock Mode1
N* Input          : - TIM1_ExtTRGPrescaler: The external Trigger Prescaler.
N*                    It can be one of the following values:
N*                       - TIM1_ExtTRGPSC_OFF
N*                       - TIM1_ExtTRGPSC_DIV2
N*                       - TIM1_ExtTRGPSC_DIV4
N*                       - TIM1_ExtTRGPSC_DIV8.
N*                  - TIM1_ExtTRGPolarity: The external Trigger Polarity.
N*                    It can be one of the following values:
N*                       - TIM1_ExtTRGPolarity_Inverted
N*                       - TIM1_ExtTRGPolarity_NonInverted
N*                  - ExtTRGFilter: External Trigger Filter.
N*                    This parameter must be a value between 0x00 and 0x0F
N* Output         : None
N* Return         : None
N* 功能           : 配置TIM1外部时钟模式1 ；
N*******************************************************************************/
Nvoid TIM1_ETRClockMode1Config(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
N                             u16 ExtTRGFilter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
X  ((void)0);
N
N  /* Configure the ETR Clock source */
N  TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
N
N  /* Select the External clock mode1 */
N  TIM1->SMCR &= SMCR_SMS_Mask;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR &= ((u16)0xFFF0);
N  TIM1->SMCR |= TIM1_SlaveMode_External1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR |= ((u16)0x0007);
N  
N  /* Select the Trigger selection : ETRF */
N  TIM1->SMCR &= SMCR_TS_Mask;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR &= ((u16)0xFF87);
N  TIM1->SMCR |= TIM1_TS_ETRF;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR |= ((u16)0x0070);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ETRClockMode2Config
N* Description    : Configures the TIM1 External clock Mode2
N* Input          : - TIM1_ExtTRGPrescaler: The external Trigger Prescaler.
N*                    It can be one of the following values:
N*                       - TIM1_ExtTRGPSC_OFF
N*                       - TIM1_ExtTRGPSC_DIV2
N*                       - TIM1_ExtTRGPSC_DIV4
N*                       - TIM1_ExtTRGPSC_DIV8
N*                  - TIM1_ExtTRGPolarity: The external Trigger Polarity.
N*                    It can be one of the following values:
N*                       - TIM1_ExtTRGPolarity_Inverted
N*                       - TIM1_ExtTRGPolarity_NonInverted
N*                  - ExtTRGFilter: External Trigger Filter.
N*                    This parameter must be a value between 0x00 and 0x0F
N* Output         : None
N* Return         : None
N* 功能           : 配置TIM1外部时钟模式2 ；
N*******************************************************************************/
Nvoid TIM1_ETRClockMode2Config(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
N                             u16 ExtTRGFilter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
X  ((void)0);
N
N  /* Configure the ETR Clock source */
N  TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
N
N  /* Enable the External clock mode2 */
N  *(vu32 *) SMCR_ECE_BB = SMCR_ECE_Set;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x08) * 32) + (0x0E * 4)) = ((u16)0x0001);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ETRConfig
N* Description    : Configures the TIM1 External Trigger (ETR).
N* Input          : - TIM1_ExtTRGPrescaler: The external Trigger Prescaler.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ExtTRGPSC_OFF
N*                       - TIM1_ExtTRGPSC_DIV2
N*                       - TIM1_ExtTRGPSC_DIV4
N*                       - TIM1_ExtTRGPSC_DIV8
N*                  - TIM1_ExtTRGPolarity: The external Trigger Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ExtTRGPolarity_Inverted
N*                       - TIM1_ExtTRGPolarity_NonInverted
N*                  - ExtTRGFilter: External Trigger Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N* 功能           : 配置TIM1外部触发 ；
N*******************************************************************************/
Nvoid TIM1_ETRConfig(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
N                    u16 ExtTRGFilter)
N{
N  u32 tmpsmcr = 0;
N
N  tmpsmcr = TIM1->SMCR;
X  tmpsmcr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR;
N
N  /* Set the Prescaler, the Filter value and the Polarity */
N  tmpsmcr &= SMCR_ETR_Mask;
X  tmpsmcr &= ((u16)0x40F7);
N  tmpsmcr |= TIM1_ExtTRGPrescaler | TIM1_ExtTRGPolarity | (u16)((u16)ExtTRGFilter << 8);
N
N  TIM1->SMCR = (u16)tmpsmcr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR = (u16)tmpsmcr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ITRxExternalClockConfig
N* Description    : Configures the TIM1 Internal Trigger as External Clock
N* Input          : - TIM1_ITRSource: Internal Trigger source.
N*                    This parameter can be one of the following values:
N*                       - TIM1_TS_ITR0: Internal Trigger 0
N*                       - TIM1_TS_ITR1: Internal Trigger 1
N*                       - TIM1_TS_ITR2: Internal Trigger 2
N*                       - TIM1_TS_ITR3: Internal Trigger 3
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1内部触发为外部时钟模式 ；
N*******************************************************************************/
Nvoid TIM1_ITRxExternalClockConfig(u16 TIM1_InputTriggerSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_INTERNAL_TRIGGER_SELECTION(TIM1_InputTriggerSource));
X  ((void)0);
N  
N  /* Select the Internal Trigger */
N  TIM1_SelectInputTrigger(TIM1_InputTriggerSource);
N
N  /* Select the External clock mode1 */
N  TIM1->SMCR |= TIM1_SlaveMode_External1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR |= ((u16)0x0007);
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_TIxExternalClockConfig
N* Description    : Configures the TIM1 Trigger as External Clock
N* Input          : - TIM1_TIxExternalCLKSource: Trigger source.
N*                    This parameter can be one of the following values:
N*                       - TIM1_TS_TI1F_ED: TI1 Edge Detector
N*                       - TIM1_TS_TI1FP1: Filtered TIM1 Input 1
N*                       - TIM1_TS_TI2FP2: Filtered TIM1 Input 2
N*                  - TIM1_ICPolarity: specifies the TIx Polarity.
N*                    This parameter can be:
N*                       - TIM1_ICPolarity_Rising
N*                       - TIM1_ICPolarity_Falling
N*                   - ICFilter : specifies the filter value.
N*                     This parameter must be a value between 0x0 and 0xF.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1触发为外部时钟 ；
N*******************************************************************************/
Nvoid TIM1_TIxExternalClockConfig(u16 TIM1_TIxExternalCLKSource,
N                                u16 TIM1_ICPolarity, u8 ICFilter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_TIX_TRIGGER_SELECTION(TIM1_TIxExternalCLKSource));
X  ((void)0);
N  assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
X  ((void)0);
N  assert_param(IS_TIM1_IC_FILTER(ICFilter));
X  ((void)0);
N
N  /* Configure the TIM1 Input Clock Source */
N  if (TIM1_TIxExternalCLKSource == TIM1_TIxExternalCLK1Source_TI2)
X  if (TIM1_TIxExternalCLKSource == ((u16)0x0060))
N  {
N    TI2_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
X    TI2_Config(TIM1_ICPolarity, ((u16)0x0001), ICFilter);
N  }
N  else
N  {
N    TI1_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
X    TI1_Config(TIM1_ICPolarity, ((u16)0x0001), ICFilter);
N  }
N
N  /* Select the Trigger source */
N  TIM1_SelectInputTrigger(TIM1_TIxExternalCLKSource);
N
N  /* Select the External clock mode1 */
N  TIM1->SMCR |= TIM1_SlaveMode_External1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR |= ((u16)0x0007);
N}
N/*******************************************************************************
N* Function Name  : TIM1_SelectInputTrigger
N* Description    : Selects the TIM1 Input Trigger source
N* Input          : - TIM1_InputTriggerSource: The Trigger source.
N*                    This parameter can be one of the following values:
N*                       - TIM1_TS_ITR0: Internal Trigger 0
N*                       - TIM1_TS_ITR1: Internal Trigger 1
N*                       - TIM1_TS_ITR2: Internal Trigger 2
N*                       - TIM1_TS_ITR3: Internal Trigger 3
N*                       - TIM1_TS_TI1F_ED: TI1 Edge Detector
N*                       - TIM1_TS_TI1FP1: Filtered Timer Input 1
N*                       - TIM1_TS_TI2FP2: Filtered Timer Input 2
N*                       - TIM1_TS_ETRF: External Trigger input
N* Output         : None
N* Return         : None
N* 功能           : 选择TIM1输入触发源 ；
N*******************************************************************************/
Nvoid TIM1_SelectInputTrigger(u16 TIM1_InputTriggerSource)
N{
N  u32 tmpsmcr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_TRIGGER_SELECTION(TIM1_InputTriggerSource));
X  ((void)0);
N
N  tmpsmcr = TIM1->SMCR;
X  tmpsmcr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR;
N
N  /* Select the Tgigger Source */
N  tmpsmcr &= SMCR_TS_Mask;
X  tmpsmcr &= ((u16)0xFF87);
N  tmpsmcr |= TIM1_InputTriggerSource;
N
N  TIM1->SMCR = (u16)tmpsmcr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR = (u16)tmpsmcr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_UpdateDisableConfig
N* Description    : Enables or Disables the TIM1 Update event.
N* Input          : - Newstate: new state of the TIM1 peripheral Preload register
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1更新事件 ；
N*******************************************************************************/
Nvoid TIM1_UpdateDisableConfig(FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  /* Set or Reset the UDIS Bit */
N  *(vu32 *) CR1_UDIS_BB = (u16)Newstate;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x00) * 32) + (0x01 * 4)) = (u16)Newstate;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_UpdateRequestConfig
N* Description    : Selects the TIM1 Update Request Interrupt source.
N* Input          : - TIM1_UpdateSource: specifies the Update source.
N*                    This parameter can be one of the following values:
N*                       - TIM1_UpdateSource_Regular
N*                       - TIM1_UpdateSource_Global
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1更新请求源 ；
N*******************************************************************************/
Nvoid TIM1_UpdateRequestConfig(u8 TIM1_UpdateSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_UPDATE_SOURCE(TIM1_UpdateSource));
X  ((void)0);
N
N  /* Set or Reset the URS Bit */
N  *(vu32 *) CR1_URS_BB = TIM1_UpdateSource;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x00) * 32) + (0x02 * 4)) = TIM1_UpdateSource;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectHallSensor
N* Description    : Enables or disables the TIM1s Hall sensor interface.
N* Input          : - Newstate: new state of the TIM1 Hall sensor interface
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1霍尔传感器接口 ；
N*******************************************************************************/
Nvoid TIM1_SelectHallSensor(FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  /* Set or Reset the TI1S Bit */
N  *(vu32 *) CR2_TI1S_BB = (u16)Newstate;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x07 * 4)) = (u16)Newstate;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectOPM
N* Description    : Enables or disables the TIM1s One Pulse Mode.
N* Input          : - TIM1_OPMode: specifies the OPM Mode to be used.
N*                    This parameter can be one of the following values:
N*                    - TIM1_OPMode_Single
N*                    - TIM1_OPMode_Repetitive
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1单脉冲模式 ；
N*******************************************************************************/
Nvoid TIM1_SelectOnePulseMode(u16 TIM1_OPMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OPM_MODE(TIM1_OPMode));
X  ((void)0);
N
N  /* Set or Reset the OPM Bit */
N  *(vu32 *) CR1_OPM_BB = TIM1_OPMode;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x00) * 32) + (0x03 * 4)) = TIM1_OPMode;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectOutputTrigger
N* Description    : Selects the TIM1 Trigger Output Mode.
N* Input          : - TIM1_TRGOSource: specifies the Trigger Output source.
N*                    This paramter can be one of the following values:
N*                       - TIM1_TRGOSource_Reset
N*                       - TIM1_TRGOSource_Enable
N*                       - TIM1_TRGOSource_Update
N*                       - TIM1_TRGOSource_OC1
N*                       - TIM1_TRGOSource_OC1Ref
N*                       - TIM1_TRGOSource_OC2Ref
N*                       - TIM1_TRGOSource_OC3Ref
N*                       - TIM1_TRGOSource_OC4Ref
N* Output         : None
N* Return         : None
N* 功能           : 选择TIM1触发输出模式 ；
N*******************************************************************************/
Nvoid TIM1_SelectOutputTrigger(u16 TIM1_TRGOSource)
N{
N  u32 tmpcr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_TRGO_SOURCE(TIM1_TRGOSource));
X  ((void)0);
N
N  tmpcr2 = TIM1->CR2;
X  tmpcr2 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR2;
N
N  /* Reset the MMS Bits */
N  tmpcr2 &= CR2_MMS_Mask;
X  tmpcr2 &= ((u16)0x0080);
N
N  /* Select the TRGO source */
N  tmpcr2 |=  TIM1_TRGOSource;
N
N  TIM1->CR2 = (u16)tmpcr2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR2 = (u16)tmpcr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectSlaveMode
N* Description    : Selects the TIM1 Slave Mode.
N* Input          : - TIM1_SlaveMode: specifies the TIM1 Slave Mode.
N*                    This paramter can be one of the following values:
N*                       - TIM1_SlaveMode_Reset
N*                       - TIM1_SlaveMode_Gated
N*                       - TIM1_SlaveMode_Trigger
N*                       - TIM1_SlaveMode_External1
N* Output         : None
N* Return         : None
N* 功能           : 选择TIM1从模式 ；
N*******************************************************************************/
Nvoid TIM1_SelectSlaveMode(u16 TIM1_SlaveMode)
N{
N  u32 tmpsmcr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_SLAVE_MODE(TIM1_SlaveMode));
X  ((void)0);
N
N  tmpsmcr = TIM1->SMCR;
X  tmpsmcr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR;
N
N  /* Reset the SMS Bits */
N  tmpsmcr &= SMCR_SMS_Mask;
X  tmpsmcr &= ((u16)0xFFF0);
N
N  /* Select the Slave Mode */
N  tmpsmcr |= TIM1_SlaveMode;
N
N  TIM1->SMCR = (u16)tmpsmcr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR = (u16)tmpsmcr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectMasterSlaveMode
N* Description    : Sets or Resets the TIM1 Master/Slave Mode.
N* Input          : - TIM1_MasterSlaveMode: specifies the TIM1 Master Slave Mode.
N*                    This paramter can be one of the following values:
N*                       - TIM1_MasterSlaveMode_Enable: synchronization between
N*                         the current timer and its slaves (through TRGO).
N*                       - TIM1_MasterSlaveMode_Disable: No action
N* Output         : None
N* Return         : None
N* 功能           : 设置或者重置TIM1主/从模式 ；
N*******************************************************************************/
Nvoid TIM1_SelectMasterSlaveMode(u16 TIM1_MasterSlaveMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_MSM_STATE(TIM1_MasterSlaveMode));
X  ((void)0);
N
N  /* Set or Reset the MSM Bit */
N  *(vu32 *) SMCR_MSM_BB = TIM1_MasterSlaveMode;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x08) * 32) + (0x07 * 4)) = TIM1_MasterSlaveMode;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_EncoderInterfaceConfig
N* Description    : Configures the TIM1 Encoder Interface.
N* Input          : - TIM1_EncoderMode: specifies the TIM1 Encoder Mode.
N*                    This parameter can be one of the following values:
N*                       - TIM1_EncoderMode_TI1: Counter counts on TI1FP1 edge
N*                         depending on TI2FP2 level.
N*                       - TIM1_EncoderMode_TI2: Counter counts on TI2FP2 edge
N*                         depending on TI1FP1 level.
N*                       - TIM1_EncoderMode_TI12: Counter counts on both TI1FP1 and
N*                         TI2FP2 edges depending on the level of the other input.
N*                  - TIM1_IC1Polarity: specifies the IC1 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_ICPolarity_Falling
N*                       - TIM1_ICPolarity_Rising
N*                  - TIM1_IC2Polarity: specifies the IC2 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_ICPolarity_Falling
N*                       - TIM1_ICPolarity_Rising
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1编码界面 ；
N*******************************************************************************/
Nvoid TIM1_EncoderInterfaceConfig(u16 TIM1_EncoderMode, u16 TIM1_IC1Polarity,
N                                u16 TIM1_IC2Polarity)
N{
N  u32 tmpsmcr = 0;
N  u32 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_ENCODER_MODE(TIM1_EncoderMode));
X  ((void)0);
N  assert_param(IS_TIM1_IC_POLARITY(TIM1_IC1Polarity));
X  ((void)0);
N  assert_param(IS_TIM1_IC_POLARITY(TIM1_IC2Polarity));
X  ((void)0);
N
N  tmpsmcr = TIM1->SMCR;
X  tmpsmcr = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR;
N  tmpccmr1 = TIM1->CCMR1;
X  tmpccmr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Set the encoder Mode */
N  tmpsmcr &= SMCR_SMS_Mask;
X  tmpsmcr &= ((u16)0xFFF0);
N  tmpsmcr |= TIM1_EncoderMode;
N
N  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
N  tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
X  tmpccmr1 &= ((u16)0xFFFC) & ((u16)0xFCFF);
N  tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
X  tmpccmr1 |= ((u16)0x0001) | ((u16)0x0100);
N
N  /* Set the TI1 and the TI2 Polarities */
N  *(vu32 *) CCER_CC1P_BB = TIM1_IC1Polarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x01 * 4)) = TIM1_IC1Polarity;
N  *(vu32 *) CCER_CC2P_BB = TIM1_IC2Polarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x05 * 4)) = TIM1_IC2Polarity;
N
N  TIM1->SMCR = (u16)tmpsmcr;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SMCR = (u16)tmpsmcr;
N
N  TIM1->CCMR1 = (u16)tmpccmr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_PrescalerConfig
N* Description    : Configures the TIM1 Prescaler.
N* Input          : - Prescaler: specifies the Prescaler Register value
N*                  - TIM1_PSCReloadMode: specifies the TIM1 Prescaler Reload mode.
N*                    This parmeter can be one of the following values:
N*                       - TIM1_PSCReloadMode_Update: The Prescaler is loaded at
N*                         the update event.
N*                       - TIM1_PSCReloadMode_Immediate: The Prescaler is loaded
N*                         immediatly.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1预分频 ；
N*******************************************************************************/
Nvoid TIM1_PrescalerConfig(u16 Prescaler, u16 TIM1_PSCReloadMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_PRESCALER_RELOAD(TIM1_PSCReloadMode));
X  ((void)0);
N
N  /* Set the Prescaler value */
N  TIM1->PSC = Prescaler;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->PSC = Prescaler;
N
N  /* Set or reset the UG Bit */
N  *(vu32 *) EGR_UG_BB = TIM1_PSCReloadMode;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x14) * 32) + (0x00 * 4)) = TIM1_PSCReloadMode;
N}
N/*******************************************************************************
N* Function Name  : TIM1_CounterModeConfig
N* Description    : Specifies the TIM1 Counter Mode to be used.
N* Input          : - TIM1_CounterMode: specifies the Counter Mode to be used
N*                    This parameter can be one of the following values:
N*                       - TIM1_CounterMode_Up: TIM1 Up Counting Mode
N*                       - TIM1_CounterMode_Down: TIM1 Down Counting Mode
N*                       - TIM1_CounterMode_CenterAligned1: TIM1 Center Aligned Mode1
N*                       - TIM1_CounterMode_CenterAligned2: TIM1 Center Aligned Mode2
N*                       - TIM1_CounterMode_CenterAligned3: TIM1 Center Aligned Mode3
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1计数器模式 ；
N*******************************************************************************/
Nvoid TIM1_CounterModeConfig(u16 TIM1_CounterMode)
N{
N  u32 tmpcr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_COUNTER_MODE(TIM1_CounterMode));
X  ((void)0);
N
N  tmpcr1 = TIM1->CR1;
X  tmpcr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR1;
N
N  /* Reset the CMS and DIR Bits */
N  tmpcr1 &= CR1_CounterMode_Mask;
X  tmpcr1 &= ((u16)0x039F);
N
N  /* Set the Counter Mode */
N  tmpcr1 |= TIM1_CounterMode;
N
N  TIM1->CR1 = (u16)tmpcr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR1 = (u16)tmpcr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ForcedOC1Config
N* Description    : Forces the TIM1 Channel1 output waveform to active or inactive 
N*                  level.
N* Input          : - TIM1_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ForcedAction_Active: Force active level on OC1REF
N*                       - TIM1_ForcedAction_InActive: Force inactive level on
N*                         OC1REF.
N* Output         : None
N* Return         : None
N* 功能           : 置TIM1输出1为活动或者非活动电平 ；
N*******************************************************************************/
Nvoid TIM1_ForcedOC1Config(u16 TIM1_ForcedAction)
N{
N  u32 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
X  ((void)0);
N
N  tmpccmr1 = TIM1->CCMR1;
X  tmpccmr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Reset the OCM Bits */
N  tmpccmr1 &= CCMR_OCM13_Mask;
X  tmpccmr1 &= ((u16)0x7F0F);
N
N  /* Configure The Forced output Mode */
N  tmpccmr1 |= TIM1_ForcedAction;
N
N  TIM1->CCMR1 = (u16)tmpccmr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ForcedOC2Config
N* Description    : Forces the TIM1 Channel2 output waveform to active or inactive 
N*                  level.
N* Input          : - TIM1_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ForcedAction_Active: Force active level on OC2REF
N*                       - TIM1_ForcedAction_InActive: Force inactive level on
N*                         OC2REF.
N* Output         : None
N* Return         : None
N* 功能           : 置TIM1输出2为活动或者非活动电平 ；
N*******************************************************************************/
Nvoid TIM1_ForcedOC2Config(u16 TIM1_ForcedAction)
N{
N  u32 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
X  ((void)0);
N
N  tmpccmr1 = TIM1->CCMR1;
X  tmpccmr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Reset the OCM Bits */
N  tmpccmr1 &= CCMR_OCM24_Mask;
X  tmpccmr1 &= ((u16)0x0F7F);
N
N  /* Configure The Forced output Mode */
N  tmpccmr1 |= (u32)TIM1_ForcedAction << 8;
N
N  TIM1->CCMR1 = (u16)tmpccmr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ForcedOC3Config
N* Description    : Forces the TIM1 Channel3 output waveform to active or inactive 
N*                  level.
N* Input          : - TIM1_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ForcedAction_Active: Force active level on OC3REF
N*                       - TIM1_ForcedAction_InActive: Force inactive level on
N*                         OC3REF.
N* Output         : None
N* Return         : None
N* 功能           : 置TIM1输出3为活动或者非活动电平
N*******************************************************************************/
Nvoid TIM1_ForcedOC3Config(u16 TIM1_ForcedAction)
N{
N  u32 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
X  ((void)0);
N
N  tmpccmr2 = TIM1->CCMR2;
X  tmpccmr2 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2;
N
N  /* Reset the OCM Bits */
N  tmpccmr2 &= CCMR_OCM13_Mask;
X  tmpccmr2 &= ((u16)0x7F0F);
N
N  /* Configure The Forced output Mode */
N  tmpccmr2 |= TIM1_ForcedAction;
N
N  TIM1->CCMR2 = (u16)tmpccmr2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = (u16)tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ForcedOC4Config
N* Description    : Forces the TIM1 Channel4 output waveform to active or inactive 
N*                  level.
N* Input          : - TIM1_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ForcedAction_Active: Force active level on OC4REF
N*                       - TIM1_ForcedAction_InActive: Force inactive level on
N*                         OC4REF.
N* Output         : None
N* Return         : None
N* 功能           : 置TIM1输出4为活动或者非活动电平
N*******************************************************************************/
Nvoid TIM1_ForcedOC4Config(u16 TIM1_ForcedAction)
N{
N  u32 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
X  ((void)0);
N
N  tmpccmr2 = TIM1->CCMR1;
X  tmpccmr2 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Reset the OCM Bits */
N  tmpccmr2 &= CCMR_OCM24_Mask;
X  tmpccmr2 &= ((u16)0x0F7F);
N
N  /* Configure The Forced output Mode */
N  tmpccmr2 |= (u16)((u16)TIM1_ForcedAction << 8);
N
N  TIM1->CCMR2 = (u16)tmpccmr2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = (u16)tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ARRPreloadConfig
N* Description    : Enables or disables TIM1 peripheral Preload register on ARR.
N* Input          : - Newstate: new state of the TIM1 peripheral Preload register
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1在ARR上的预装载寄存器 ；
N*******************************************************************************/
Nvoid TIM1_ARRPreloadConfig(FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  /* Set or Reset the ARPE Bit */
N  *(vu32 *) CR1_ARPE_BB = (u16)Newstate;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x00) * 32) + (0x07 * 4)) = (u16)Newstate;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectCOM
N* Description    : Selects the TIM1 peripheral Commutation event.
N* Input          : - Newstate: new state of the Commutation event.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 选择TIM1外设的通讯事件 ；
N*******************************************************************************/
Nvoid TIM1_SelectCOM(FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  /* Set or Reset the CCUS Bit */
N  *(vu32 *) CR2_CCUS_BB = (u16)Newstate;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x02 * 4)) = (u16)Newstate;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectCCDMA
N* Description    : Selects the TIM1 peripheral Capture Compare DMA source.
N* Input          : - Newstate: new state of the Capture Compare DMA source
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 选择TIM1外设的捕获比较DMA源 ；
N*******************************************************************************/
Nvoid TIM1_SelectCCDMA(FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  /* Set or Reset the CCDS Bit */
N  *(vu32 *) CR2_CCDS_BB = (u16)Newstate;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x03 * 4)) = (u16)Newstate;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_CCPreloadControl
N* Description    : Sets or Resets the TIM1 peripheral Capture Compare Preload 
N*                  Control bit.
N* Input          : - Newstate: new state of the Capture Compare Preload Control bit
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N* 功能           : 设置或者重置TIM1捕获比较控制位 ；
N*******************************************************************************/
Nvoid TIM1_CCPreloadControl(FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  /* Set or Reset the CCPC Bit */
N  *(vu32 *) CR2_CCPC_BB = (u16)Newstate;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x04) * 32) + (0x00 * 4)) = (u16)Newstate;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC1PreloadConfig
N* Description    : Enables or disables the TIM1 peripheral Preload Register on CCR1.
N* Input          : - TIM1_OCPreload: new state of the Capture Compare Preload
N*                    register.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCPreload_Enable
N*                       - TIM1_OCPreload_Disable
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1在CCR1上的预装载寄存器 ；
N*******************************************************************************/
Nvoid TIM1_OC1PreloadConfig(u16 TIM1_OCPreload)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
X  ((void)0);
N
N  /* Set or Reset the OC1PE Bit */
N  *(vu32 *) CCMR1_OC1PE_BB = (u16)TIM1_OCPreload;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x18) * 32) + (0x03 * 4)) = (u16)TIM1_OCPreload;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC2PreloadConfig
N* Description    : Enables or disables the TIM1 peripheral Preload Register on CCR2.
N* Input          : - TIM1_OCPreload: new state of the Capture Compare Preload
N*                    register.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCPreload_Enable
N*                       - TIM1_OCPreload_Disable
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1在CCR2上的预装载寄存器 ；
N*******************************************************************************/
Nvoid TIM1_OC2PreloadConfig(u16 TIM1_OCPreload)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
X  ((void)0);
N
N  /* Set or Reset the OC2PE Bit */
N  *(vu32 *) CCMR1_OC2PE_BB = (u16)TIM1_OCPreload;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x18) * 32) + (0x0B * 4)) = (u16)TIM1_OCPreload;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC3PreloadConfig
N* Description    : Enables or disables the TIM1 peripheral Preload Register on CCR3.
N* Input          : - TIM1_OCPreload: new state of the Capture Compare Preload
N*                    register.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCPreload_Enable
N*                       - TIM1_OCPreload_Disable
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1在CCR3上的预装载寄存器 ；
N*******************************************************************************/
Nvoid TIM1_OC3PreloadConfig(u16 TIM1_OCPreload)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
X  ((void)0);
N
N  /* Set or Reset the OC3PE Bit */
N  *(vu32 *) CCMR2_OC3PE_BB = (u16)TIM1_OCPreload;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x1C) * 32) + (0x03 * 4)) = (u16)TIM1_OCPreload;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC4PreloadConfig
N* Description    : Enables or disables the TIM1 peripheral Preload Register on CCR4.
N* Input          : - TIM1_OCPreload: new state of the Capture Compare Preload
N*                    register.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCPreload_Enable
N*                       - TIM1_OCPreload_Disable
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1在CCR4上的预装载寄存器 ；
N*******************************************************************************/
Nvoid TIM1_OC4PreloadConfig(u16 TIM1_OCPreload)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
X  ((void)0);
N
N  /* Set or Reset the OC4PE Bit */
N  *(vu32 *) CCMR2_OC4PE_BB = (u16)TIM1_OCPreload;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x1C) * 32) + (0x0B * 4)) = (u16)TIM1_OCPreload;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC1FastConfig
N* Description    : Configures the TIM1 Capture Compare 1 Fast feature.
N* Input          : - TIM1_OCFast: new state of the Output Compare Fast Enable bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCFast_Enable
N*                       - TIM1_OCFast_Disable
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较1快速特征 ；
N*******************************************************************************/
Nvoid TIM1_OC1FastConfig(u16 TIM1_OCFast)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
X  ((void)0);
N
N  /* Set or Reset the OC1FE Bit */
N  *(vu32 *) CCMR1_OC1FE_BB = (u16)TIM1_OCFast;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x18) * 32) + (0x02 * 4)) = (u16)TIM1_OCFast;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC2FastConfig
N* Description    : Configures the TIM1 Capture Compare Fast feature.
N* Input          : - TIM1_OCFast: new state of the Output Compare Fast Enable bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCFast_Enable
N*                       - TIM1_OCFast_Disable
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较2快速特征 ；
N*******************************************************************************/
Nvoid TIM1_OC2FastConfig(u16 TIM1_OCFast)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
X  ((void)0);
N
N  /* Set or Reset the OC2FE Bit */
N  *(vu32 *) CCMR1_OC2FE_BB = (u16)TIM1_OCFast;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x18) * 32) + (0x0A * 4)) = (u16)TIM1_OCFast;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC3FastConfig
N* Description    : Configures the TIM1 Capture Compare Fast feature.
N* Input          : - TIM1_OCFast: new state of the Output Compare Fast Enable bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCFast_Enable
N*                       - TIM1_OCFast_Disable
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较3快速特征 ；
N*******************************************************************************/
Nvoid TIM1_OC3FastConfig(u16 TIM1_OCFast)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
X  ((void)0);
N
N  /* Set or Reset the OC3FE Bit */
N  *(vu32 *) CCMR2_OC3FE_BB = (u16)TIM1_OCFast;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x1C) * 32) + (0x02 * 4)) = (u16)TIM1_OCFast;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC4FastConfig
N* Description    : Configures the TIM1 Capture Compare Fast feature.
N* Input          : - TIM1_OCFast: new state of the Output Compare Fast Enable bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCFast_Enable
N*                       - TIM1_OCFast_Disable
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较4快速特征 ；
N*******************************************************************************/
Nvoid TIM1_OC4FastConfig(u16 TIM1_OCFast)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
X  ((void)0);
N
N  /* Set or Reset the OC4FE Bit */
N  *(vu32 *) CCMR2_OC4FE_BB = (u16)TIM1_OCFast;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x1C) * 32) + (0x0A * 4)) = (u16)TIM1_OCFast;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ClearOC1Ref
N* Description    : Clears or safeguards the OCREF1 signal on an external event
N*                  - TIM1_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCClear_Enable
N*                       - TIM1_OCClear_Disable
N* Output         : None
N* Return         : None
N* 功能           : 在一个外部事件时清除或者保持OCREF1信号 ；
N*******************************************************************************/
Nvoid TIM1_ClearOC1Ref(u16 TIM1_OCClear)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
X  ((void)0);
N
N  /* Set or Reset the OC1CE Bit */
N  *(vu32 *) CCMR1_OC1CE_BB = (u16)TIM1_OCClear;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x18) * 32) + (0x07 * 4)) = (u16)TIM1_OCClear;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ClearOC2Ref
N* Description    : Clears or safeguards the OCREF2 signal on an external event
N*                  - TIM1_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCClear_Enable
N*                       - TIM1_OCClear_Disable
N* Output         : None
N* Return         : None
N* 功能           : 在一个外部事件时清除或者保持OCREF2信号 ；
N*******************************************************************************/
Nvoid TIM1_ClearOC2Ref(u16 TIM1_OCClear)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
X  ((void)0);
N
N  /* Set or Reset the OC2CE Bit */
N  *(vu32 *) CCMR1_OC2CE_BB = (u16)TIM1_OCClear;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x18) * 32) + (0x0F * 4)) = (u16)TIM1_OCClear;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ClearOC3Ref
N* Description    : Clears or safeguards the OCREF3 signal on an external event
N*                  - TIM1_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCClear_Enable
N*                       - TIM1_OCClear_Disable
N* Output         : None
N* Return         : None
N* 功能           : 在一个外部事件时清除或者保持OCREF3信号 ；
N*******************************************************************************/
Nvoid TIM1_ClearOC3Ref(u16 TIM1_OCClear)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
X  ((void)0);
N
N  /* Set or Reset the OC3CE Bit */
N  *(vu32 *) CCMR2_OC3CE_BB = (u16)TIM1_OCClear;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x1C) * 32) + (0x07 * 4)) = (u16)TIM1_OCClear;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ClearOC4Ref
N* Description    : Clears or safeguards the OCREF4 signal on an external event
N*                  - TIM1_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM1_OCClear_Enable
N*                       - TIM1_OCClear_Disable
N* Output         : None
N* Return         : None
N* 功能           : 在一个外部事件时清除或者保持OCREF4信号 ；
N*******************************************************************************/
Nvoid TIM1_ClearOC4Ref(u16 TIM1_OCClear)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
X  ((void)0);
N
N  /* Set or Reset the OC4CE Bit */
N  *(vu32 *) CCMR2_OC4CE_BB = (u16)TIM1_OCClear;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x1C) * 32) + (0x0F * 4)) = (u16)TIM1_OCClear;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GenerateEvent
N* Description    : Configures the TIM1 event to be generate by software.
N* Input          : - TIM1_EventSource: specifies the event source.
N*                    This parameter can be one or more of the following values:
N*                       - TIM1_EventSource_Update: TIM1 update Event source
N*                       - TIM1_EventSource_CC1: TIM1 Capture Compare 1 Event source
N*                       - TIM1_EventSource_CC2: TIM1 Capture Compare 2 Event source
N*                       - TIM1_EventSource_CC3: TIM1 Capture Compare 3 Event source
N*                       - TIM1_EventSource_CC4: TIM1 Capture Compare 4 Event source
N*                       - TIM1_EventSource_COM: TIM1 COM Event source
N*                       - TIM1_EventSource_Trigger: TIM1 Trigger Event source
N*                       - TIM1_EventSourceBreak: TIM1 Break Event source
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1事件由软件产生 ；
N*******************************************************************************/
Nvoid TIM1_GenerateEvent(u16 TIM1_EventSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_EVENT_SOURCE(TIM1_EventSource));
X  ((void)0);
N
N  /* Set the event sources */
N  TIM1->EGR |= TIM1_EventSource;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->EGR |= TIM1_EventSource;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC1PolarityConfig
N* Description    : Configures the TIM1 Channel 1 polarity.
N* Input          : - TIM1_OCPolarity: specifies the OC1 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_OCPolarity_High: Output Compare active high
N*                       - TIM1_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1通道1极性 ；
N*******************************************************************************/
Nvoid TIM1_OC1PolarityConfig(u16 TIM1_OCPolarity)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
X  ((void)0);
N
N  /* Set or Reset the CC1P Bit */
N  *(vu32 *) CCER_CC1P_BB = (u16)TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x01 * 4)) = (u16)TIM1_OCPolarity;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC1NPolarityConfig
N* Description    : Configures the TIM1 Channel 1N polarity.
N* Input          : - TIM1_OCNPolarity: specifies the OC1N Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_OCNPolarity_High: Output Compare active high
N*                       - TIM1_OCNPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1通道1N极性 ；
N*******************************************************************************/
Nvoid TIM1_OC1NPolarityConfig(u16 TIM1_OCNPolarity)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
X  ((void)0);
N
N  /* Set or Reset the CC3P Bit */
N  *(vu32 *) CCER_CC1NP_BB = (u16)TIM1_OCNPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x03 * 4)) = (u16)TIM1_OCNPolarity;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC2PolarityConfig
N* Description    : Configures the TIM1 Channel 2 polarity.
N* Input          : - TIM1_OCPolarity: specifies the OC2 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_OCPolarity_High: Output Compare active high
N*                       - TIM1_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1通道2极性 ；
N*******************************************************************************/
Nvoid TIM1_OC2PolarityConfig(u16 TIM1_OCPolarity)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
X  ((void)0);
N
N  /* Set or Reset the CC2P Bit */
N  *(vu32 *) CCER_CC2P_BB = (u16)TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x05 * 4)) = (u16)TIM1_OCPolarity;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC2NPolarityConfig
N* Description    : Configures the TIM1 Channel 2N polarity.
N* Input          : - TIM1_OCNPolarity: specifies the OC2N Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_OCNPolarity_High: Output Compare active high
N*                       - TIM1_OCNPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1通道2N极性 ；
N*******************************************************************************/
Nvoid TIM1_OC2NPolarityConfig(u16 TIM1_OCNPolarity)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
X  ((void)0);
N
N  /* Set or Reset the CC3P Bit */
N  *(vu32 *) CCER_CC2NP_BB = (u16)TIM1_OCNPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x07 * 4)) = (u16)TIM1_OCNPolarity;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC3PolarityConfig
N* Description    : Configures the TIM1 Channel 3 polarity.
N* Input          : - TIM1_OCPolarity: specifies the OC3 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_OCPolarity_High: Output Compare active high
N*                       - TIM1_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1通道3极性 ；
N*******************************************************************************/
Nvoid TIM1_OC3PolarityConfig(u16 TIM1_OCPolarity)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
X  ((void)0);
N
N  /* Set or Reset the CC3P Bit */
N  *(vu32 *) CCER_CC3P_BB = (u16)TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x09 * 4)) = (u16)TIM1_OCPolarity;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC3NPolarityConfig
N* Description    : Configures the TIM1 Channel 3N polarity.
N* Input          : - TIM1_OCNPolarity: specifies the OC3N Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_OCNPolarity_High: Output Compare active high
N*                       - TIM1_OCNPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1通道3N极性 ；
N*******************************************************************************/
Nvoid TIM1_OC3NPolarityConfig(u16 TIM1_OCNPolarity)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCNPolarity));
X  ((void)0);
N
N  /* Set or Reset the CC3P Bit */
N  *(vu32 *) CCER_CC3NP_BB = (u16)TIM1_OCNPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0B * 4)) = (u16)TIM1_OCNPolarity;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_OC4PolarityConfig
N* Description    : Configures the TIM1 Channel 4 polarity.
N* Input          : - TIM1_OCPolarity: specifies the OC4 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM1_OCPolarity_High: Output Compare active high
N*                       - TIM1_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1通道4极性 ；
N*******************************************************************************/
Nvoid TIM1_OC4PolarityConfig(u16 TIM1_OCPolarity)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
X  ((void)0);
N
N  /* Set or Reset the CC4P Bit */
N  *(vu32 *) CCER_CC4P_BB = (u16)TIM1_OCPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0D * 4)) = (u16)TIM1_OCPolarity;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_CCxCmd
N* Description    : Enables or disables the TIM1 Capture Compare Channel x.
N* Input          : - TIM1_Channel: specifies the TIM1 Channel
N*                    This parmeter can be one of the following values:
N*                       - TIM1_Channel1: TIM1 Channel1
N*                       - TIM1_Channel2: TIM1 Channel2
N*                       - TIM1_Channel3: TIM1 Channel3
N*                       - TIM1_Channel4: TIM1 Channel4
N*                 - Newstate: specifies the TIM1 Channel CCxE bit new state.
N*                   This parameter can be: ENABLE or DISABLE. 
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1捕获比较通道x ；
N*******************************************************************************/
Nvoid TIM1_CCxCmd(u16 TIM1_Channel, FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  if(TIM1_Channel == TIM1_Channel_1)
X  if(TIM1_Channel == ((u16)0x0000))
N  {
N    /* Set or Reset the CC1E Bit */
N    *(vu32 *) CCER_CC1E_BB = (u16)Newstate;  
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x00 * 4)) = (u16)Newstate;  
N  }
N  else if(TIM1_Channel == TIM1_Channel_2)
X  else if(TIM1_Channel == ((u16)0x0001))
N  {
N    /* Set or Reset the CC2E Bit */
N    *(vu32 *) CCER_CC2E_BB = (u16)Newstate;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x04 * 4)) = (u16)Newstate;
N  }
N  else if(TIM1_Channel == TIM1_Channel_3)
X  else if(TIM1_Channel == ((u16)0x0002))
N  {
N    /* Set or Reset the CC3E Bit */
N    *(vu32 *) CCER_CC3E_BB = (u16)Newstate;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x08 * 4)) = (u16)Newstate;
N  }
N  else
N  {
N    /* Set or Reset the CC4E Bit */
N    *(vu32 *) CCER_CC4E_BB = (u16)Newstate;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0C * 4)) = (u16)Newstate;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_CCxNCmd
N* Description    : Enables or disables the TIM1 Capture Compare Channel xN.
N* Input          : - TIM1_Channel: specifies the TIM1 Channel
N*                    This parmeter can be one of the following values:
N*                       - TIM1_Channel1: TIM1 Channel1
N*                       - TIM1_Channel2: TIM1 Channel2
N*                       - TIM1_Channel3: TIM1 Channel3
N*                 - Newstate: specifies the TIM1 Channel CCxNE bit new state.
N*                   This parameter can be: ENABLE or DISABLE. 
N* Output         : None
N* Return         : None
N* 功能           : 使能或者失能TIM1捕获比较通道xN ；
N*******************************************************************************/
Nvoid TIM1_CCxNCmd(u16 TIM1_Channel, FunctionalState Newstate)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_COMPLEMENTARY_CHANNEL(TIM1_Channel));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(Newstate));
X  ((void)0);
N
N  if(TIM1_Channel == TIM1_Channel_1)
X  if(TIM1_Channel == ((u16)0x0000))
N  {
N    /* Set or Reset the CC1NE Bit */
N    *(vu32 *) CCER_CC1NE_BB = (u16)Newstate;  
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x02 * 4)) = (u16)Newstate;  
N  }
N  else if(TIM1_Channel == TIM1_Channel_2)
X  else if(TIM1_Channel == ((u16)0x0001))
N  {
N    /* Set or Reset the CC2NE Bit */
N    *(vu32 *) CCER_CC2NE_BB = (u16)Newstate;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x06 * 4)) = (u16)Newstate;
N  }
N  else 
N  {
N    /* Set or Reset the CC3NE Bit */
N    *(vu32 *) CCER_CC3NE_BB = (u16)Newstate;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0A * 4)) = (u16)Newstate;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SelectOCxM
N* Description    : Selects the TIM1 Ouput Compare Mode.
N*                  This function disables the selected channel before changing 
N*                  the Ouput Compare Mode. User has to enable this channel using
N*                  TIM1_CCxCmd and TIM1_CCxNCmd functions.
N* Input          : - TIM1_Channel: specifies the TIM1 Channel
N*                    This parmeter can be one of the following values:
N*                       - TIM1_Channel1: TIM1 Channel1
N*                       - TIM1_Channel2: TIM1 Channel2
N*                       - TIM1_Channel3: TIM1 Channel3
N*                       - TIM1_Channel4: TIM1 Channel4
N*                  - TIM1_OCMode: specifies the TIM1 Output Compare Mode.
N*                    This paramter can be one of the following values:
N*                       - TIM1_OCMode_Timing
N*                       - TIM1_OCMode_Active
N*                       - TIM1_OCMode_Toggle
N*                       - TIM1_OCMode_PWM1
N*                       - TIM1_OCMode_PWM2
N*                       - TIM1_ForcedAction_Active
N*                       - TIM1_ForcedAction_InActive
N* Output         : None
N* Return         : None
N* 功能           : 选择TIM1输出比较模式。
N                   本函数在改变输出比较模式前失能选中的通道。
N                   用户必须使用函数TIM1_CCxCmd和TIM1_CCxNCmd来使能这个通道。
N*******************************************************************************/
Nvoid TIM1_SelectOCxM(u16 TIM1_Channel, u16 TIM1_OCMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
X  ((void)0);
N  assert_param(IS_TIM1_OCM(TIM1_OCMode));
X  ((void)0);
N
N  if(TIM1_Channel == TIM1_Channel_1)
X  if(TIM1_Channel == ((u16)0x0000))
N  {
N    /* Disable the Channel 1: Reset the CCE Bit */
N    *(vu32 *) CCER_CC1E_BB = CCER_CCE_Reset;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x00 * 4)) = ((u16)0x0000);
N
N    /* Reset the Output Compare Bits */
N    TIM1->CCMR1 &= OC13Mode_Mask;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 &= ((u16)0xFF00);
N
N    /* Set the Ouput Compare Mode */
N    TIM1->CCMR1 |= TIM1_OCMode;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 |= TIM1_OCMode;
N  }
N  else if(TIM1_Channel == TIM1_Channel_2)
X  else if(TIM1_Channel == ((u16)0x0001))
N  {
N    /* Disable the Channel 2: Reset the CCE Bit */
N    *(vu32 *) CCER_CC2E_BB = CCER_CCE_Reset;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x04 * 4)) = ((u16)0x0000);
N
N    /* Reset the Output Compare Bits */
N    TIM1->CCMR1 &= OC24Mode_Mask;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 &= ((u16)0x00FF);
N
N    /* Set the Ouput Compare Mode */
N    TIM1->CCMR1 |= (u16)((u16)TIM1_OCMode << 8);
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 |= (u16)((u16)TIM1_OCMode << 8);
N  }
N  else if(TIM1_Channel == TIM1_Channel_3)
X  else if(TIM1_Channel == ((u16)0x0002))
N  {
N    /* Disable the Channel 3: Reset the CCE Bit */
N    *(vu32 *) CCER_CC3E_BB = CCER_CCE_Reset;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x08 * 4)) = ((u16)0x0000);
N
N    /* Reset the Output Compare Bits */
N    TIM1->CCMR2 &= OC13Mode_Mask;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 &= ((u16)0xFF00);
N
N    /* Set the Ouput Compare Mode */
N    TIM1->CCMR2 |= TIM1_OCMode;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 |= TIM1_OCMode;
N  }
N  else
N  {
N    /* Disable the Channel 4: Reset the CCE Bit */
N    *(vu32 *) CCER_CC4E_BB = CCER_CCE_Reset;
X    *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0C * 4)) = ((u16)0x0000);
N
N    /* Reset the Output Compare Bits */
N    TIM1->CCMR2 &= OC24Mode_Mask;
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 &= ((u16)0x00FF);
N
N    /* Set the Ouput Compare Mode */
N    TIM1->CCMR2 |= (u16)((u16)TIM1_OCMode << 8);
X    ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 |= (u16)((u16)TIM1_OCMode << 8);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetCounter
N* Description    : Sets the TIM1 Counter Register value
N* Input          : - Counter: specifies the Counter register new value.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1计数器寄存器值 ；
N*******************************************************************************/
Nvoid TIM1_SetCounter(u16 Counter)
N{
N  /* Set the Counter Register value */
N  TIM1->CNT = Counter;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CNT = Counter;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetAutoreload
N* Description    : Sets the TIM1 Autoreload Register value.
N* Input          : - Autoreload: specifies the Autoreload register new value.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1自动重装载寄存器值 ；
N*******************************************************************************/
Nvoid TIM1_SetAutoreload(u16 Autoreload)
N{
N  /* Set the Autoreload Register value */
N  TIM1->ARR = Autoreload;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->ARR = Autoreload;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetCompare1
N* Description    : Sets the TIM1 Capture Compare1 Register value.
N* Input          : - Compare1: specifies the Capture Compare1 register new value.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较1寄存器值 ；
N*******************************************************************************/
Nvoid TIM1_SetCompare1(u16 Compare1)
N{
N  /* Set the Capture Compare1 Register value */
N  TIM1->CCR1 = Compare1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR1 = Compare1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetCompare2
N* Description    : Sets the TIM1 Capture Compare2 Register value.
N* Input          : - Compare2: specifies the Capture Compare2 register new value.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较2寄存器值 ；
N*******************************************************************************/
Nvoid TIM1_SetCompare2(u16 Compare2)
N{
N  /* Set the Capture Compare2 Register value */
N  TIM1->CCR2 = Compare2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR2 = Compare2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetCompare3
N* Description    : Sets the TIM1 Capture Compare3 Register value.
N* Input          : - Compare3: specifies the Capture Compare3 register new value.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较3寄存器值 ；
N*******************************************************************************/
Nvoid TIM1_SetCompare3(u16 Compare3)
N{
N  /* Set the Capture Compare3 Register value */
N  TIM1->CCR3 = Compare3;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR3 = Compare3;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetCompare4
N* Description    : Sets the TIM1 Capture Compare4 Register value.
N* Input          : - Compare4: specifies the Capture Compare4 register new value.
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1捕获比较4寄存器值 ；
N*******************************************************************************/
Nvoid TIM1_SetCompare4(u16 Compare4)
N{
N  /* Set the Capture Compare4 Register value */
N  TIM1->CCR4 = Compare4;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR4 = Compare4;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetIC1Prescaler
N* Description    : Sets the TIM1 Input Capture 1 prescaler.
N* Input          : - TIM1_IC1Prescaler: specifies the Input Capture prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPSC_DIV1: no prescaler
N*                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
N*                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
N*                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1输入捕获1预分频 ；
N*******************************************************************************/
Nvoid TIM1_SetIC1Prescaler(u16 TIM1_IC1Prescaler)
N{
N  u32 tmpccmr1 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC1Prescaler));
X  ((void)0);
N
N  tmpccmr1 = TIM1->CCMR1;
X  tmpccmr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Reset the IC1PSC Bits */
N  tmpccmr1 &= CCMR_IC13PSC_Mask;
X  tmpccmr1 &= ((u16)0xFFF3);
N
N  /* Set the IC1PSC value */
N  tmpccmr1 |= TIM1_IC1Prescaler;
N
N  TIM1->CCMR1 = (u16)tmpccmr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetIC2Prescaler
N* Description    : Sets the TIM1 Input Capture 2 prescaler.
N* Input          : - TIM1_IC2Prescaler: specifies the Input Capture prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPSC_DIV1: no prescaler
N*                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
N*                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
N*                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1输入捕获2预分频 ；
N*******************************************************************************/
Nvoid TIM1_SetIC2Prescaler(u16 TIM1_IC2Prescaler)
N{
N  u32 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC2Prescaler));
X  ((void)0);
N
N  tmpccmr1 = TIM1->CCMR1;
X  tmpccmr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Reset the IC2PSC Bits */
N  tmpccmr1 &= CCMR_IC24PSC_Mask;
X  tmpccmr1 &= ((u16)0xF3FF);
N
N  /* Set the IC2PSC value */
N  tmpccmr1 |= (u16)((u16)TIM1_IC2Prescaler << 8);
N
N  TIM1->CCMR1 = (u16)tmpccmr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetIC3Prescaler
N* Description    : Sets the TIM1 Input Capture 3 prescaler.
N* Input          : - TIM1_IC3Prescaler: specifies the Input Capture prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPSC_DIV1: no prescaler
N*                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
N*                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
N*                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1输入捕获3预分频 ；
N*******************************************************************************/
Nvoid TIM1_SetIC3Prescaler(u16 TIM1_IC3Prescaler)
N{
N  u32 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC3Prescaler));
X  ((void)0);
N
N  tmpccmr2 = TIM1->CCMR2;
X  tmpccmr2 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2;
N
N  /* Reset the IC3PSC Bits */
N  tmpccmr2 &= CCMR_IC13PSC_Mask;
X  tmpccmr2 &= ((u16)0xFFF3);
N
N  /* Set the IC3PSC value */
N  tmpccmr2 |= TIM1_IC3Prescaler;
N
N  TIM1->CCMR2 = (u16)tmpccmr2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = (u16)tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetIC4Prescaler
N* Description    : Sets the TIM1 Input Capture 4 prescaler.
N* Input          : - TIM1_IC4Prescaler: specifies the Input Capture prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPSC_DIV1: no prescaler
N*                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
N*                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
N*                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1输入捕获4预分频 ；
N*******************************************************************************/
Nvoid TIM1_SetIC4Prescaler(u16 TIM1_IC4Prescaler)
N{
N  u32 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC4Prescaler));
X  ((void)0);
N
N  tmpccmr2 = TIM1->CCMR2;
X  tmpccmr2 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2;
N
N  /* Reset the IC4PSC Bits */
N  tmpccmr2 &= CCMR_IC24PSC_Mask;
X  tmpccmr2 &= ((u16)0xF3FF);
N
N  /* Set the IC4PSC value */
N  tmpccmr2 |= (u16)((u16)TIM1_IC4Prescaler << 8);
N
N  TIM1->CCMR2 = (u16)tmpccmr2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = (u16)tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_SetClockDivision
N* Description    : Sets the TIM1 Clock Division value.
N* Input          : - TIM1_CKD: specifies the clock division value.
N*                    This parameter can be one of the following value:
N*                       - TIM1_CKD_DIV1: TDTS = Tck_tim
N*                       - TIM1_CKD_DIV2: TDTS = 2*Tck_tim
N*                       - TIM1_CKD_DIV4: TDTS = 4*Tck_tim
N* Output         : None
N* Return         : None
N* 功能           : 设置TIM1的时钟分割值 ；
N*******************************************************************************/
Nvoid TIM1_SetClockDivision(u16 TIM1_CKD)
N{
N  u32 tmpcr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_CKD_DIV(TIM1_CKD));
X  ((void)0);
N
N  tmpcr1 = TIM1->CR1;
X  tmpcr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR1;
N
N  /* Reset the CKD Bits */
N  tmpcr1 &= CR1_CKD_Mask;
X  tmpcr1 &= ((u16)0x00FF);
N
N  /* Set the CKD value */
N  tmpcr1 |= TIM1_CKD;
N
N  TIM1->CR1 = (u16)tmpcr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CR1 = (u16)tmpcr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetCapture1
N* Description    : Gets the TIM1 Input Capture 1 value.
N* Input          : None
N* Output         : None
N* Return         : Capture Compare 1 Register value.
N* 功能           : 获得TIM1输入捕获1的值 ；
N*******************************************************************************/
Nu16 TIM1_GetCapture1(void)
N{
N  /* Get the Capture 1 Register value */
N  return TIM1->CCR1;
X  return ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetCapture2
N* Description    : Gets the TIM1 Input Capture 2 value.
N* Input          : None
N* Output         : None
N* Return         : Capture Compare 2 Register value.
N* 功能           : 获得TIM1输入捕获2的值 ；
N*******************************************************************************/
Nu16 TIM1_GetCapture2(void)
N{
N  /* Get the Capture 2 Register value */
N  return TIM1->CCR2;
X  return ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetCapture3
N* Description    : Gets the TIM1 Input Capture 3 value.
N* Input          : None
N* Output         : None
N* Return         : Capture Compare 3 Register value.
N* 功能           : 获得TIM1输入捕获3的值 ；
N*******************************************************************************/
Nu16 TIM1_GetCapture3(void)
N{
N  /* Get the Capture 3 Register value */
N  return TIM1->CCR3;
X  return ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR3;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetCapture4
N* Description    : Gets the TIM1 Input Capture 4 value.
N* Input          : None
N* Output         : None
N* Return         : Capture Compare 4 Register value.
N* 功能           : 获得TIM1输入捕获4的值 ；
N*******************************************************************************/
Nu16 TIM1_GetCapture4(void)
N{
N  /* Get the Capture 4 Register value */
N  return TIM1->CCR4;
X  return ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCR4;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetCounter
N* Description    : Gets the TIM1 Counter value.
N* Input          : None
N* Output         : None
N* Return         : Counter Register value.
N* 功能           : 获得TIM1计数器的值 ；
N*******************************************************************************/
Nu16 TIM1_GetCounter(void)
N{
N  /* Get the Counter Register value */
N  return TIM1->CNT;
X  return ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CNT;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetPrescaler
N* Description    : Gets the TIM1 Prescaler value.
N* Input          : None
N* Output         : None
N* Return         : Prescaler Register value.
N* 功能           : 获得TIM1预分频值 ；
N*******************************************************************************/
Nu16 TIM1_GetPrescaler(void)
N{
N  /* Get the Prescaler Register value */
N  return TIM1->PSC;
X  return ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->PSC;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetFlagStatus
N* Description    : Checks whether the specified TIM1 flag is set or not.
N* Input          : - TIM1_FLAG: specifies the flag to check.
N*                    This parameter can be one of the following values:
N*                       - TIM1_FLAG_Update: TIM1 update Flag
N*                       - TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
N*                       - TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
N*                       - TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
N*                       - TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
N*                       - TIM1_FLAG_COM: TIM1 Commutation Flag
N*                       - TIM1_FLAG_Trigger: TIM1 Trigger Flag
N*                       - TIM1_FLAG_Break: TIM1 Break Flag
N*                       - TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
N*                       - TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
N*                       - TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
N*                       - TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
N* Output         : None
N* Return         : The new state of TIM1_FLAG (SET or RESET).
N* 功能           : 检查指定的TIM1标志位设置与否 ；
N*******************************************************************************/
NFlagStatus TIM1_GetFlagStatus(u16 TIM1_FLAG)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_GET_FLAG(TIM1_FLAG));
X  ((void)0);
N
N  if ((TIM1->SR & TIM1_FLAG) != (u16)RESET )
X  if ((((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SR & TIM1_FLAG) != (u16)RESET )
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ClearFlag
N* Description    : Clears the TIM1s pending flags.
N* Input          : - TIM1_FLAG: specifies the flag to clear.
N*                    This parameter can be any combination of the following values:
N*                       - TIM1_FLAG_Update: TIM1 update Flag
N*                       - TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
N*                       - TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
N*                       - TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
N*                       - TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
N*                       - TIM1_FLAG_COM: TIM1 Commutation Flag
N*                       - TIM1_FLAG_Trigger: TIM1 Trigger Flag
N*                       - TIM1_FLAG_Break: TIM1 Break Flag
N*                       - TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
N*                       - TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
N*                       - TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
N*                       - TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
N* Output         : None
N* Return         : None
N* 功能           : 清除TIM1的待处理标志位 ；
N*******************************************************************************/
Nvoid TIM1_ClearFlag(u16 TIM1_FLAG)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_CLEAR_FLAG(TIM1_FLAG));
X  ((void)0);
N
N  /* Clear the flags */
N  TIM1->SR &= (u16)~TIM1_FLAG;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SR &= (u16)~TIM1_FLAG;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_GetITStatus
N* Description    : Checks whether the TIM1 interrupt has occurred or not.
N* Input          : - TIM1_IT: specifies the TIM1 interrupt source to check.
N*                    This parameter can be one of the following values:
N*                       - TIM1_IT_Update: TIM1 update Interrupt source
N*                       - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
N*                       - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
N*                       - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
N*                       - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
N*                       - TIM1_IT_COM: TIM1 Commutation Interrupt
N*                         source
N*                       - TIM1_IT_Trigger: TIM1 Trigger Interrupt source
N*                       - TIM1_IT_Break: TIM1 Break Interrupt source
N* Output         : None
N* Return         : The new state of the TIM1_IT(SET or RESET).
N* 功能           : 检查指定的TIM1中断发生与否 ；
N*******************************************************************************/
NITStatus TIM1_GetITStatus(u16 TIM1_IT)
N{
N  ITStatus bitstatus = RESET;
N  
N  u16 TIM1_itStatus = 0x0, TIM1_itEnable = 0x0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM1_GET_IT(TIM1_IT));
X  ((void)0);
N  
N  TIM1_itStatus = TIM1->SR & TIM1_IT;
X  TIM1_itStatus = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SR & TIM1_IT;
N  
N  TIM1_itEnable = TIM1->DIER & TIM1_IT;
X  TIM1_itEnable = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->DIER & TIM1_IT;
N
N  if ((TIM1_itStatus != (u16)RESET ) && (TIM1_itEnable != (u16)RESET ))
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : TIM1_ClearITPendingBit
N* Description    : Clears the TIM1's interrupt pending bits.
N* Input          : - TIM1_IT: specifies the pending bit to clear.
N*                    This parameter can be any combination of the following values:
N*                       - TIM1_IT_Update: TIM1 update Interrupt source
N*                       - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
N*                       - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
N*                       - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
N*                       - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
N*                       - TIM1_IT_COM: TIM1 Commutation Interrupt
N*                         source
N*                       - TIM1_IT_Trigger: TIM1 Trigger Interrupt source
N*                       - TIM1_IT_Break: TIM1 Break Interrupt source
N* Output         : None
N* Return         : None
N* 功能           : 清除TIM1的中断待处理位 ；
N*******************************************************************************/
Nvoid TIM1_ClearITPendingBit(u16 TIM1_IT)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM1_IT(TIM1_IT));
X  ((void)0);
N
N  /* Clear the IT pending Bit */
N  TIM1->SR &= (u16)~TIM1_IT;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->SR &= (u16)~TIM1_IT;
N}
N
N/*******************************************************************************
N* Function Name  : TI1_Config
N* Description    : Configure the TI1 as Input.
N* Input          : - TIM1_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPolarity_Rising
N*                       - TIM1_ICPolarity_Falling
N*                  - TIM1_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICSelection_DirectTI: TIM1 Input 1 is selected to
N*                         be connected to IC1.
N*                       - TIM1_ICSelection_IndirectTI: TIM1 Input 1 is selected to
N*                         be connected to IC2.
N*                       - TIM1_ICSelection_TRC:TIM1 Input 1 is selected to be
N*                         connected to TRC.
N*                  - TIM1_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N* 功能           : 
N*******************************************************************************/
Nstatic void TI1_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter)
N{
N  u32 tmpccmr1 = 0;
N
N  tmpccmr1 = TIM1->CCMR1;
X  tmpccmr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Disable the Channel 1: Reset the CCE Bit */
N  *(vu32 *) CCER_CC1E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x00 * 4)) = ((u16)0x0000);
N
N  /* Select the Input and set the filter */
N  tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
X  tmpccmr1 &= ((u16)0xFFFC) & ((u16)0xFF0F);
N  tmpccmr1 |= (u16)TIM1_ICSelection | (u16)((u16)TIM1_ICFilter << 4);
N
N  TIM1->CCMR1 = (u16)tmpccmr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr1;
N
N  /* Select the Polarity */
N  *(vu32 *) CCER_CC1P_BB = TIM1_ICPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x01 * 4)) = TIM1_ICPolarity;
N
N  /* Set the CCE Bit */
N  *(vu32 *) CCER_CC1E_BB = CCER_CCE_Set;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x00 * 4)) = ((u16)0x0001);
N}
N
N/*******************************************************************************
N* Function Name  : TI2_Config
N* Description    : Configure the TI2 as Input.
N* Input          : - TIM1_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPolarity_Rising
N*                       - TIM1_ICPolarity_Falling
N*                  - TIM1_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICSelection_DirectTI: TIM1 Input 2 is selected to
N*                         be connected to IC2.
N*                       - TIM1_ICSelection_IndirectTI: TIM1 Input 2 is selected to
N*                         be connected to IC1.
N*                       - TIM1_ICSelection_TRC: TIM1 Input 2 is selected to be
N*                         connected to TRC.
N*                  - TIM1_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N* 功能           : 
N*******************************************************************************/
Nstatic void TI2_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter)
N{
N  u32 tmpccmr1 = 0;
N
N  tmpccmr1 = TIM1->CCMR1;
X  tmpccmr1 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1;
N
N  /* Disable the Channel 2: Reset the CCE Bit */
N  *(vu32 *) CCER_CC2E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x04 * 4)) = ((u16)0x0000);
N
N  /* Select the Input and set the filter */
N  tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
X  tmpccmr1 &= ((u16)0xFCFF) & ((u16)0x0FFF);
N  tmpccmr1 |= (u16)((u16)TIM1_ICSelection << 8) | (u16)((u16)TIM1_ICFilter <<12);
N
N  TIM1->CCMR1 = (u16)tmpccmr1;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR1 = (u16)tmpccmr1;
N
N  /* Select the Polarity */
N  *(vu32 *) CCER_CC2P_BB = TIM1_ICPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x05 * 4)) = TIM1_ICPolarity;
N
N  /* Set the CCE Bit */
N  *(vu32 *) CCER_CC2E_BB = CCER_CCE_Set;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x04 * 4)) = ((u16)0x0001);
N
N}
N
N/*******************************************************************************
N* Function Name  : TI3_Config
N* Description    : Configure the TI3 as Input.
N* Input          : - TIM1_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPolarity_Rising
N*                       - TIM1_ICPolarity_Falling
N*                  - TIM1_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICSelection_DirectTI: TIM1 Input 3 is selected to
N*                         be connected to IC3.
N*                       - TIM1_ICSelection_IndirectTI: TIM1 Input 3 is selected to
N*                         be connected to IC4.
N*                       - TIM1_ICSelection_TRC: TIM1 Input 3 is selected to be
N*                         connected to TRC.
N*                  - TIM1_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N* 功能           : 
N*******************************************************************************/
Nstatic void TI3_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter)
N{
N  u32 tmpccmr2 = 0;
N
N  tmpccmr2 = TIM1->CCMR2;
X  tmpccmr2 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2;
N
N  /* Disable the Channel 3: Reset the CCE Bit */
N  *(vu32 *) CCER_CC3E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x08 * 4)) = ((u16)0x0000);
N
N  /* Select the Input and set the filter */
N  tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
X  tmpccmr2 &= ((u16)0xFFFC) & ((u16)0xFF0F);
N  tmpccmr2 |= (u16)TIM1_ICSelection | (u16)((u16)TIM1_ICFilter << 4);
N
N  TIM1->CCMR2 = (u16)tmpccmr2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = (u16)tmpccmr2;
N
N  /* Select the Polarity */
N  *(vu32 *) CCER_CC3P_BB = TIM1_ICPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x09 * 4)) = TIM1_ICPolarity;
N
N  /* Set the CCE Bit */
N  *(vu32 *) CCER_CC3E_BB = CCER_CCE_Set;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x08 * 4)) = ((u16)0x0001);
N}
N
N/*******************************************************************************
N* Function Name  : TI4_Config
N* Description    : Configure the TI4 as Input.
N* Input          : - TIM1_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICPolarity_Rising
N*                       - TIM1_ICPolarity_Falling
N*                  - TIM1_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM1_ICSelection_DirectTI: TIM1 Input 4 is selected to
N*                         be connected to IC4.
N*                       - TIM1_ICSelection_IndirectTI: TIM1 Input 4 is selected to
N*                         be connected to IC3.
N*                       - TIM1_ICSelection_TRC: TIM1 Input 4 is selected to be
N*                         connected to TRC.
N*                  - TIM1_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N* 功能           : 
N*******************************************************************************/
Nstatic void TI4_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
N                       u8 TIM1_ICFilter)
N{
N  u32 tmpccmr2 = 0;
N
N  tmpccmr2 = TIM1->CCMR2;
X  tmpccmr2 = ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2;
N  
N  /* Disable the Channel 4: Reset the CCE Bit */
N  *(vu32 *) CCER_CC4E_BB = CCER_CCE_Reset;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0C * 4)) = ((u16)0x0000);
N
N  /* Select the Input and set the filter */
N  tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
X  tmpccmr2 &= ((u16)0xFCFF) & ((u16)0x0FFF);
N  tmpccmr2 |= (u16)((u16)TIM1_ICSelection << 8) | (u16)((u16)TIM1_ICFilter << 12);
N
N  TIM1->CCMR2 = (u16)tmpccmr2;
X  ((TIM1_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2C00))->CCMR2 = (u16)tmpccmr2;
N
N  /* Select the Polarity */
N  *(vu32 *) CCER_CC4P_BB = TIM1_ICPolarity;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0D * 4)) = TIM1_ICPolarity;
N
N  /* Set the CCE Bit */
N  *(vu32 *) CCER_CC4E_BB = CCER_CCE_Set;
X  *(vu32 *) (((u32)0x42000000) + (((((((u32)0x40000000) + 0x10000) + 0x2C00) - ((u32)0x40000000)) + 0x20) * 32) + (0x0C * 4)) = ((u16)0x0001);
N}
N/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
