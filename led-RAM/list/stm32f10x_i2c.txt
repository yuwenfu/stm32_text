; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_i2c.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\lib\inc -I.\User -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 -DVECT_TAB_RAM --omf_browse=.\output\stm32f10x_i2c.crf lib\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;816    *******************************************************************************/
;;;817    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L1.12|
;;;818    {
;;;819      /* Check the parameters */
;;;820      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;821      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;822    
;;;823      if (NewState != DISABLE)
;;;824      {
;;;825        /* Enable the selected I2C ARP */
;;;826        I2Cx->CR1 |= CR1_ENARP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420210          ORR      r2,r2,#0x10
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L1.22|
                  |L1.12|
;;;827      }
;;;828      else
;;;829      {
;;;830        /* Disable the selected I2C ARP */
;;;831        I2Cx->CR1 &= CR1_ENARP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L1.22|
;;;832      }
;;;833    }
000016  4770              BX       lr
;;;834    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;424    *******************************************************************************/
;;;425    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;426    {
;;;427      /* Check the parameters */
;;;428      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;429      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;430    
;;;431      if (NewState != DISABLE)
;;;432      {
;;;433        /* Enable the acknowledgement */
;;;434        I2Cx->CR1 |= CR1_ACK_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4426280          ORR      r2,r2,#0x400
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;435      }
;;;436      else
;;;437      {
;;;438        /* Disable the acknowledgement */
;;;439        I2Cx->CR1 &= CR1_ACK_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f33ff          MOV      r3,#0xfbff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L2.22|
;;;440      }
;;;441    }
000016  4770              BX       lr
;;;442    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;773    *******************************************************************************/
;;;774    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;775    {
;;;776      /* Check the parameters */
;;;777      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;778      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;779    
;;;780      if (NewState != DISABLE)
;;;781      {
;;;782        /* Enable the selected I2C PEC calculation */
;;;783        I2Cx->CR1 |= CR1_ENPEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420220          ORR      r2,r2,#0x20
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;784      }
;;;785      else
;;;786      {
;;;787        /* Disable the selected I2C PEC calculation */
;;;788        I2Cx->CR1 &= CR1_ENPEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L3.22|
;;;789      }
;;;790    }
000016  4770              BX       lr
;;;791    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;939    *******************************************************************************/
;;;940    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
000000  b570              PUSH     {r4-r6,lr}
;;;941    {
000002  4602              MOV      r2,r0
;;;942      u32 lastevent = 0;
000004  2400              MOVS     r4,#0
;;;943      u32 flag1 = 0, flag2 = 0;
000006  2500              MOVS     r5,#0
000008  2300              MOVS     r3,#0
;;;944      ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;945    
;;;946      /* Check the parameters */
;;;947      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;948      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;949    
;;;950      /* Read the I2Cx status register */
;;;951      flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;952      flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;953      flag2 = flag2 << 16;
000010  041b              LSLS     r3,r3,#16
;;;954    
;;;955      /* Get the last event value from I2C status register */
;;;956      lastevent = (flag1 | flag2) & FLAG_Mask;
000012  ea450603          ORR      r6,r5,r3
000016  f026447f          BIC      r4,r6,#0xff000000
;;;957    
;;;958      /* Check whether the last event is equal to I2C_EVENT */
;;;959      if (lastevent == I2C_EVENT )
00001a  428c              CMP      r4,r1
00001c  d101              BNE      |L4.34|
;;;960      {
;;;961        /* SUCCESS: last event is equal to I2C_EVENT */
;;;962        status = SUCCESS;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L4.36|
                  |L4.34|
;;;963      }
;;;964      else
;;;965      {
;;;966        /* ERROR: last event is different from I2C_EVENT */
;;;967        status = ERROR;
000022  2000              MOVS     r0,#0
                  |L4.36|
;;;968      }
;;;969    
;;;970      /* Return status */
;;;971      return status;
;;;972    }
000024  bd70              POP      {r4-r6,pc}
;;;973    
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1062   *******************************************************************************/
;;;1063   void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1064   {
;;;1065     u32 flagpos = 0;
000002  2300              MOVS     r3,#0
;;;1066     u32 flagindex = 0;
000004  2200              MOVS     r2,#0
;;;1067   
;;;1068     /* Check the parameters */
;;;1069     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1070     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1071   
;;;1072     /* Get the I2C flag position */
;;;1073     flagpos = I2C_FLAG & FLAG_Mask;
000006  f021437f          BIC      r3,r1,#0xff000000
;;;1074   
;;;1075     /* Get the I2C flag index */
;;;1076     flagindex = I2C_FLAG >> 28;
00000a  0f0a              LSRS     r2,r1,#28
;;;1077   
;;;1078     /* Clear the flag by writing 0 */
;;;1079     if (flagindex == 1)
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L5.22|
;;;1080     {
;;;1081       /* Clear the selected I2C flag */
;;;1082       I2Cx->SR1 = (u16)~flagpos;
000010  43dc              MVNS     r4,r3
000012  8284              STRH     r4,[r0,#0x14]
000014  e00d              B        |L5.50|
                  |L5.22|
;;;1083     }
;;;1084     /* Flags that need a read of the SR1 register to be cleared */
;;;1085     else if (flagindex == 2)
000016  2a02              CMP      r2,#2
000018  d101              BNE      |L5.30|
;;;1086     {
;;;1087       /* Read the SR1 register */
;;;1088       (void)I2Cx->SR1;
00001a  8a84              LDRH     r4,[r0,#0x14]
00001c  e009              B        |L5.50|
                  |L5.30|
;;;1089     }
;;;1090     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1091     else if (flagindex == 6)
00001e  2a06              CMP      r2,#6
000020  d105              BNE      |L5.46|
;;;1092     {
;;;1093       /* Read the SR1 register */
;;;1094       (void)I2Cx->SR1;
000022  8a84              LDRH     r4,[r0,#0x14]
;;;1095   
;;;1096       /* Write on the CR1 register */
;;;1097       I2Cx->CR1 |= CR1_PE_Set;
000024  8804              LDRH     r4,[r0,#0]
000026  f0440401          ORR      r4,r4,#1
00002a  8004              STRH     r4,[r0,#0]
00002c  e001              B        |L5.50|
                  |L5.46|
;;;1098     }
;;;1099     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1100     else /*flagindex == 0xA*/
;;;1101     {
;;;1102       /* Read the SR1 register */
;;;1103       (void)I2Cx->SR1;
00002e  8a84              LDRH     r4,[r0,#0x14]
;;;1104   
;;;1105       /* Read the SR2 register */
;;;1106       (void)I2Cx->SR2;
000030  8b04              LDRH     r4,[r0,#0x18]
                  |L5.50|
;;;1107     }
;;;1108   }
000032  bd10              POP      {r4,pc}
;;;1109   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1191   *******************************************************************************/
;;;1192   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1193   {
;;;1194     u32 flagpos = 0;
000002  2300              MOVS     r3,#0
;;;1195     u32 flagindex = 0;
000004  2200              MOVS     r2,#0
;;;1196   
;;;1197     /* Check the parameters */
;;;1198     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1199     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1200   
;;;1201     /* Get the I2C flag position */
;;;1202     flagpos = I2C_IT & FLAG_Mask;
000006  f021437f          BIC      r3,r1,#0xff000000
;;;1203   
;;;1204     /* Get the I2C flag index */
;;;1205     flagindex = I2C_IT >> 28;
00000a  0f0a              LSRS     r2,r1,#28
;;;1206   
;;;1207     /* Clear the flag by writing 0 */
;;;1208     if (flagindex == 1)
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L6.22|
;;;1209     {
;;;1210       /* Clear the selected I2C flag */
;;;1211       I2Cx->SR1 = (u16)~flagpos;
000010  43dc              MVNS     r4,r3
000012  8284              STRH     r4,[r0,#0x14]
000014  e00d              B        |L6.50|
                  |L6.22|
;;;1212     }
;;;1213     /* Flags that need a read of the SR1 register to be cleared */
;;;1214     else if (flagindex == 2)
000016  2a02              CMP      r2,#2
000018  d101              BNE      |L6.30|
;;;1215     {
;;;1216       /* Read the SR1 register */
;;;1217       (void)I2Cx->SR1;
00001a  8a84              LDRH     r4,[r0,#0x14]
00001c  e009              B        |L6.50|
                  |L6.30|
;;;1218     }
;;;1219     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1220     else if (flagindex == 6)
00001e  2a06              CMP      r2,#6
000020  d105              BNE      |L6.46|
;;;1221     {
;;;1222       /* Read the SR1 register */
;;;1223       (void)I2Cx->SR1;
000022  8a84              LDRH     r4,[r0,#0x14]
;;;1224   
;;;1225       /* Write on the CR1 register */
;;;1226       I2Cx->CR1 |= CR1_PE_Set;
000024  8804              LDRH     r4,[r0,#0]
000026  f0440401          ORR      r4,r4,#1
00002a  8004              STRH     r4,[r0,#0]
00002c  e001              B        |L6.50|
                  |L6.46|
;;;1227     }
;;;1228     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1229     else /*flagindex == 0xA*/
;;;1230     {
;;;1231       /* Read the SR1 register */
;;;1232       (void)I2Cx->SR1;
00002e  8a84              LDRH     r4,[r0,#0x14]
;;;1233   
;;;1234       /* Read the SR2 register */
;;;1235       (void)I2Cx->SR2;
000030  8b04              LDRH     r4,[r0,#0x18]
                  |L6.50|
;;;1236     }
;;;1237   }
000032  bd10              POP      {r4,pc}
;;;1238   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;289    *******************************************************************************/
;;;290    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L7.12|
;;;291    {
;;;292      /* Check the parameters */
;;;293      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;294      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;295    
;;;296      if (NewState != DISABLE)
;;;297      {
;;;298        /* Enable the selected I2C peripheral */
;;;299        I2Cx->CR1 |= CR1_PE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L7.22|
                  |L7.12|
;;;300      }
;;;301      else
;;;302      {
;;;303        /* Disable the selected I2C peripheral */
;;;304        I2Cx->CR1 &= CR1_PE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L7.22|
;;;305      }
;;;306    }
000016  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;316    *******************************************************************************/
;;;317    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;318    {
;;;319      /* Check the parameters */
;;;320      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;321      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;322    
;;;323      if (NewState != DISABLE)
;;;324      {
;;;325        /* Enable the selected I2C DMA requests */
;;;326        I2Cx->CR2 |= CR2_DMAEN_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;327      }
;;;328      else
;;;329      {
;;;330        /* Disable the selected I2C DMA requests */
;;;331        I2Cx->CR2 &= CR2_DMAEN_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f24f73ff          MOV      r3,#0xf7ff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;332      }
;;;333    }
000016  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;343    *******************************************************************************/
;;;344    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L9.12|
;;;345    {
;;;346      /* Check the parameters */
;;;347      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;348      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;349    
;;;350      if (NewState != DISABLE)
;;;351      {
;;;352        /* Next DMA transfer is the last transfer */
;;;353        I2Cx->CR2 |= CR2_LAST_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L9.22|
                  |L9.12|
;;;354      }
;;;355      else
;;;356      {
;;;357        /* Next DMA transfer is not the last transfer */
;;;358        I2Cx->CR2 &= CR2_LAST_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L9.22|
;;;359      }
;;;360    }
000016  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;110    *******************************************************************************/
;;;111    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;112    {
000002  4604              MOV      r4,r0
;;;113      /* Check the parameters */
;;;114      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;115    
;;;116      switch (*(u32*)&I2Cx)
000004  480e              LDR      r0,|L10.64|
000006  4420              ADD      r0,r0,r4
000008  b118              CBZ      r0,|L10.18|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d114              BNE      |L10.58|
000010  e009              B        |L10.38|
                  |L10.18|
;;;117      {
;;;118        case I2C1_BASE:
;;;119          /* Enable I2C1 reset state */
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000012  2101              MOVS     r1,#1
000014  0548              LSLS     r0,r1,#21
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;121          /* Release I2C1 from reset state */
;;;122          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
00001a  2100              MOVS     r1,#0
00001c  f44f1000          MOV      r0,#0x200000
000020  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;123          break;
000024  e00a              B        |L10.60|
                  |L10.38|
;;;124    
;;;125        case I2C2_BASE:
;;;126          /* Enable I2C2 reset state */
;;;127          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000026  2101              MOVS     r1,#1
000028  0588              LSLS     r0,r1,#22
00002a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;128          /* Release I2C2 from reset state */
;;;129          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00002e  2100              MOVS     r1,#0
000030  f44f0080          MOV      r0,#0x400000
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;130          break;
000038  e000              B        |L10.60|
                  |L10.58|
;;;131    
;;;132        default:
;;;133          break;
00003a  bf00              NOP      
                  |L10.60|
00003c  bf00              NOP                            ;123
;;;134      }
;;;135    }
00003e  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  |L10.64|
                          DCD      0xbfffac00

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;476    *******************************************************************************/
;;;477    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L11.12|
;;;478    {
;;;479      /* Check the parameters */
;;;480      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;481      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;482    
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Enable dual addressing mode */
;;;486        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L11.22|
                  |L11.12|
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable dual addressing mode */
;;;491        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L11.22|
;;;492      }
;;;493    }
000016  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;872    *******************************************************************************/
;;;873    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;874    {
;;;875      /* Check the parameters */
;;;876      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;877      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;878    
;;;879      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000004  d005              BEQ      |L12.18|
;;;880      {
;;;881        /* I2C fast mode Tlow/Thigh=2 */
;;;882        I2Cx->CCR &= I2C_DutyCycle_2;
000006  8b82              LDRH     r2,[r0,#0x1c]
000008  f64b73ff          MOV      r3,#0xbfff
00000c  401a              ANDS     r2,r2,r3
00000e  8382              STRH     r2,[r0,#0x1c]
000010  e003              B        |L12.26|
                  |L12.18|
;;;883      }
;;;884      else
;;;885      {
;;;886        /* I2C fast mode Tlow/Thigh=16/9 */
;;;887        I2Cx->CCR |= I2C_DutyCycle_16_9;
000012  8b82              LDRH     r2,[r0,#0x1c]
000014  f4424280          ORR      r2,r2,#0x4000
000018  8382              STRH     r2,[r0,#0x1c]
                  |L12.26|
;;;888      }
;;;889    }
00001a  4770              BX       lr
;;;890    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;503    *******************************************************************************/
;;;504    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;505    {
;;;506      /* Check the parameters */
;;;507      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;508      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;509    
;;;510      if (NewState != DISABLE)
;;;511      {
;;;512        /* Enable generall call */
;;;513        I2Cx->CR1 |= CR1_ENGC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420240          ORR      r2,r2,#0x40
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;514      }
;;;515      else
;;;516      {
;;;517        /* Disable generall call */
;;;518        I2Cx->CR1 &= CR1_ENGC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73bf          MOV      r3,#0xffbf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L13.22|
;;;519      }
;;;520    }
000016  4770              BX       lr
;;;521    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;370    *******************************************************************************/
;;;371    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L14.12|
;;;372    {
;;;373      /* Check the parameters */
;;;374      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;375      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;376    
;;;377      if (NewState != DISABLE)
;;;378      {
;;;379        /* Generate a START condition */
;;;380        I2Cx->CR1 |= CR1_START_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427280          ORR      r2,r2,#0x100
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L14.22|
                  |L14.12|
;;;381      }
;;;382      else
;;;383      {
;;;384        /* Disable the START condition generation */
;;;385        I2Cx->CR1 &= CR1_START_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f63ff          MOV      r3,#0xfeff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L14.22|
;;;386      }
;;;387    }
000016  4770              BX       lr
;;;388    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;397    *******************************************************************************/
;;;398    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L15.12|
;;;399    {
;;;400      /* Check the parameters */
;;;401      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;402      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;403    
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Generate a STOP condition */
;;;407        I2Cx->CR1 |= CR1_STOP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427200          ORR      r2,r2,#0x200
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L15.22|
                  |L15.12|
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the STOP condition generation */
;;;412        I2Cx->CR1 &= CR1_STOP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f53ff          MOV      r3,#0xfdff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L15.22|
;;;413      }
;;;414    }
000016  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1004   *******************************************************************************/
;;;1005   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1006   {
000002  4602              MOV      r2,r0
;;;1007     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1008     u32 i2cstatus = 0;
000006  2400              MOVS     r4,#0
;;;1009     u32 flag1 = 0, flag2 = 0;
000008  2500              MOVS     r5,#0
00000a  2300              MOVS     r3,#0
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1013     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1014   
;;;1015     /* Read the I2Cx status register */
;;;1016     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1017     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1018     flag2 = (flag2 & FLAG_Mask) << 16;
000010  041b              LSLS     r3,r3,#16
;;;1019   
;;;1020     /* Get the I2C status value */
;;;1021     i2cstatus = flag1 | flag2;
000012  ea450403          ORR      r4,r5,r3
;;;1022   
;;;1023     /* Get bit[23:0] of the flag */
;;;1024     I2C_FLAG &= FLAG_Mask;
000016  f021417f          BIC      r1,r1,#0xff000000
;;;1025   
;;;1026     /* Check the status of the specified I2C flag */
;;;1027     if ((i2cstatus & I2C_FLAG) != (u32)RESET)
00001a  ea040601          AND      r6,r4,r1
00001e  b10e              CBZ      r6,|L16.36|
;;;1028     {
;;;1029       /* I2C_FLAG is set */
;;;1030       bitstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L16.38|
                  |L16.36|
;;;1031     }
;;;1032     else
;;;1033     {
;;;1034       /* I2C_FLAG is reset */
;;;1035       bitstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L16.38|
;;;1036     }
;;;1037     /* Return the I2C_FLAG status */
;;;1038     return  bitstatus;
;;;1039   }
000026  bd70              POP      {r4-r6,pc}
;;;1040   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1133   *******************************************************************************/
;;;1134   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1135   {
000002  4602              MOV      r2,r0
;;;1136     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1137     u32 i2cstatus = 0;
000006  2400              MOVS     r4,#0
;;;1138     u32 flag1 = 0, flag2 = 0;
000008  2500              MOVS     r5,#0
00000a  2300              MOVS     r3,#0
;;;1139   
;;;1140     /* Check the parameters */
;;;1141     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1142     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1143   
;;;1144     /* Read the I2Cx status register */
;;;1145     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1146     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1147     flag2 = (flag2 & FLAG_Mask) << 16;
000010  041b              LSLS     r3,r3,#16
;;;1148   
;;;1149     /* Get the I2C status value */
;;;1150     i2cstatus = flag1 | flag2;
000012  ea450403          ORR      r4,r5,r3
;;;1151   
;;;1152     /* Get bit[23:0] of the flag */
;;;1153     I2C_IT &= FLAG_Mask;
000016  f021417f          BIC      r1,r1,#0xff000000
;;;1154   
;;;1155     /* Check the status of the specified I2C flag */
;;;1156     if ((i2cstatus & I2C_IT) != (u32)RESET)
00001a  ea040601          AND      r6,r4,r1
00001e  b10e              CBZ      r6,|L17.36|
;;;1157     {
;;;1158       /* I2C_IT is set */
;;;1159       bitstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L17.38|
                  |L17.36|
;;;1160     }
;;;1161     else
;;;1162     {
;;;1163       /* I2C_IT is reset */
;;;1164       bitstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L17.38|
;;;1165     }
;;;1166     /* Return the I2C_IT status */
;;;1167     return  bitstatus;
;;;1168   }
000026  bd70              POP      {r4-r6,pc}
;;;1169   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;897    *******************************************************************************/
;;;898    u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;899    {
000002  4601              MOV      r1,r0
;;;900      u32 lastevent = 0;
000004  2000              MOVS     r0,#0
;;;901      u32 flag1 = 0, flag2 = 0;
000006  2300              MOVS     r3,#0
000008  2200              MOVS     r2,#0
;;;902    
;;;903      /* Check the parameters */
;;;904      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;905    
;;;906      /* Read the I2Cx status register */
;;;907      flag1 = I2Cx->SR1;
00000a  8a8b              LDRH     r3,[r1,#0x14]
;;;908      flag2 = I2Cx->SR2;
00000c  8b0a              LDRH     r2,[r1,#0x18]
;;;909      flag2 = flag2 << 16;
00000e  0412              LSLS     r2,r2,#16
;;;910    
;;;911      /* Get the last event value from I2C status register */
;;;912      lastevent = (flag1 | flag2) & FLAG_Mask;
000010  ea430402          ORR      r4,r3,r2
000014  f024407f          BIC      r0,r4,#0xff000000
;;;913    
;;;914      /* Return status */
;;;915      return lastevent;
;;;916    }
000018  bd10              POP      {r4,pc}
;;;917    
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;798    *******************************************************************************/
;;;799    u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;803    
;;;804      /* Return the selected I2C PEC value */
;;;805      return ((I2Cx->SR2) >> 8);
000002  8b08              LDRH     r0,[r1,#0x18]
000004  1200              ASRS     r0,r0,#8
;;;806    }
000006  4770              BX       lr
;;;807    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;536    *******************************************************************************/
;;;537    void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;538    {
;;;539      /* Check the parameters */
;;;540      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;541      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;542      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;543      
;;;544      if (NewState != DISABLE)
;;;545      {
;;;546        /* Enable the selected I2C interrupts */
;;;547        I2Cx->CR2 |= I2C_IT;
000002  8883              LDRH     r3,[r0,#4]
000004  430b              ORRS     r3,r3,r1
000006  8083              STRH     r3,[r0,#4]
000008  e002              B        |L20.16|
                  |L20.10|
;;;548      }
;;;549      else
;;;550      {
;;;551        /* Disable the selected I2C interrupts */
;;;552        I2Cx->CR2 &= (u16)~I2C_IT;
00000a  8883              LDRH     r3,[r0,#4]
00000c  438b              BICS     r3,r3,r1
00000e  8083              STRH     r3,[r0,#4]
                  |L20.16|
;;;553      }
;;;554    }
000010  4770              BX       lr
;;;555    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;147    ******************************************************************************/
;;;148    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;149    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;150      u16 tmpreg = 0, freqrange = 0;
00000a  2600              MOVS     r6,#0
00000c  46b1              MOV      r9,r6
;;;151      u16 result = 0x04;
00000e  2704              MOVS     r7,#4
;;;152      u32 pclk1 = 8000000;
000010  f8df80cc          LDR      r8,|L21.224|
;;;153      RCC_ClocksTypeDef  rcc_clocks;
;;;154    
;;;155      /* Check the parameters */
;;;156      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;157      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;158      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;159      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;160      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;161      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;162      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;163    
;;;164    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;165      /* Get the I2Cx CR2 value */
;;;166      tmpreg = I2Cx->CR2;
000014  88a6              LDRH     r6,[r4,#4]
;;;167      /* Clear frequency FREQ[5:0] bits */
;;;168      tmpreg &= CR2_FREQ_Reset;
000016  f64f70c0          MOV      r0,#0xffc0
00001a  4006              ANDS     r6,r6,r0
;;;169      /* Get pclk1 frequency value */
;;;170      RCC_GetClocksFreq(&rcc_clocks);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       RCC_GetClocksFreq
;;;171      pclk1 = rcc_clocks.PCLK1_Frequency;
000022  f8dd8008          LDR      r8,[sp,#8]
;;;172      /* Set frequency bits depending on pclk1 value */
;;;173      freqrange = (u16)(pclk1 / 1000000);
000026  482f              LDR      r0,|L21.228|
000028  fbb8f0f0          UDIV     r0,r8,r0
00002c  fa1ff980          UXTH     r9,r0
;;;174      tmpreg |= freqrange;
000030  ea460609          ORR      r6,r6,r9
;;;175      /* Write to I2Cx CR2 */
;;;176      I2Cx->CR2 = tmpreg;
000034  80a6              STRH     r6,[r4,#4]
;;;177    
;;;178    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;179      /* Disable the selected I2C peripheral to configure TRISE */
;;;180      I2Cx->CR1 &= CR1_PE_Reset;
000036  8820              LDRH     r0,[r4,#0]
000038  f64f71fe          MOV      r1,#0xfffe
00003c  4008              ANDS     r0,r0,r1
00003e  8020              STRH     r0,[r4,#0]
;;;181    
;;;182      /* Reset tmpreg value */
;;;183      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;184      tmpreg = 0;
000040  2600              MOVS     r6,#0
;;;185    
;;;186      /* Configure speed in standard mode */
;;;187      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000042  4929              LDR      r1,|L21.232|
000044  68e8              LDR      r0,[r5,#0xc]
000046  4288              CMP      r0,r1
000048  d80c              BHI      |L21.100|
;;;188      {
;;;189        /* Standard mode speed calculate */
;;;190        result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
00004a  68e8              LDR      r0,[r5,#0xc]
00004c  0040              LSLS     r0,r0,#1
00004e  fbb8f0f0          UDIV     r0,r8,r0
000052  b287              UXTH     r7,r0
;;;191        /* Test if CCR value is under 0x4*/
;;;192        if (result < 0x04)
000054  2f04              CMP      r7,#4
000056  da00              BGE      |L21.90|
;;;193        {
;;;194          /* Set minimum allowed value */
;;;195          result = 0x04;  
000058  2704              MOVS     r7,#4
                  |L21.90|
;;;196        }
;;;197        /* Set speed value for standard mode */
;;;198        tmpreg |= result;	  
00005a  433e              ORRS     r6,r6,r7
;;;199        /* Set Maximum Rise Time for standard mode */
;;;200        I2Cx->TRISE = freqrange + 1; 
00005c  f1090001          ADD      r0,r9,#1
000060  8420              STRH     r0,[r4,#0x20]
000062  e027              B        |L21.180|
                  |L21.100|
;;;201      }
;;;202      /* Configure speed in fast mode */
;;;203      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;204      {
;;;205        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000064  8868              LDRH     r0,[r5,#2]
000066  f64b71ff          MOV      r1,#0xbfff
00006a  4288              CMP      r0,r1
00006c  d106              BNE      |L21.124|
;;;206        {
;;;207          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;208          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00006e  68e8              LDR      r0,[r5,#0xc]
000070  eb000040          ADD      r0,r0,r0,LSL #1
000074  fbb8f0f0          UDIV     r0,r8,r0
000078  b287              UXTH     r7,r0
00007a  e009              B        |L21.144|
                  |L21.124|
;;;209        }
;;;210        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;211        {
;;;212          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;213          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00007c  68e8              LDR      r0,[r5,#0xc]
00007e  eb0001c0          ADD      r1,r0,r0,LSL #3
000082  eb011000          ADD      r0,r1,r0,LSL #4
000086  fbb8f0f0          UDIV     r0,r8,r0
00008a  b287              UXTH     r7,r0
;;;214          /* Set DUTY bit */
;;;215          result |= I2C_DutyCycle_16_9;
00008c  f4474780          ORR      r7,r7,#0x4000
                  |L21.144|
;;;216        }
;;;217        /* Test if CCR value is under 0x1*/
;;;218        if ((result & CCR_CCR_Set) == 0)
000090  f3c7000b          UBFX     r0,r7,#0,#12
000094  b908              CBNZ     r0,|L21.154|
;;;219        {
;;;220          /* Set minimum allowed value */
;;;221          result |= (u16)0x0001;  
000096  f0470701          ORR      r7,r7,#1
                  |L21.154|
;;;222        }
;;;223        /* Set speed value and set F/S bit for fast mode */
;;;224        tmpreg |= result | CCR_FS_Set;
00009a  f4474000          ORR      r0,r7,#0x8000
00009e  4306              ORRS     r6,r6,r0
;;;225        /* Set Maximum Rise Time for fast mode */
;;;226        I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
0000a0  f44f7096          MOV      r0,#0x12c
0000a4  fb09f000          MUL      r0,r9,r0
0000a8  f44f717a          MOV      r1,#0x3e8
0000ac  fb90f0f1          SDIV     r0,r0,r1
0000b0  1c40              ADDS     r0,r0,#1
0000b2  8420              STRH     r0,[r4,#0x20]
                  |L21.180|
;;;227      }
;;;228      /* Write to I2Cx CCR */
;;;229      I2Cx->CCR = tmpreg;
0000b4  83a6              STRH     r6,[r4,#0x1c]
;;;230    
;;;231      /* Enable the selected I2C peripheral */
;;;232      I2Cx->CR1 |= CR1_PE_Set;
0000b6  8820              LDRH     r0,[r4,#0]
0000b8  f0400001          ORR      r0,r0,#1
0000bc  8020              STRH     r0,[r4,#0]
;;;233    
;;;234    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;235      /* Get the I2Cx CR1 value */
;;;236      tmpreg = I2Cx->CR1;
0000be  8826              LDRH     r6,[r4,#0]
;;;237      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;238      tmpreg &= CR1_CLEAR_Mask;
0000c0  f64f30f5          MOV      r0,#0xfbf5
0000c4  4006              ANDS     r6,r6,r0
;;;239      /* Configure I2Cx: mode and acknowledgement */
;;;240      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;241      /* Set ACK bit according to I2C_Ack value */
;;;242      tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000c6  8828              LDRH     r0,[r5,#0]
0000c8  88e9              LDRH     r1,[r5,#6]
0000ca  4308              ORRS     r0,r0,r1
0000cc  4306              ORRS     r6,r6,r0
;;;243      /* Write to I2Cx CR1 */
;;;244      I2Cx->CR1 = tmpreg;
0000ce  8026              STRH     r6,[r4,#0]
;;;245    
;;;246    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;247      /* Set I2Cx Own Address1 and acknowledged address */
;;;248      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000d0  8928              LDRH     r0,[r5,#8]
0000d2  88a9              LDRH     r1,[r5,#4]
0000d4  4308              ORRS     r0,r0,r1
0000d6  8120              STRH     r0,[r4,#8]
;;;249    }
0000d8  b005              ADD      sp,sp,#0x14
0000da  e8bd83f0          POP      {r4-r9,pc}
;;;250    
                          ENDP

0000de  0000              DCW      0x0000
                  |L21.224|
                          DCD      0x007a1200
                  |L21.228|
                          DCD      0x000f4240
                  |L21.232|
                          DCD      0x000186a0

                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;450    *******************************************************************************/
;;;451    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
000000  460a              MOV      r2,r1
;;;452    {
;;;453      u16 tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;454    
;;;455      /* Check the parameters */
;;;456      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;457    
;;;458      /* Get the old register value */
;;;459      tmpreg = I2Cx->OAR2;
000004  8981              LDRH     r1,[r0,#0xc]
;;;460      /* Reset I2Cx Own address2 bit [7:1] */
;;;461      tmpreg &= OAR2_ADD2_Reset;
000006  f64f7301          MOV      r3,#0xff01
00000a  4019              ANDS     r1,r1,r3
;;;462      /* Set I2Cx Own address2 */
;;;463      tmpreg |= (u16)(Address & (u16)0x00FE);
00000c  f00203fe          AND      r3,r2,#0xfe
000010  4319              ORRS     r1,r1,r3
;;;464      /* Store the new register value */
;;;465      I2Cx->OAR2 = tmpreg;
000012  8181              STRH     r1,[r0,#0xc]
;;;466    }
000014  4770              BX       lr
;;;467    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;745    *******************************************************************************/
;;;746    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;747    {
;;;748      /* Check the parameters */
;;;749      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;750      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;751    
;;;752      if (I2C_PECPosition == I2C_PECPosition_Next)
000004  d104              BNE      |L23.16|
;;;753      {
;;;754        /* Next byte in shift register is PEC */
;;;755        I2Cx->CR1 |= I2C_PECPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L23.26|
                  |L23.16|
;;;756      }
;;;757      else
;;;758      {
;;;759        /* Current byte in shift register is PEC */
;;;760        I2Cx->CR1 &= I2C_PECPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L23.26|
;;;761      }
;;;762    }
00001a  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;639    *******************************************************************************/
;;;640    u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
000000  4602              MOV      r2,r0
;;;641    {
;;;642      /* Check the parameters */
;;;643      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;644      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;645    
;;;646      /* Return the selected register value */
;;;647      return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
000002  5a50              LDRH     r0,[r2,r1]
;;;648    }
000004  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;579    *******************************************************************************/
;;;580    u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;581    {
;;;582      /* Check the parameters */
;;;583      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;584    
;;;585      /* Return the data in the DR register */
;;;586      return (u8)I2Cx->DR;
000002  8a08              LDRH     r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;587    }
000006  4770              BX       lr
;;;588    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;687    *******************************************************************************/
;;;688    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;689    {
;;;690      /* Check the parameters */
;;;691      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;692      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;693    
;;;694      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000004  d104              BNE      |L26.16|
;;;695      {
;;;696        /* Drive the SMBusAlert pin Low */
;;;697        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000006  8802              LDRH     r2,[r0,#0]
000008  f4425200          ORR      r2,r2,#0x2000
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L26.26|
                  |L26.16|
;;;698      }
;;;699      else
;;;700      {
;;;701        /* Drive the SMBusAlert pin High  */
;;;702        I2Cx->CR1 &= I2C_SMBusAlert_High;
000010  8802              LDRH     r2,[r0,#0]
000012  f64d73ff          MOV      r3,#0xdfff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L26.26|
;;;703      }
;;;704    }
00001a  4770              BX       lr
;;;705    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;601    *******************************************************************************/
;;;602    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
000000  b112              CBZ      r2,|L27.8|
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;606      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;607    
;;;608      /* Test on the direction to set/reset the read/write bit */
;;;609      if (I2C_Direction != I2C_Direction_Transmitter)
;;;610      {
;;;611        /* Set the address bit0 for read */
;;;612        Address |= OAR1_ADD0_Set;
000002  f0410101          ORR      r1,r1,#1
000006  e002              B        |L27.14|
                  |L27.8|
;;;613      }
;;;614      else
;;;615      {
;;;616        /* Reset the address bit0 for write */
;;;617        Address &= OAR1_ADD0_Reset;
000008  f64f73fe          MOV      r3,#0xfffe
00000c  4019              ANDS     r1,r1,r3
                  |L27.14|
;;;618      }
;;;619      /* Send the address */
;;;620      I2Cx->DR = Address;
00000e  8201              STRH     r1,[r0,#0x10]
;;;621    }
000010  4770              BX       lr
;;;622    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;563    *******************************************************************************/
;;;564    void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;565    {
;;;566      /* Check the parameters */
;;;567      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;568    
;;;569      /* Write in the DR register the data to be sent */
;;;570      I2Cx->DR = Data;
;;;571    }
000002  4770              BX       lr
;;;572    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;658    *******************************************************************************/
;;;659    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L29.12|
;;;660    {
;;;661      /* Check the parameters */
;;;662      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;663      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;664    
;;;665      if (NewState != DISABLE)
;;;666      {
;;;667        /* Peripheral under reset */
;;;668        I2Cx->CR1 |= CR1_SWRST_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4424200          ORR      r2,r2,#0x8000
000008  8002              STRH     r2,[r0,#0]
00000a  e003              B        |L29.20|
                  |L29.12|
;;;669      }
;;;670      else
;;;671      {
;;;672        /* Peripheral not under reset */
;;;673        I2Cx->CR1 &= CR1_SWRST_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  8002              STRH     r2,[r0,#0]
                  |L29.20|
;;;674      }
;;;675    }
000014  4770              BX       lr
;;;676    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;843    *******************************************************************************/
;;;844    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b921              CBNZ     r1,|L30.12|
;;;845    {
;;;846      /* Check the parameters */
;;;847      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;848      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;849    
;;;850      if (NewState == DISABLE)
;;;851      {
;;;852        /* Enable the selected I2C Clock stretching */
;;;853        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L30.22|
                  |L30.12|
;;;854      }
;;;855      else
;;;856      {
;;;857        /* Disable the selected I2C Clock stretching */
;;;858        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L30.22|
;;;859      }
;;;860    }
000016  4770              BX       lr
;;;861    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;258    *******************************************************************************/
;;;259    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  2100              MOVS     r1,#0
;;;260    {
;;;261    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;262      /* Initialize the I2C_Mode member */
;;;263      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000002  8001              STRH     r1,[r0,#0]
;;;264    
;;;265      /* Initialize the I2C_DutyCycle member */
;;;266      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000004  f64b71ff          MOV      r1,#0xbfff
000008  8041              STRH     r1,[r0,#2]
;;;267    
;;;268      /* Initialize the I2C_OwnAddress1 member */
;;;269      I2C_InitStruct->I2C_OwnAddress1 = 0;
00000a  2100              MOVS     r1,#0
00000c  8081              STRH     r1,[r0,#4]
;;;270    
;;;271      /* Initialize the I2C_Ack member */
;;;272      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00000e  80c1              STRH     r1,[r0,#6]
;;;273    
;;;274      /* Initialize the I2C_AcknowledgedAddress member */
;;;275      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000010  f44f4180          MOV      r1,#0x4000
000014  8101              STRH     r1,[r0,#8]
;;;276    
;;;277      /* initialize the I2C_ClockSpeed member */
;;;278      I2C_InitStruct->I2C_ClockSpeed = 5000;
000016  f2413188          MOV      r1,#0x1388
00001a  60c1              STR      r1,[r0,#0xc]
;;;279    }
00001c  4770              BX       lr
;;;280    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;714    *******************************************************************************/
;;;715    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L32.12|
;;;716    {
;;;717      /* Check the parameters */
;;;718      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;719      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;720    
;;;721      if (NewState != DISABLE)
;;;722      {
;;;723        /* Enable the selected I2C PEC transmission */
;;;724        I2Cx->CR1 |= CR1_PEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L32.22|
                  |L32.12|
;;;725      }
;;;726      else
;;;727      {
;;;728        /* Disable the selected I2C PEC transmission */
;;;729        I2Cx->CR1 &= CR1_PEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L32.22|
;;;730      }
;;;731    }
000016  4770              BX       lr
;;;732    
                          ENDP

