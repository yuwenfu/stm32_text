; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_rcc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\lib\inc -I.\User -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 -DVECT_TAB_RAM --omf_browse=.\output\stm32f10x_rcc.crf lib\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;556    *******************************************************************************/
;;;557    void RCC_ADCCLKConfig(u32 RCC_PCLK2)
000000  4601              MOV      r1,r0
;;;558    {
;;;559      u32 tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;560    
;;;561      /* Check the parameters */
;;;562      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;563    
;;;564      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L1.20|
000006  6850              LDR      r0,[r2,#4]
;;;565    
;;;566      /* Clear ADCPRE[1:0] bits */
;;;567      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000008  f4204040          BIC      r0,r0,#0xc000
;;;568    
;;;569      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;570      tmpreg |= RCC_PCLK2;
00000c  4308              ORRS     r0,r0,r1
;;;571    
;;;572      /* Store the new value */
;;;573      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;574    }
000010  4770              BX       lr
;;;575    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;789    *******************************************************************************/
;;;790    void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;791    {
;;;792      /* Check the parameters */
;;;793      assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;794      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;795    
;;;796      if (NewState != DISABLE)
;;;797      {
;;;798        RCC->AHBENR |= RCC_AHBPeriph;
000002  4a06              LDR      r2,|L2.28|
000004  6952              LDR      r2,[r2,#0x14]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L2.28|
00000a  615a              STR      r2,[r3,#0x14]
00000c  e004              B        |L2.24|
                  |L2.14|
;;;799      }
;;;800      else
;;;801      {
;;;802        RCC->AHBENR &= ~RCC_AHBPeriph;
00000e  4a03              LDR      r2,|L2.28|
000010  6952              LDR      r2,[r2,#0x14]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L2.28|
000016  615a              STR      r2,[r3,#0x14]
                  |L2.24|
;;;803      }
;;;804    }
000018  4770              BX       lr
;;;805    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;858    *******************************************************************************/
;;;859    void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;860    {
;;;861      /* Check the parameters */
;;;862      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;863      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;864    
;;;865      if (NewState != DISABLE)
;;;866      {
;;;867        RCC->APB1ENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L3.28|
000004  69d2              LDR      r2,[r2,#0x1c]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L3.28|
00000a  61da              STR      r2,[r3,#0x1c]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;868      }
;;;869      else
;;;870      {
;;;871        RCC->APB1ENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L3.28|
000010  69d2              LDR      r2,[r2,#0x1c]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L3.28|
000016  61da              STR      r2,[r3,#0x1c]
                  |L3.24|
;;;872      }
;;;873    }
000018  4770              BX       lr
;;;874    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;925    *******************************************************************************/
;;;926    void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;927    {
;;;928      /* Check the parameters */
;;;929      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;930      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;931    
;;;932      if (NewState != DISABLE)
;;;933      {
;;;934        RCC->APB1RSTR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L4.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;935      }
;;;936      else
;;;937      {
;;;938        RCC->APB1RSTR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L4.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L4.24|
;;;939      }
;;;940    }
000018  4770              BX       lr
;;;941    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;823    *******************************************************************************/
;;;824    void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L5.14|
;;;825    {
;;;826      /* Check the parameters */
;;;827      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;828      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;829    
;;;830      if (NewState != DISABLE)
;;;831      {
;;;832        RCC->APB2ENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L5.28|
000004  6992              LDR      r2,[r2,#0x18]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L5.28|
00000a  619a              STR      r2,[r3,#0x18]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;833      }
;;;834      else
;;;835      {
;;;836        RCC->APB2ENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L5.28|
000010  6992              LDR      r2,[r2,#0x18]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L5.28|
000016  619a              STR      r2,[r3,#0x18]
                  |L5.24|
;;;837      }
;;;838    }
000018  4770              BX       lr
;;;839    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;891    *******************************************************************************/
;;;892    void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L6.14|
;;;893    {
;;;894      /* Check the parameters */
;;;895      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;896      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;897    
;;;898      if (NewState != DISABLE)
;;;899      {
;;;900        RCC->APB2RSTR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L6.28|
000004  68d2              LDR      r2,[r2,#0xc]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L6.28|
00000a  60da              STR      r2,[r3,#0xc]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;901      }
;;;902      else
;;;903      {
;;;904        RCC->APB2RSTR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L6.28|
000010  68d2              LDR      r2,[r2,#0xc]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L6.28|
000016  60da              STR      r2,[r3,#0xc]
                  |L6.24|
;;;905      }
;;;906    }
000018  4770              BX       lr
;;;907    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;237    *******************************************************************************/
;;;238    void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
000000  4601              MOV      r1,r0
;;;239    {
;;;240      u32 tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;241    
;;;242      /* Check the parameters */
;;;243      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;244    
;;;245      tmpreg = RCC->CR;
000004  4a03              LDR      r2,|L7.20|
000006  6810              LDR      r0,[r2,#0]
;;;246    
;;;247      /* Clear HSITRIM[4:0] bits */
;;;248      tmpreg &= CR_HSITRIM_Mask;
000008  f02000f8          BIC      r0,r0,#0xf8
;;;249    
;;;250      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;251      tmpreg |= (u32)HSICalibrationValue << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;252    
;;;253      /* Store the new value */
;;;254      RCC->CR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;255    }
000012  4770              BX       lr
;;;256    
                          ENDP

                  |L7.20|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;950    *******************************************************************************/
;;;951    void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;952    {
;;;953      /* Check the parameters */
;;;954      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;955    
;;;956      *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;957    }
000004  4770              BX       lr
;;;958    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1070   *******************************************************************************/
;;;1071   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L9.16|
;;;1072   {
;;;1073     /* Set RMVF bit to clear the reset flags */
;;;1074     RCC->CSR |= CSR_RMVF_Set;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L9.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;1075   }
00000c  4770              BX       lr
;;;1076   
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1127   *******************************************************************************/
;;;1128   void RCC_ClearITPendingBit(u8 RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;1129   {
;;;1130     /* Check the parameters */
;;;1131     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1132   
;;;1133     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1134        pending bits */
;;;1135     *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1136   }
000004  4770              BX       lr
;;;1137   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;967    *******************************************************************************/
;;;968    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;969    {
;;;970      /* Check the parameters */
;;;971      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;972    
;;;973      *(vu32 *) CR_CSSON_BB = (u32)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;974    }
000004  4770              BX       lr
;;;975    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;127    *******************************************************************************/
;;;128    void RCC_DeInit(void)
000000  480f              LDR      r0,|L12.64|
;;;129    {
;;;130      /* Set HSION bit */
;;;131      RCC->CR |= (u32)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  490d              LDR      r1,|L12.64|
00000a  6008              STR      r0,[r1,#0]
;;;132    
;;;133      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;134      RCC->CFGR &= (u32)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  490c              LDR      r1,|L12.68|
000012  4008              ANDS     r0,r0,r1
000014  490a              LDR      r1,|L12.64|
000016  6048              STR      r0,[r1,#4]
;;;135      
;;;136      /* Reset HSEON, CSSON and PLLON bits */
;;;137      RCC->CR &= (u32)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  490a              LDR      r1,|L12.72|
00001e  4008              ANDS     r0,r0,r1
000020  4907              LDR      r1,|L12.64|
000022  6008              STR      r0,[r1,#0]
;;;138    
;;;139      /* Reset HSEBYP bit */
;;;140      RCC->CR &= (u32)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;141    
;;;142      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;143      RCC->CFGR &= (u32)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;144    
;;;145      /* Disable all interrupts */
;;;146      RCC->CIR = 0x00000000;
000038  2000              MOVS     r0,#0
00003a  6088              STR      r0,[r1,#8]
;;;147    }
00003c  4770              BX       lr
;;;148    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0xf8ff0000
                  |L12.72|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;688    *******************************************************************************/
;;;689    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b530              PUSH     {r4,r5,lr}
;;;690    {
;;;691      u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2400              MOVS     r4,#0
000008  2300              MOVS     r3,#0
;;;692    
;;;693      /* Get SYSCLK source -------------------------------------------------------*/
;;;694      tmp = RCC->CFGR & CFGR_SWS_Mask;
00000a  4d2d              LDR      r5,|L13.192|
00000c  686d              LDR      r5,[r5,#4]
00000e  f005010c          AND      r1,r5,#0xc
;;;695    
;;;696      switch (tmp)
000012  b121              CBZ      r1,|L13.30|
000014  2904              CMP      r1,#4
000016  d005              BEQ      |L13.36|
000018  2908              CMP      r1,#8
00001a  d123              BNE      |L13.100|
00001c  e005              B        |L13.42|
                  |L13.30|
;;;697      {
;;;698        case 0x00:  /* HSI used as system clock */
;;;699          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
00001e  4d29              LDR      r5,|L13.196|
000020  6005              STR      r5,[r0,#0]
;;;700          break;
000022  e022              B        |L13.106|
                  |L13.36|
;;;701    
;;;702        case 0x04:  /* HSE used as system clock */
;;;703          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
000024  4d27              LDR      r5,|L13.196|
000026  6005              STR      r5,[r0,#0]
;;;704          break;
000028  e01f              B        |L13.106|
                  |L13.42|
;;;705    
;;;706        case 0x08:  /* PLL used as system clock */
;;;707          /* Get PLL clock source and multiplication factor ----------------------*/
;;;708          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00002a  4d25              LDR      r5,|L13.192|
00002c  686d              LDR      r5,[r5,#4]
00002e  f4051270          AND      r2,r5,#0x3c0000
;;;709          pllmull = ( pllmull >> 18) + 2;
000032  2502              MOVS     r5,#2
000034  eb054292          ADD      r2,r5,r2,LSR #18
;;;710    
;;;711          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
000038  4d21              LDR      r5,|L13.192|
00003a  686d              LDR      r5,[r5,#4]
00003c  f4053480          AND      r4,r5,#0x10000
;;;712    
;;;713          if (pllsource == 0x00)
000040  b91c              CBNZ     r4,|L13.74|
;;;714          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;715            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
000042  4d21              LDR      r5,|L13.200|
000044  4355              MULS     r5,r2,r5
000046  6005              STR      r5,[r0,#0]
000048  e00b              B        |L13.98|
                  |L13.74|
;;;716          }
;;;717          else
;;;718          {/* HSE selected as PLL clock entry */
;;;719    
;;;720            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
00004a  4d1d              LDR      r5,|L13.192|
00004c  686d              LDR      r5,[r5,#4]
00004e  f4053500          AND      r5,r5,#0x20000
000052  b11d              CBZ      r5,|L13.92|
;;;721            {/* HSE oscillator clock divided by 2 */
;;;722    
;;;723              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
000054  4d1c              LDR      r5,|L13.200|
000056  4355              MULS     r5,r2,r5
000058  6005              STR      r5,[r0,#0]
00005a  e002              B        |L13.98|
                  |L13.92|
;;;724            }
;;;725            else
;;;726            {
;;;727              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
00005c  4d19              LDR      r5,|L13.196|
00005e  4355              MULS     r5,r2,r5
000060  6005              STR      r5,[r0,#0]
                  |L13.98|
;;;728            }
;;;729          }
;;;730          break;
000062  e002              B        |L13.106|
                  |L13.100|
;;;731    
;;;732        default:
;;;733          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
000064  4d17              LDR      r5,|L13.196|
000066  6005              STR      r5,[r0,#0]
;;;734          break;
000068  bf00              NOP      
                  |L13.106|
00006a  bf00              NOP                            ;700
;;;735      }
;;;736    
;;;737      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;738      /* Get HCLK prescaler */
;;;739      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
00006c  4d14              LDR      r5,|L13.192|
00006e  686d              LDR      r5,[r5,#4]
000070  f00501f0          AND      r1,r5,#0xf0
;;;740      tmp = tmp >> 4;
000074  0909              LSRS     r1,r1,#4
;;;741      presc = APBAHBPrescTable[tmp];
000076  4d15              LDR      r5,|L13.204|
000078  5c6b              LDRB     r3,[r5,r1]
;;;742    
;;;743      /* HCLK clock frequency */
;;;744      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00007a  6805              LDR      r5,[r0,#0]
00007c  40dd              LSRS     r5,r5,r3
00007e  6045              STR      r5,[r0,#4]
;;;745    
;;;746      /* Get PCLK1 prescaler */
;;;747      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000080  4d0f              LDR      r5,|L13.192|
000082  686d              LDR      r5,[r5,#4]
000084  f40561e0          AND      r1,r5,#0x700
;;;748      tmp = tmp >> 8;
000088  0a09              LSRS     r1,r1,#8
;;;749      presc = APBAHBPrescTable[tmp];
00008a  4d10              LDR      r5,|L13.204|
00008c  5c6b              LDRB     r3,[r5,r1]
;;;750    
;;;751      /* PCLK1 clock frequency */
;;;752      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00008e  6845              LDR      r5,[r0,#4]
000090  40dd              LSRS     r5,r5,r3
000092  6085              STR      r5,[r0,#8]
;;;753    
;;;754      /* Get PCLK2 prescaler */
;;;755      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000094  4d0a              LDR      r5,|L13.192|
000096  686d              LDR      r5,[r5,#4]
000098  f4055160          AND      r1,r5,#0x3800
;;;756      tmp = tmp >> 11;
00009c  0ac9              LSRS     r1,r1,#11
;;;757      presc = APBAHBPrescTable[tmp];
00009e  4d0b              LDR      r5,|L13.204|
0000a0  5c6b              LDRB     r3,[r5,r1]
;;;758    
;;;759      /* PCLK2 clock frequency */
;;;760      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000a2  6845              LDR      r5,[r0,#4]
0000a4  40dd              LSRS     r5,r5,r3
0000a6  60c5              STR      r5,[r0,#0xc]
;;;761    
;;;762      /* Get ADCCLK prescaler */
;;;763      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
0000a8  4d05              LDR      r5,|L13.192|
0000aa  686d              LDR      r5,[r5,#4]
0000ac  f4054140          AND      r1,r5,#0xc000
;;;764      tmp = tmp >> 14;
0000b0  0b89              LSRS     r1,r1,#14
;;;765      presc = ADCPrescTable[tmp];
0000b2  4d07              LDR      r5,|L13.208|
0000b4  5c6b              LDRB     r3,[r5,r1]
;;;766    
;;;767      /* ADCCLK clock frequency */
;;;768      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
0000b6  68c5              LDR      r5,[r0,#0xc]
0000b8  fbb5f5f3          UDIV     r5,r5,r3
0000bc  6105              STR      r5,[r0,#0x10]
;;;769    }
0000be  bd30              POP      {r4,r5,pc}
;;;770    
                          ENDP

                  |L13.192|
                          DCD      0x40021000
                  |L13.196|
                          DCD      0x007a1200
                  |L13.200|
                          DCD      0x003d0900
                  |L13.204|
                          DCD      APBAHBPrescTable
                  |L13.208|
                          DCD      ADCPrescTable

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1018   *******************************************************************************/
;;;1019   FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1020   {
000002  4601              MOV      r1,r0
;;;1021     u32 tmp = 0;
000004  2200              MOVS     r2,#0
;;;1022     u32 statusreg = 0;
000006  2300              MOVS     r3,#0
;;;1023     FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;1024   
;;;1025     /* Check the parameters */
;;;1026     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1027   
;;;1028     /* Get the RCC register index */
;;;1029     tmp = RCC_FLAG >> 5;
00000a  114a              ASRS     r2,r1,#5
;;;1030   
;;;1031     if (tmp == 1)               /* The flag to check is in CR register */
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L14.22|
;;;1032     {
;;;1033       statusreg = RCC->CR;
000010  4c09              LDR      r4,|L14.56|
000012  6823              LDR      r3,[r4,#0]
000014  e006              B        |L14.36|
                  |L14.22|
;;;1034     }
;;;1035     else if (tmp == 2)          /* The flag to check is in BDCR register */
000016  2a02              CMP      r2,#2
000018  d102              BNE      |L14.32|
;;;1036     {
;;;1037       statusreg = RCC->BDCR;
00001a  4c07              LDR      r4,|L14.56|
00001c  6a23              LDR      r3,[r4,#0x20]
00001e  e001              B        |L14.36|
                  |L14.32|
;;;1038     }
;;;1039     else                       /* The flag to check is in CSR register */
;;;1040     {
;;;1041       statusreg = RCC->CSR;
000020  4c05              LDR      r4,|L14.56|
000022  6a63              LDR      r3,[r4,#0x24]
                  |L14.36|
;;;1042     }
;;;1043   
;;;1044     /* Get the flag position */
;;;1045     tmp = RCC_FLAG & FLAG_Mask;
000024  f001021f          AND      r2,r1,#0x1f
;;;1046   
;;;1047     if ((statusreg & ((u32)1 << tmp)) != (u32)RESET)
000028  2401              MOVS     r4,#1
00002a  4094              LSLS     r4,r4,r2
00002c  401c              ANDS     r4,r4,r3
00002e  b10c              CBZ      r4,|L14.52|
;;;1048     {
;;;1049       bitstatus = SET;
000030  2001              MOVS     r0,#1
000032  e000              B        |L14.54|
                  |L14.52|
;;;1050     }
;;;1051     else
;;;1052     {
;;;1053       bitstatus = RESET;
000034  2000              MOVS     r0,#0
                  |L14.54|
;;;1054     }
;;;1055   
;;;1056     /* Return the flag status */
;;;1057     return bitstatus;
;;;1058   }
000036  bd10              POP      {r4,pc}
;;;1059   
                          ENDP

                  |L14.56|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1091   *******************************************************************************/
;;;1092   ITStatus RCC_GetITStatus(u8 RCC_IT)
000000  4601              MOV      r1,r0
;;;1093   {
;;;1094     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1095   
;;;1096     /* Check the parameters */
;;;1097     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1098   
;;;1099     /* Check the status of the specified RCC interrupt */
;;;1100     if ((RCC->CIR & RCC_IT) != (u32)RESET)
000004  4a03              LDR      r2,|L15.20|
000006  6892              LDR      r2,[r2,#8]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L15.16|
;;;1101     {
;;;1102       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L15.18|
                  |L15.16|
;;;1103     }
;;;1104     else
;;;1105     {
;;;1106       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L15.18|
;;;1107     }
;;;1108   
;;;1109     /* Return the RCC_IT status */
;;;1110     return  bitstatus;
;;;1111   }
000012  4770              BX       lr
;;;1112   
                          ENDP

                  |L15.20|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;374    *******************************************************************************/
;;;375    u8 RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;376    {
;;;377      return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;378    }
000008  4770              BX       lr
;;;379    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;398    *******************************************************************************/
;;;399    void RCC_HCLKConfig(u32 RCC_SYSCLK)
000000  4601              MOV      r1,r0
;;;400    {
;;;401      u32 tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;402    
;;;403      /* Check the parameters */
;;;404      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;405    
;;;406      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L17.20|
000006  6850              LDR      r0,[r2,#4]
;;;407    
;;;408      /* Clear HPRE[3:0] bits */
;;;409      tmpreg &= CFGR_HPRE_Reset_Mask;
000008  f02000f0          BIC      r0,r0,#0xf0
;;;410    
;;;411      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;412      tmpreg |= RCC_SYSCLK;
00000c  4308              ORRS     r0,r0,r1
;;;413    
;;;414      /* Store the new value */
;;;415      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;416    }
000010  4770              BX       lr
;;;417    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;163    *******************************************************************************/
;;;164    void RCC_HSEConfig(u32 RCC_HSE)
000000  4911              LDR      r1,|L18.72|
;;;165    {
;;;166      /* Check the parameters */
;;;167      assert_param(IS_RCC_HSE(RCC_HSE));
;;;168    
;;;169      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;170      /* Reset HSEON bit */
;;;171      RCC->CR &= CR_HSEON_Reset;
000002  6809              LDR      r1,[r1,#0]
000004  f4213180          BIC      r1,r1,#0x10000
000008  4a0f              LDR      r2,|L18.72|
00000a  6011              STR      r1,[r2,#0]
;;;172    
;;;173      /* Reset HSEBYP bit */
;;;174      RCC->CR &= CR_HSEBYP_Reset;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  f4212180          BIC      r1,r1,#0x40000
000014  6011              STR      r1,[r2,#0]
;;;175    
;;;176      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;177      switch(RCC_HSE)
000016  f5b03f80          CMP      r0,#0x10000
00001a  d003              BEQ      |L18.36|
00001c  f5b02f80          CMP      r0,#0x40000
000020  d10e              BNE      |L18.64|
000022  e006              B        |L18.50|
                  |L18.36|
;;;178      {
;;;179        case RCC_HSE_ON:
;;;180          /* Set HSEON bit */
;;;181          RCC->CR |= CR_HSEON_Set;
000024  4908              LDR      r1,|L18.72|
000026  6809              LDR      r1,[r1,#0]
000028  f4413180          ORR      r1,r1,#0x10000
00002c  4a06              LDR      r2,|L18.72|
00002e  6011              STR      r1,[r2,#0]
;;;182          break;
000030  e007              B        |L18.66|
                  |L18.50|
;;;183          
;;;184        case RCC_HSE_Bypass:
;;;185          /* Set HSEBYP and HSEON bits */
;;;186          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000032  4905              LDR      r1,|L18.72|
000034  6809              LDR      r1,[r1,#0]
000036  f44121a0          ORR      r1,r1,#0x50000
00003a  4a03              LDR      r2,|L18.72|
00003c  6011              STR      r1,[r2,#0]
;;;187          break;            
00003e  e000              B        |L18.66|
                  |L18.64|
;;;188          
;;;189        default:
;;;190          break;      
000040  bf00              NOP      
                  |L18.66|
000042  bf00              NOP                            ;182
;;;191      }
;;;192    }
000044  4770              BX       lr
;;;193    
                          ENDP

000046  0000              DCW      0x0000
                  |L18.72|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;267    *******************************************************************************/
;;;268    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;269    {
;;;270      /* Check the parameters */
;;;271      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;272    
;;;273      *(vu32 *) CR_HSION_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;274    }
000004  4770              BX       lr
;;;275    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;502    *******************************************************************************/
;;;503    void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L20.14|
;;;504    {
;;;505      /* Check the parameters */
;;;506      assert_param(IS_RCC_IT(RCC_IT));
;;;507      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;508    
;;;509      if (NewState != DISABLE)
;;;510      {
;;;511        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;512        *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
000002  4a06              LDR      r2,|L20.28|
000004  7a52              LDRB     r2,[r2,#9]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L20.28|
00000a  725a              STRB     r2,[r3,#9]
00000c  e004              B        |L20.24|
                  |L20.14|
;;;513      }
;;;514      else
;;;515      {
;;;516        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;517        *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
00000e  4a03              LDR      r2,|L20.28|
000010  7a52              LDRB     r2,[r2,#9]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L20.28|
000016  725a              STRB     r2,[r3,#9]
                  |L20.24|
;;;518      }
;;;519    }
000018  4770              BX       lr
;;;520    
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;588    *******************************************************************************/
;;;589    void RCC_LSEConfig(u8 RCC_LSE)
000000  2100              MOVS     r1,#0
;;;590    {
;;;591      /* Check the parameters */
;;;592      assert_param(IS_RCC_LSE(RCC_LSE));
;;;593    
;;;594      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;595      /* Reset LSEON bit */
;;;596      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  4a0b              LDR      r2,|L21.48|
000004  7011              STRB     r1,[r2,#0]
;;;597    
;;;598      /* Reset LSEBYP bit */
;;;599      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  4a0a              LDR      r2,|L21.48|
000008  3a20              SUBS     r2,r2,#0x20
00000a  f8821020          STRB     r1,[r2,#0x20]
;;;600    
;;;601      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;602      switch(RCC_LSE)
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L21.24|
000012  2804              CMP      r0,#4
000014  d108              BNE      |L21.40|
000016  e003              B        |L21.32|
                  |L21.24|
;;;603      {
;;;604        case RCC_LSE_ON:
;;;605          /* Set LSEON bit */
;;;606          *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
000018  2101              MOVS     r1,#1
00001a  4a05              LDR      r2,|L21.48|
00001c  7011              STRB     r1,[r2,#0]
;;;607          break;
00001e  e004              B        |L21.42|
                  |L21.32|
;;;608          
;;;609        case RCC_LSE_Bypass:
;;;610          /* Set LSEBYP and LSEON bits */
;;;611          *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000020  2105              MOVS     r1,#5
000022  4a03              LDR      r2,|L21.48|
000024  7011              STRB     r1,[r2,#0]
;;;612          break;            
000026  e000              B        |L21.42|
                  |L21.40|
;;;613          
;;;614        default:
;;;615          break;      
000028  bf00              NOP      
                  |L21.42|
00002a  bf00              NOP                            ;607
;;;616      }
;;;617    }
00002c  4770              BX       lr
;;;618    
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      0x40021020

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;628    *******************************************************************************/
;;;629    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;630    {
;;;631      /* Check the parameters */
;;;632      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;633    
;;;634      *(vu32 *) CSR_LSION_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;635    }
000004  4770              BX       lr
;;;636    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;989    *******************************************************************************/
;;;990    void RCC_MCOConfig(u8 RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;991    {
;;;992      /* Check the parameters */
;;;993      assert_param(IS_RCC_MCO(RCC_MCO));
;;;994    
;;;995      /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;996      *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;997    }
000004  4770              BX       lr
;;;998    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;432    *******************************************************************************/
;;;433    void RCC_PCLK1Config(u32 RCC_HCLK)
000000  4601              MOV      r1,r0
;;;434    {
;;;435      u32 tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;436    
;;;437      /* Check the parameters */
;;;438      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;439    
;;;440      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L24.20|
000006  6850              LDR      r0,[r2,#4]
;;;441    
;;;442      /* Clear PPRE1[2:0] bits */
;;;443      tmpreg &= CFGR_PPRE1_Reset_Mask;
000008  f42060e0          BIC      r0,r0,#0x700
;;;444    
;;;445      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;446      tmpreg |= RCC_HCLK;
00000c  4308              ORRS     r0,r0,r1
;;;447    
;;;448      /* Store the new value */
;;;449      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;450    }
000010  4770              BX       lr
;;;451    
                          ENDP

000012  0000              DCW      0x0000
                  |L24.20|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;466    *******************************************************************************/
;;;467    void RCC_PCLK2Config(u32 RCC_HCLK)
000000  4601              MOV      r1,r0
;;;468    {
;;;469      u32 tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;470    
;;;471      /* Check the parameters */
;;;472      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;473    
;;;474      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L25.20|
000006  6850              LDR      r0,[r2,#4]
;;;475    
;;;476      /* Clear PPRE2[2:0] bits */
;;;477      tmpreg &= CFGR_PPRE2_Reset_Mask;
000008  f4205060          BIC      r0,r0,#0x3800
;;;478    
;;;479      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;480      tmpreg |= RCC_HCLK << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;481    
;;;482      /* Store the new value */
;;;483      RCC->CFGR = tmpreg;
000010  6050              STR      r0,[r2,#4]
;;;484    }
000012  4770              BX       lr
;;;485    
                          ENDP

                  |L25.20|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;323    *******************************************************************************/
;;;324    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;328    
;;;329      *(vu32 *) CR_PLLON_BB = (u32)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;330    }
000004  4770              BX       lr
;;;331    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;293    *******************************************************************************/
;;;294    void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
000000  4602              MOV      r2,r0
;;;295    {
;;;296      u32 tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;297    
;;;298      /* Check the parameters */
;;;299      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;300      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;301    
;;;302      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L27.24|
000006  6858              LDR      r0,[r3,#4]
;;;303    
;;;304      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;305      tmpreg &= CFGR_PLL_Mask;
000008  f420107c          BIC      r0,r0,#0x3f0000
;;;306    
;;;307      /* Set the PLL configuration bits */
;;;308      tmpreg |= RCC_PLLSource | RCC_PLLMul;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;309    
;;;310      /* Store the new value */
;;;311      RCC->CFGR = tmpreg;
000012  4b01              LDR      r3,|L27.24|
000014  6058              STR      r0,[r3,#4]
;;;312    }
000016  4770              BX       lr
;;;313    
                          ENDP

                  |L27.24|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;671    *******************************************************************************/
;;;672    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;673    {
;;;674      /* Check the parameters */
;;;675      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;676    
;;;677      *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
000002  6008              STR      r0,[r1,#0]
;;;678    }
000004  4770              BX       lr
;;;679    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;651    *******************************************************************************/
;;;652    void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;653    {
;;;654      /* Check the parameters */
;;;655      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;656    
;;;657      /* Select the RTC clock source */
;;;658      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a09              LDR      r1,[r1,#0x20]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L29.12|
000008  6211              STR      r1,[r2,#0x20]
;;;659    }
00000a  4770              BX       lr
;;;660    
                          ENDP

                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;343    *******************************************************************************/
;;;344    void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
000000  4601              MOV      r1,r0
;;;345    {
;;;346      u32 tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;347    
;;;348      /* Check the parameters */
;;;349      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;350    
;;;351      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L30.20|
000006  6850              LDR      r0,[r2,#4]
;;;352    
;;;353      /* Clear SW[1:0] bits */
;;;354      tmpreg &= CFGR_SW_Mask;
000008  f0200003          BIC      r0,r0,#3
;;;355    
;;;356      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;357      tmpreg |= RCC_SYSCLKSource;
00000c  4308              ORRS     r0,r0,r1
;;;358    
;;;359      /* Store the new value */
;;;360      RCC->CFGR = tmpreg;
00000e  6050              STR      r0,[r2,#4]
;;;361    }
000010  4770              BX       lr
;;;362    
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;534    *******************************************************************************/
;;;535    void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;539    
;;;540      *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;541    }
000004  4770              BX       lr
;;;542    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      0x424200d8

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=2

                  RCC_WaitForHSEStartUp PROC
;;;203    *******************************************************************************/
;;;204    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206      ErrorStatus status = ERROR;
000002  2400              MOVS     r4,#0
;;;207    
;;;208      /* Wait till HSE is ready and if Time out is reached exit */
;;;209      do
000004  bf00              NOP      
                  |L32.6|
;;;210      {
;;;211        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
000006  2031              MOVS     r0,#0x31
000008  f7fffffe          BL       RCC_GetFlagStatus
00000c  490c              LDR      r1,|L32.64|
00000e  7008              STRB     r0,[r1,#0]
;;;212        StartUpCounter++;  
000010  480c              LDR      r0,|L32.68|
000012  6800              LDR      r0,[r0,#0]  ; StartUpCounter
000014  1c40              ADDS     r0,r0,#1
000016  490b              LDR      r1,|L32.68|
000018  6008              STR      r0,[r1,#0]  ; StartUpCounter
;;;213      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
00001a  4809              LDR      r0,|L32.64|
00001c  7800              LDRB     r0,[r0,#0]  ; HSEStatus
00001e  b928              CBNZ     r0,|L32.44|
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]  ; StartUpCounter
000024  f24011ff          MOV      r1,#0x1ff
000028  4288              CMP      r0,r1
00002a  d1ec              BNE      |L32.6|
                  |L32.44|
;;;214    
;;;215    
;;;216      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00002c  2031              MOVS     r0,#0x31
00002e  f7fffffe          BL       RCC_GetFlagStatus
000032  b108              CBZ      r0,|L32.56|
;;;217      {
;;;218        status = SUCCESS;
000034  2401              MOVS     r4,#1
000036  e000              B        |L32.58|
                  |L32.56|
;;;219      }
;;;220      else
;;;221      {
;;;222        status = ERROR;
000038  2400              MOVS     r4,#0
                  |L32.58|
;;;223      }  
;;;224    
;;;225      return (status);
00003a  4620              MOV      r0,r4
;;;226    }
00003c  bd10              POP      {r4,pc}
;;;227    
                          ENDP

00003e  0000              DCW      0x0000
                  |L32.64|
                          DCD      HSEStatus
                  |L32.68|
                          DCD      StartUpCounter

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08

                          AREA ||.data||, DATA, ALIGN=2

                  HSEStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  StartUpCounter
                          DCD      0x00000000
