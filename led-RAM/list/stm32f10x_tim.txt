; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_tim.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\lib\inc -I.\User -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 -DVECT_TAB_RAM --omf_browse=.\output\stm32f10x_tim.crf lib\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3144   *******************************************************************************/
;;;3145   static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3146                          u16 TIM_ICFilter)
;;;3147   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3148     u16 tmpccmr1 = 0, tmpccer = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;3149   
;;;3150     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3151     TIMx->CCER &= CCER_CC1E_Reset;
00000a  8c06              LDRH     r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;3152   
;;;3153     tmpccmr1 = TIMx->CCMR1;
000014  8b01              LDRH     r1,[r0,#0x18]
;;;3154     tmpccer = TIMx->CCER;
000016  8c02              LDRH     r2,[r0,#0x20]
;;;3155   
;;;3156     /* Select the Input and set the filter */
;;;3157     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000018  f64f760c          MOV      r6,#0xff0c
00001c  4031              ANDS     r1,r1,r6
;;;3158     tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
00001e  1c7e              ADDS     r6,r7,#1
000020  ea061603          AND      r6,r6,r3,LSL #4
000024  432e              ORRS     r6,r6,r5
000026  4331              ORRS     r1,r1,r6
;;;3159   
;;;3160     /* Select the Polarity and set the CC1E Bit */
;;;3161     tmpccer &= CCER_CC1P_Reset;
000028  1e7e              SUBS     r6,r7,#1
00002a  4032              ANDS     r2,r2,r6
;;;3162     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
00002c  f0440601          ORR      r6,r4,#1
000030  4332              ORRS     r2,r2,r6
;;;3163   
;;;3164     /* Write to TIMx CCMR1 and CCER registers */
;;;3165     TIMx->CCMR1 = tmpccmr1;
000032  8301              STRH     r1,[r0,#0x18]
;;;3166     TIMx->CCER = tmpccer;
000034  8402              STRH     r2,[r0,#0x20]
;;;3167   }
000036  bdf0              POP      {r4-r7,pc}
;;;3168   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3191   *******************************************************************************/
;;;3192   static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3193                          u16 TIM_ICFilter)
;;;3194   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3195     u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3196   
;;;3197     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3198     TIMx->CCER &= CCER_CC2E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3199   
;;;3200     tmpccmr1 = TIMx->CCMR1;
000018  8b01              LDRH     r1,[r0,#0x18]
;;;3201     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3202     tmp = (u16)(TIM_ICPolarity << 4);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea071604          AND      r6,r7,r4,LSL #4
;;;3203   
;;;3204     /* Select the Input and set the filter */
;;;3205     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3206     tmpccmr1 |= (u16)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea073703          AND      r7,r7,r3,LSL #12
000032  4339              ORRS     r1,r1,r7
;;;3207     tmpccmr1 |= (u16)(TIM_ICSelection << 8);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea072705          AND      r7,r7,r5,LSL #8
00003c  4339              ORRS     r1,r1,r7
;;;3208   
;;;3209     /* Select the Polarity and set the CC2E Bit */
;;;3210     tmpccer &= CCER_CC2P_Reset;
00003e  f64f77df          MOV      r7,#0xffdf
000042  403a              ANDS     r2,r2,r7
;;;3211     tmpccer |=  tmp | CCER_CC2E_Set;
000044  f0460710          ORR      r7,r6,#0x10
000048  433a              ORRS     r2,r2,r7
;;;3212   
;;;3213     /* Write to TIMx CCMR1 and CCER registers */
;;;3214     TIMx->CCMR1 = tmpccmr1 ;
00004a  8301              STRH     r1,[r0,#0x18]
;;;3215     TIMx->CCER = tmpccer;
00004c  8402              STRH     r2,[r0,#0x20]
;;;3216   }
00004e  bdf0              POP      {r4-r7,pc}
;;;3217   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;3240   *******************************************************************************/
;;;3241   static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3242                          u16 TIM_ICFilter)
;;;3243   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3244     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3245   
;;;3246     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3247     TIMx->CCER &= CCER_CC3E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3248   
;;;3249     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3250     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3251     tmp = (u16)(TIM_ICPolarity << 8);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea072604          AND      r6,r7,r4,LSL #8
;;;3252   
;;;3253     /* Select the Input and set the filter */
;;;3254     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000024  f64f770c          MOV      r7,#0xff0c
000028  4039              ANDS     r1,r1,r7
;;;3255     tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea071703          AND      r7,r7,r3,LSL #4
000032  432f              ORRS     r7,r7,r5
000034  4339              ORRS     r1,r1,r7
;;;3256   
;;;3257     /* Select the Polarity and set the CC3E Bit */
;;;3258     tmpccer &= CCER_CC3P_Reset;
000036  f64f57ff          MOV      r7,#0xfdff
00003a  403a              ANDS     r2,r2,r7
;;;3259     tmpccer |= tmp | CCER_CC3E_Set;
00003c  f4467780          ORR      r7,r6,#0x100
000040  433a              ORRS     r2,r2,r7
;;;3260   
;;;3261     /* Write to TIMx CCMR2 and CCER registers */
;;;3262     TIMx->CCMR2 = tmpccmr2;
000042  8381              STRH     r1,[r0,#0x1c]
;;;3263     TIMx->CCER = tmpccer;
000044  8402              STRH     r2,[r0,#0x20]
;;;3264   }
000046  bdf0              POP      {r4-r7,pc}
;;;3265   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;3288   *******************************************************************************/
;;;3289   static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3290                          u16 TIM_ICFilter)
;;;3291   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3292     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3293   
;;;3294     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3295     TIMx->CCER &= CCER_CC4E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3296   
;;;3297     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3298     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3299     tmp = (u16)(TIM_ICPolarity << 12);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea073604          AND      r6,r7,r4,LSL #12
;;;3300   
;;;3301     /* Select the Input and set the filter */
;;;3302     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3303     tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea072705          AND      r7,r7,r5,LSL #8
000032  f64f7cff          MOV      r12,#0xffff
000036  ea0c3c03          AND      r12,r12,r3,LSL #12
00003a  ea47070c          ORR      r7,r7,r12
00003e  4339              ORRS     r1,r1,r7
;;;3304   
;;;3305     /* Select the Polarity and set the CC4E Bit */
;;;3306     tmpccer &= CCER_CC4P_Reset;
000040  f64d77ff          MOV      r7,#0xdfff
000044  403a              ANDS     r2,r2,r7
;;;3307     tmpccer |= tmp | CCER_CC4E_Set;
000046  f4465780          ORR      r7,r6,#0x1000
00004a  433a              ORRS     r2,r2,r7
;;;3308   
;;;3309     /* Write to TIMx CCMR2 and CCER registers */
;;;3310     TIMx->CCMR2 = tmpccmr2;
00004c  8381              STRH     r1,[r0,#0x1c]
;;;3311     TIMx->CCER = tmpccer ;
00004e  8402              STRH     r2,[r0,#0x20]
;;;3312   }
000050  bdf0              POP      {r4-r7,pc}
;;;3313   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1573   *******************************************************************************/
;;;1574   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;1575   {
;;;1576     /* Check the parameters */
;;;1577     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1578     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1579   
;;;1580     if (NewState != DISABLE)
;;;1581     {
;;;1582       /* Set the ARR Preload Bit */
;;;1583       TIMx->CR1 |= CR1_ARPE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;1584     }
;;;1585     else
;;;1586     {
;;;1587       /* Reset the ARR Preload Bit */
;;;1588       TIMx->CR1 &= CR1_ARPE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f240337f          MOV      r3,#0x37f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;1589     }
;;;1590   }
000016  4770              BX       lr
;;;1591   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;731    *******************************************************************************/
;;;732    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;733    {
;;;734      /* Check the parameters */
;;;735      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;736      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;737      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;738      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;739      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;740      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;741      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;742    
;;;743      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;744         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;745    
;;;746      TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02052          STRH     r2,[r0,#0x52]
;;;747                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;748                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;749                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;750    
;;;751    }
00001e  4770              BX       lr
;;;752    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;821    *******************************************************************************/
;;;822    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;823    {
;;;824      /* Set the default configuration */
;;;825      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;826      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;827      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;828      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;829      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;830      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;831      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;832    }
000010  4770              BX       lr
;;;833    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1659   *******************************************************************************/
;;;1660   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;1661   { 
;;;1662     /* Check the parameters */
;;;1663     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1664     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1665   
;;;1666     if (NewState != DISABLE)
;;;1667     {
;;;1668       /* Set the CCPC Bit */
;;;1669       TIMx->CR2 |= CR2_CCPC_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;1670     }
;;;1671     else
;;;1672     {
;;;1673       /* Reset the CCPC Bit */
;;;1674       TIMx->CR2 &= CR2_CCPC_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;1675     }
;;;1676   }
000016  4770              BX       lr
;;;1677   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;2312   *******************************************************************************/
;;;2313   void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;2314   {
;;;2315     /* Check the parameters */
;;;2316     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2317     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2318     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2319   
;;;2320     /* Reset the CCxE Bit */
;;;2321     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2322   
;;;2323     /* Set or reset the CCxE Bit */ 
;;;2324     TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  fa02f401          LSL      r4,r2,r1
000012  b2a4              UXTH     r4,r4
000014  4323              ORRS     r3,r3,r4
000016  8403              STRH     r3,[r0,#0x20]
;;;2325   }
000018  bd10              POP      {r4,pc}
;;;2326   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2341   *******************************************************************************/
;;;2342   void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;2343   {
;;;2344     /* Check the parameters */
;;;2345     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2346     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2347     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2348   
;;;2349     /* Reset the CCxNE Bit */
;;;2350     TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2351   
;;;2352     /* Set or reset the CCxNE Bit */ 
;;;2353     TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  fa02f401          LSL      r4,r2,r1
000012  b2a4              UXTH     r4,r4
000014  4323              ORRS     r3,r3,r4
000016  8403              STRH     r3,[r0,#0x20]
;;;2354   }
000018  bd10              POP      {r4,pc}
;;;2355   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;3037   *******************************************************************************/
;;;3038   void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;3039   {  
;;;3040     /* Check the parameters */
;;;3041     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3042     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;3043     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;3044      
;;;3045     /* Clear the flags */
;;;3046     TIMx->SR = (u16)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;3047   }
000004  4770              BX       lr
;;;3048   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;3111   *******************************************************************************/
;;;3112   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
000000  43ca              MVNS     r2,r1
;;;3113   {
;;;3114     /* Check the parameters */
;;;3115     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3116     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;3117   
;;;3118     /* Clear the IT pending Bit */
;;;3119     TIMx->SR = (u16)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;3120   }
000004  4770              BX       lr
;;;3121   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1962   *******************************************************************************/
;;;1963   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1964   {
;;;1965     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1966   
;;;1967     /* Check the parameters */
;;;1968     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1969     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1970   
;;;1971     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1972   
;;;1973     /* Reset the OC1CE Bit */
;;;1974     tmpccmr1 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1975   
;;;1976     /* Enable or Disable the Output Compare Clear Bit */
;;;1977     tmpccmr1 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1978   
;;;1979     /* Write to TIMx CCMR1 register */
;;;1980     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1981   }
000010  4770              BX       lr
;;;1982   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1995   *******************************************************************************/
;;;1996   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1997   {
;;;1998     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1999   
;;;2000     /* Check the parameters */
;;;2001     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2002     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;2003   
;;;2004     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;2005   
;;;2006     /* Reset the OC2CE Bit */
;;;2007     tmpccmr1 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;2008   
;;;2009     /* Enable or Disable the Output Compare Clear Bit */
;;;2010     tmpccmr1 |= (u16)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;2011   
;;;2012     /* Write to TIMx CCMR1 register */
;;;2013     TIMx->CCMR1 = tmpccmr1;
000014  8301              STRH     r1,[r0,#0x18]
;;;2014   }
000016  4770              BX       lr
;;;2015   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;2028   *******************************************************************************/
;;;2029   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;2030   {
;;;2031     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;2032   
;;;2033     /* Check the parameters */
;;;2034     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2035     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;2036   
;;;2037     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;2038   
;;;2039     /* Reset the OC3CE Bit */
;;;2040     tmpccmr2 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;2041   
;;;2042     /* Enable or Disable the Output Compare Clear Bit */
;;;2043     tmpccmr2 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;2044   
;;;2045     /* Write to TIMx CCMR2 register */
;;;2046     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;2047   }
000010  4770              BX       lr
;;;2048   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;2061   *******************************************************************************/
;;;2062   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;2063   {
;;;2064     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;2065   
;;;2066     /* Check the parameters */
;;;2067     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2068     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;2069   
;;;2070     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;2071   
;;;2072     /* Reset the OC4CE Bit */
;;;2073     tmpccmr2 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;2074   
;;;2075     /* Enable or Disable the Output Compare Clear Bit */
;;;2076     tmpccmr2 |= (u16)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;2077   
;;;2078     /* Write to TIMx CCMR2 register */
;;;2079     TIMx->CCMR2 = tmpccmr2;
000014  8381              STRH     r1,[r0,#0x1c]
;;;2080   }
000016  4770              BX       lr
;;;2081   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;843    *******************************************************************************/
;;;844    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;845    {
;;;846      /* Check the parameters */
;;;847      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;848      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;849      
;;;850      if (NewState != DISABLE)
;;;851      {
;;;852        /* Enable the TIM Counter */
;;;853        TIMx->CR1 |= CR1_CEN_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;854      }
;;;855      else
;;;856      {
;;;857        /* Disable the TIM Counter */
;;;858        TIMx->CR1 &= CR1_CEN_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fe          MOV      r3,#0x3fe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;859      }
;;;860    }
000016  4770              BX       lr
;;;861    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1294   *******************************************************************************/
;;;1295   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;1296   {
;;;1297     u16 tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;1298   
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1301     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1302   
;;;1303     tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;1304   
;;;1305     /* Reset the CMS and DIR Bits */
;;;1306     tmpcr1 &= CR1_CounterMode_Mask;
000006  f240338f          MOV      r3,#0x38f
00000a  4019              ANDS     r1,r1,r3
;;;1307   
;;;1308     /* Set the Counter Mode */
;;;1309     tmpcr1 |= TIM_CounterMode;
00000c  4311              ORRS     r1,r1,r2
;;;1310   
;;;1311     /* Write to TIMx CR1 register */
;;;1312     TIMx->CR1 = tmpcr1;
00000e  8001              STRH     r1,[r0,#0]
;;;1313   }
000010  4770              BX       lr
;;;1314   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;871    *******************************************************************************/
;;;872    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;873    {
;;;874      /* Check the parameters */
;;;875      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;876      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;877    
;;;878      if (NewState != DISABLE)
;;;879      {
;;;880        /* Enable the TIM Main Output */
;;;881        TIMx->BDTR |= BDTR_MOE_Set;
000002  f8b02052          LDRH     r2,[r0,#0x52]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02052          STRH     r2,[r0,#0x52]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;882      }
;;;883      else
;;;884      {
;;;885        /* Disable the TIM Main Output */
;;;886        TIMx->BDTR &= BDTR_MOE_Reset;
000010  f8b02052          LDRH     r2,[r0,#0x52]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02052          STRH     r2,[r0,#0x52]
                  |L19.28|
;;;887      }  
;;;888    }
00001c  4770              BX       lr
;;;889    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;1008   *******************************************************************************/
;;;1009   void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;1010   { 
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1013     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;1014     assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;1015     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1016     
;;;1017     if (NewState != DISABLE)
;;;1018     {
;;;1019       /* Enable the DMA sources */
;;;1020       TIMx->DIER |= TIM_DMASource; 
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L20.16|
                  |L20.10|
;;;1021     }
;;;1022     else
;;;1023     {
;;;1024       /* Disable the DMA sources */
;;;1025       TIMx->DIER &= (u16)~TIM_DMASource;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L20.16|
;;;1026     }
;;;1027   }
000010  4770              BX       lr
;;;1028   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;978    *******************************************************************************/
;;;979    void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;980    {
;;;981      /* Check the parameters */
;;;982      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;983      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;984      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;985    
;;;986      /* Set the DMA Base and the DMA Burst Length */
;;;987      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;988    }
000008  4770              BX       lr
;;;989    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;136    *******************************************************************************/
;;;137    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;138    {
000002  4604              MOV      r4,r0
;;;139      /* Check the parameters */
;;;140      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;141     
;;;142      switch (*(u32*)&TIMx)
000004  4934              LDR      r1,|L22.216|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d045              BEQ      |L22.152|
00000c  dc0c              BGT      |L22.40|
00000e  f1b44f80          CMP      r4,#0x40000000
000012  d01d              BEQ      |L22.80|
000014  4831              LDR      r0,|L22.220|
000016  4420              ADD      r0,r0,r4
000018  b318              CBZ      r0,|L22.98|
00001a  f5b06f80          CMP      r0,#0x400
00001e  d029              BEQ      |L22.116|
000020  f5b06f00          CMP      r0,#0x800
000024  d154              BNE      |L22.208|
000026  e02e              B        |L22.134|
                  |L22.40|
000028  f5b06f80          CMP      r0,#0x400
00002c  d03d              BEQ      |L22.170|
00002e  f5b03f8e          CMP      r0,#0x11c00
000032  d003              BEQ      |L22.60|
000034  f5b03f92          CMP      r0,#0x12400
000038  d14a              BNE      |L22.208|
00003a  e03f              B        |L22.188|
                  |L22.60|
;;;143      {
;;;144        case TIM1_BASE:
;;;145          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  02c8              LSLS     r0,r1,#11
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;146          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000044  2100              MOVS     r1,#0
000046  f44f6000          MOV      r0,#0x800
00004a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;147          break; 
00004e  e040              B        |L22.210|
                  |L22.80|
;;;148          
;;;149        case TIM2_BASE:
;;;150          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000050  2101              MOVS     r1,#1
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;151          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;152          break;
000060  e037              B        |L22.210|
                  |L22.98|
;;;153     
;;;154        case TIM3_BASE:
;;;155          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000062  2101              MOVS     r1,#1
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;156          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00006a  2100              MOVS     r1,#0
00006c  2002              MOVS     r0,#2
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;157          break;
000072  e02e              B        |L22.210|
                  |L22.116|
;;;158     
;;;159        case TIM4_BASE:
;;;160          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000074  2101              MOVS     r1,#1
000076  2004              MOVS     r0,#4
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;161          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00007c  2100              MOVS     r1,#0
00007e  2004              MOVS     r0,#4
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;162          break;
000084  e025              B        |L22.210|
                  |L22.134|
;;;163          
;;;164        case TIM5_BASE:
;;;165          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000086  2101              MOVS     r1,#1
000088  2008              MOVS     r0,#8
00008a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;166          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2008              MOVS     r0,#8
000092  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;167          break;
000096  e01c              B        |L22.210|
                  |L22.152|
;;;168          
;;;169        case TIM6_BASE:
;;;170          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000098  2101              MOVS     r1,#1
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;171          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
0000a0  2100              MOVS     r1,#0
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;172          break;
0000a8  e013              B        |L22.210|
                  |L22.170|
;;;173          
;;;174        case TIM7_BASE:
;;;175          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  2020              MOVS     r0,#0x20
0000ae  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;176          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000b2  2100              MOVS     r1,#0
0000b4  2020              MOVS     r0,#0x20
0000b6  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;177          break;
0000ba  e00a              B        |L22.210|
                  |L22.188|
;;;178          
;;;179        case TIM8_BASE:
;;;180          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  0348              LSLS     r0,r1,#13
0000c0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;181          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000c4  2100              MOVS     r1,#0
0000c6  f44f5000          MOV      r0,#0x2000
0000ca  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;182          break; 
0000ce  e000              B        |L22.210|
                  |L22.208|
;;;183          
;;;184        default:
;;;185          break;
0000d0  bf00              NOP      
                  |L22.210|
0000d2  bf00              NOP                            ;147
;;;186      }
;;;187    }
0000d4  bd10              POP      {r4,pc}
;;;188    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L22.216|
                          DCD      0x40001000
                  |L22.220|
                          DCD      0xbffffc00

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1139   *******************************************************************************/
;;;1140   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1141                                u16 ExtTRGFilter)
;;;1142   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1143     u16 tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;1144   
;;;1145     /* Check the parameters */
;;;1146     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1147     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1148     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1149     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1150   
;;;1151     /* Configure the ETR Clock source */
;;;1152     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;1153     
;;;1154     /* Get the TIMx SMCR register value */
;;;1155     tmpsmcr = TIMx->SMCR;
00001a  892c              LDRH     r4,[r5,#8]
;;;1156   
;;;1157     /* Reset the SMS Bits */
;;;1158     tmpsmcr &= SMCR_SMS_Mask;
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4004              ANDS     r4,r4,r0
;;;1159     /* Select the External clock mode1 */
;;;1160     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0440407          ORR      r4,r4,#7
;;;1161   
;;;1162     /* Select the Trigger selection : ETRF */
;;;1163     tmpsmcr &= SMCR_TS_Mask;
000026  f64f708f          MOV      r0,#0xff8f
00002a  4004              ANDS     r4,r4,r0
;;;1164     tmpsmcr |= TIM_TS_ETRF;
00002c  f0440470          ORR      r4,r4,#0x70
;;;1165   
;;;1166     /* Write to TIMx SMCR */
;;;1167     TIMx->SMCR = tmpsmcr;
000030  812c              STRH     r4,[r5,#8]
;;;1168   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1169   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1190   *******************************************************************************/
;;;1191   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;1192                                u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
;;;1193   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1194     /* Check the parameters */
;;;1195     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1196     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1197     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1198     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1199   
;;;1200     /* Configure the ETR Clock source */
;;;1201     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;1202   
;;;1203     /* Enable the External clock mode2 */
;;;1204     TIMx->SMCR |= SMCR_ECE_Set;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;1205   }
00001e  bdf0              POP      {r4-r7,pc}
;;;1206   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1227   *******************************************************************************/
;;;1228   void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
000000  b570              PUSH     {r4-r6,lr}
;;;1229                      u16 ExtTRGFilter)
;;;1230   {
000002  460c              MOV      r4,r1
;;;1231     u16 tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;1232   
;;;1233     /* Check the parameters */
;;;1234     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1235     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1236     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1237     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1238   
;;;1239     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;1240   
;;;1241     /* Reset the ETR Bits */
;;;1242     tmpsmcr &= SMCR_ETR_Mask;
000008  b2c9              UXTB     r1,r1
;;;1243   
;;;1244     /* Set the Prescaler, the Filter value and the Polarity */
;;;1245     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
00000a  ea440502          ORR      r5,r4,r2
00000e  f64f76ff          MOV      r6,#0xffff
000012  ea062603          AND      r6,r6,r3,LSL #8
000016  4335              ORRS     r5,r5,r6
000018  4329              ORRS     r1,r1,r5
;;;1246   
;;;1247     /* Write to TIMx SMCR */
;;;1248     TIMx->SMCR = tmpsmcr;
00001a  8101              STRH     r1,[r0,#8]
;;;1249   }
00001c  bd70              POP      {r4-r6,pc}
;;;1250   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1379   *******************************************************************************/
;;;1380   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1381                                   u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
;;;1382   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;1383     u16 tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;1384     u16 tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;1385     u16 tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;1386       
;;;1387     /* Check the parameters */
;;;1388     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1389     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1390     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1391     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1392   
;;;1393     /* Get the TIMx SMCR register value */
;;;1394     tmpsmcr = TIMx->SMCR;
00000e  8901              LDRH     r1,[r0,#8]
;;;1395   
;;;1396     /* Get the TIMx CCMR1 register value */
;;;1397     tmpccmr1 = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;1398   
;;;1399     /* Get the TIMx CCER register value */
;;;1400     tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;1401   
;;;1402     /* Set the encoder Mode */
;;;1403     tmpsmcr &= SMCR_SMS_Mask;
000014  f64f77f8          MOV      r7,#0xfff8
000018  4039              ANDS     r1,r1,r7
;;;1404     tmpsmcr |= TIM_EncoderMode;
00001a  4321              ORRS     r1,r1,r4
;;;1405   
;;;1406     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1407     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
00001c  f64f47fc          MOV      r7,#0xfcfc
000020  403a              ANDS     r2,r2,r7
;;;1408     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
000022  f2401701          MOV      r7,#0x101
000026  433a              ORRS     r2,r2,r7
;;;1409   
;;;1410     /* Set the TI1 and the TI2 Polarities */
;;;1411     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000028  f64f77dd          MOV      r7,#0xffdd
00002c  403b              ANDS     r3,r3,r7
;;;1412     tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071706          AND      r7,r7,r6,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  433b              ORRS     r3,r3,r7
;;;1413   
;;;1414     /* Write to TIMx SMCR */
;;;1415     TIMx->SMCR = tmpsmcr;
00003a  8101              STRH     r1,[r0,#8]
;;;1416   
;;;1417     /* Write to TIMx CCMR1 */
;;;1418     TIMx->CCMR1 = tmpccmr1;
00003c  8302              STRH     r2,[r0,#0x18]
;;;1419   
;;;1420     /* Write to TIMx CCER */
;;;1421     TIMx->CCER = tmpccer;
00003e  8403              STRH     r3,[r0,#0x20]
;;;1422   }
000040  bdf0              POP      {r4-r7,pc}
;;;1423   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1438   *******************************************************************************/
;;;1439   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1440   {
;;;1441     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1442   
;;;1443     /* Check the parameters */
;;;1444     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1445     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1446   
;;;1447     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1448   
;;;1449     /* Reset the OC1M Bits */
;;;1450     tmpccmr1 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1451   
;;;1452     /* Configure The Forced output Mode */
;;;1453     tmpccmr1 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1454   
;;;1455     /* Write to TIMx CCMR1 register */
;;;1456     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1457   }
000010  4770              BX       lr
;;;1458   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1473   *******************************************************************************/
;;;1474   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1475   {
;;;1476     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1477   
;;;1478     /* Check the parameters */
;;;1479     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1480     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1481   
;;;1482     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1483   
;;;1484     /* Reset the OC2M Bits */
;;;1485     tmpccmr1 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1486   
;;;1487     /* Configure The Forced output Mode */
;;;1488     tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1489   
;;;1490     /* Write to TIMx CCMR1 register */
;;;1491     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1492   }
000018  4770              BX       lr
;;;1493   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1508   *******************************************************************************/
;;;1509   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1510   {
;;;1511     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1512   
;;;1513     /* Check the parameters */
;;;1514     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1515     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1516   
;;;1517     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1518   
;;;1519     /* Reset the OC1M Bits */
;;;1520     tmpccmr2 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1521   
;;;1522     /* Configure The Forced output Mode */
;;;1523     tmpccmr2 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1524   
;;;1525     /* Write to TIMx CCMR2 register */
;;;1526     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1527   }
000010  4770              BX       lr
;;;1528   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1543   *******************************************************************************/
;;;1544   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1545   {
;;;1546     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1547   
;;;1548     /* Check the parameters */
;;;1549     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1550     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1551     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1552   
;;;1553     /* Reset the OC2M Bits */
;;;1554     tmpccmr2 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1555   
;;;1556     /* Configure The Forced output Mode */
;;;1557     tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1558   
;;;1559     /* Write to TIMx CCMR2 register */
;;;1560     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1561   }
000018  4770              BX       lr
;;;1562   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;946    *******************************************************************************/
;;;947    void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;948    { 
;;;949      /* Check the parameters */
;;;950      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;951      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;952      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;953    
;;;954      /* Set the event sources */
;;;955      TIMx->EGR = TIM_EventSource;
;;;956    }
000002  4770              BX       lr
;;;957    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2876   *******************************************************************************/
;;;2877   u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2878   {
;;;2879     /* Check the parameters */
;;;2880     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2881   
;;;2882     /* Get the Capture 1 Register value */
;;;2883     return TIMx->CCR1;
000002  8e88              LDRH     r0,[r1,#0x34]
;;;2884   }
000004  4770              BX       lr
;;;2885   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2894   *******************************************************************************/
;;;2895   u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2896   {
;;;2897     /* Check the parameters */
;;;2898     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2899   
;;;2900     /* Get the Capture 2 Register value */
;;;2901     return TIMx->CCR2;
000002  8f08              LDRH     r0,[r1,#0x38]
;;;2902   }
000004  4770              BX       lr
;;;2903   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2912   *******************************************************************************/
;;;2913   u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2914   {
;;;2915     /* Check the parameters */
;;;2916     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2917   
;;;2918     /* Get the Capture 3 Register value */
;;;2919     return TIMx->CCR3;
000002  8f88              LDRH     r0,[r1,#0x3c]
;;;2920   }
000004  4770              BX       lr
;;;2921   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2930   *******************************************************************************/
;;;2931   u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2932   {
;;;2933     /* Check the parameters */
;;;2934     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2935   
;;;2936     /* Get the Capture 4 Register value */
;;;2937     return TIMx->CCR4;
000002  f8b10040          LDRH     r0,[r1,#0x40]
;;;2938   }
000006  4770              BX       lr
;;;2939   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2947   *******************************************************************************/
;;;2948   u16 TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2949   {
;;;2950     /* Check the parameters */
;;;2951     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2952   
;;;2953     /* Get the Counter Register value */
;;;2954     return TIMx->CNT;
000002  8c88              LDRH     r0,[r1,#0x24]
;;;2955   }
000004  4770              BX       lr
;;;2956   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2995   *******************************************************************************/
;;;2996   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2997   { 
;;;2998     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2999   
;;;3000     /* Check the parameters */
;;;3001     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3002     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;3003     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;3004     
;;;3005     if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L37.14|
;;;3006     {
;;;3007       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;3008     }
;;;3009     else
;;;3010     {
;;;3011       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;3012     }
;;;3013     return bitstatus;
;;;3014   }
000010  4770              BX       lr
;;;3015   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;3067   *******************************************************************************/
;;;3068   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;3069   {
000002  4602              MOV      r2,r0
;;;3070     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;3071     u16 itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;3072   
;;;3073     /* Check the parameters */
;;;3074     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3075     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;3076     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;3077      
;;;3078     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;3079     
;;;3080     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;3081   
;;;3082     if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;3083     {
;;;3084       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;3085     }
;;;3086     else
;;;3087     {
;;;3088       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;3089     }
;;;3090     return bitstatus;
;;;3091   }
000020  bd30              POP      {r4,r5,pc}
;;;3092   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2964   *******************************************************************************/
;;;2965   u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2966   {
;;;2967     /* Check the parameters */
;;;2968     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2969   
;;;2970     /* Get the Prescaler Register value */
;;;2971     return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;2972   }
000004  4770              BX       lr
;;;2973   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;593    *******************************************************************************/
;;;594    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;595    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;596      /* Check the parameters */
;;;597      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;598      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;599      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;600      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;601      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;602      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;603      
;;;604      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;605      {
;;;606        /* TI1 Configuration */
;;;607        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  8923              LDRH     r3,[r4,#8]
00000c  88a2              LDRH     r2,[r4,#4]
00000e  8861              LDRH     r1,[r4,#2]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI1_Config
;;;608                   TIM_ICInitStruct->TIM_ICSelection,
;;;609                   TIM_ICInitStruct->TIM_ICFilter);
;;;610    
;;;611        /* Set the Input Capture Prescaler value */
;;;612        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e1              LDRH     r1,[r4,#6]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;613      }
;;;614      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8820              LDRH     r0,[r4,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;615      {
;;;616        /* TI2 Configuration */
;;;617        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI2_Config
;;;618                   TIM_ICInitStruct->TIM_ICSelection,
;;;619                   TIM_ICInitStruct->TIM_ICFilter);
;;;620    
;;;621        /* Set the Input Capture Prescaler value */
;;;622        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;623      }
;;;624      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8820              LDRH     r0,[r4,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;625      {
;;;626        /* TI3 Configuration */
;;;627        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  8923              LDRH     r3,[r4,#8]
000044  88a2              LDRH     r2,[r4,#4]
000046  8861              LDRH     r1,[r4,#2]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TI3_Config
;;;628                   TIM_ICInitStruct->TIM_ICSelection,
;;;629                   TIM_ICInitStruct->TIM_ICFilter);
;;;630    
;;;631        /* Set the Input Capture Prescaler value */
;;;632        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e1              LDRH     r1,[r4,#6]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;633      }
;;;634      else
;;;635      {
;;;636        /* TI4 Configuration */
;;;637        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  8923              LDRH     r3,[r4,#8]
00005a  88a2              LDRH     r2,[r4,#4]
00005c  8861              LDRH     r1,[r4,#2]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TI4_Config
;;;638                   TIM_ICInitStruct->TIM_ICSelection,
;;;639                   TIM_ICInitStruct->TIM_ICFilter);
;;;640    
;;;641        /* Set the Input Capture Prescaler value */
;;;642        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e1              LDRH     r1,[r4,#6]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;643      }
;;;644    }
00006c  bd70              POP      {r4-r6,pc}
;;;645    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;802    *******************************************************************************/
;;;803    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;804    {
;;;805      /* Set the default configuration */
;;;806      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;807      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;808      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;809      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;810      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;811    }
000010  4770              BX       lr
;;;812    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;910    *******************************************************************************/
;;;911    void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L42.10|
;;;912    {  
;;;913      /* Check the parameters */
;;;914      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;915      assert_param(IS_TIM_IT(TIM_IT));
;;;916      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;917      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;918      
;;;919      if (NewState != DISABLE)
;;;920      {
;;;921        /* Enable the Interrupt sources */
;;;922        TIMx->DIER |= TIM_IT;
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L42.16|
                  |L42.10|
;;;923      }
;;;924      else
;;;925      {
;;;926        /* Disable the Interrupt sources */
;;;927        TIMx->DIER &= (u16)~TIM_IT;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L42.16|
;;;928      }
;;;929    }
000010  4770              BX       lr
;;;930    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;1060   *******************************************************************************/
;;;1061   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1062   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1063     /* Check the parameters */
;;;1064     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1065     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1066   
;;;1067     /* Select the Internal Trigger */
;;;1068     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;1069   
;;;1070     /* Select the External clock mode1 */
;;;1071     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;1072   }
000016  bd30              POP      {r4,r5,pc}
;;;1073   /*******************************************************************************
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;1037   *******************************************************************************/
;;;1038   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;1039   {
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1042   
;;;1043     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;1044     TIMx->SMCR &=  SMCR_SMS_Mask;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;1045   }
00000a  4770              BX       lr
;;;1046   /*******************************************************************************
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1826   *******************************************************************************/
;;;1827   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1828   {
;;;1829     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1830   
;;;1831     /* Check the parameters */
;;;1832     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1833     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1834   
;;;1835     /* Get the TIMx CCMR1 register value */
;;;1836     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1837   
;;;1838     /* Reset the OC1FE Bit */
;;;1839     tmpccmr1 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1840   
;;;1841     /* Enable or Disable the Output Compare Fast Bit */
;;;1842     tmpccmr1 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1843   
;;;1844     /* Write to TIMx CCMR1 */
;;;1845     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1846   }
000010  4770              BX       lr
;;;1847   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;241    *******************************************************************************/
;;;242    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;245       
;;;246      /* Check the parameters */
;;;247      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;248      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;249      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;250      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;251    
;;;252      /* Disable the Channel 1: Reset the CC1E Bit */
;;;253      TIMx->CCER &= CCER_CC1E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;254      
;;;255      /* Get the TIMx CCER register value */
;;;256      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;257    
;;;258      /* Get the TIMx CR2 register value */
;;;259      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;260      
;;;261      /* Get the TIMx CCMR1 register value */
;;;262      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;263        
;;;264      /* Reset the Output Compare Mode Bits */
;;;265      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;266      
;;;267      /* Select the Output Compare Mode */
;;;268      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;269      
;;;270      /* Reset the Output Polarity level */
;;;271      tmpccer &= CCER_CC1P_Reset;
000022  1e75              SUBS     r5,r6,#1
000024  402a              ANDS     r2,r2,r5
;;;272    
;;;273      /* Set the Output Compare Polarity */
;;;274      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000026  890d              LDRH     r5,[r1,#8]
000028  432a              ORRS     r2,r2,r5
;;;275      
;;;276      /* Set the Output State */
;;;277      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002a  884d              LDRH     r5,[r1,#2]
00002c  432a              ORRS     r2,r2,r5
;;;278      
;;;279      /* Set the Capture Compare Register value */
;;;280      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00002e  88cd              LDRH     r5,[r1,#6]
000030  8685              STRH     r5,[r0,#0x34]
;;;281      
;;;282      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000032  4d0f              LDR      r5,|L46.112|
000034  42a8              CMP      r0,r5
000036  d002              BEQ      |L46.62|
000038  4d0e              LDR      r5,|L46.116|
00003a  42a8              CMP      r0,r5
00003c  d113              BNE      |L46.102|
                  |L46.62|
;;;283      {
;;;284        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;285        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;286        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;287        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;288        
;;;289        /* Reset the Output N Polarity level */
;;;290        tmpccer &= CCER_CC1NP_Reset;
00003e  f64f75f7          MOV      r5,#0xfff7
000042  402a              ANDS     r2,r2,r5
;;;291    
;;;292        /* Set the Output N Polarity */
;;;293        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000044  894d              LDRH     r5,[r1,#0xa]
000046  432a              ORRS     r2,r2,r5
;;;294    
;;;295        /* Reset the Output N State */
;;;296        tmpccer &= CCER_CC1NE_Reset;
000048  f64f75fb          MOV      r5,#0xfffb
00004c  402a              ANDS     r2,r2,r5
;;;297        
;;;298        /* Set the Output N State */
;;;299        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00004e  888d              LDRH     r5,[r1,#4]
000050  432a              ORRS     r2,r2,r5
;;;300    
;;;301        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;302        tmpcr2 &= CR2_OIS1_Reset;
000052  f64765ff          MOV      r5,#0x7eff
000056  402b              ANDS     r3,r3,r5
;;;303        tmpcr2 &= CR2_OIS1N_Reset;
000058  f64755ff          MOV      r5,#0x7dff
00005c  402b              ANDS     r3,r3,r5
;;;304    
;;;305        /* Set the Output Idle state */
;;;306        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005e  898d              LDRH     r5,[r1,#0xc]
000060  432b              ORRS     r3,r3,r5
;;;307    
;;;308        /* Set the Output N Idle state */
;;;309        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000062  89cd              LDRH     r5,[r1,#0xe]
000064  432b              ORRS     r3,r3,r5
                  |L46.102|
;;;310      }
;;;311      /* Write to TIMx CR2 */
;;;312      TIMx->CR2 = tmpcr2;
000066  8083              STRH     r3,[r0,#4]
;;;313      
;;;314      /* Write to TIMx CCMR1 */
;;;315      TIMx->CCMR1 = tmpccmrx;
000068  8304              STRH     r4,[r0,#0x18]
;;;316      
;;;317      /* Write to TIMx CCER */
;;;318      TIMx->CCER = tmpccer;
00006a  8402              STRH     r2,[r0,#0x20]
;;;319    }
00006c  bd70              POP      {r4-r6,pc}
;;;320    
                          ENDP

00006e  0000              DCW      0x0000
                  |L46.112|
                          DCD      0x40012c00
                  |L46.116|
                          DCD      0x40013400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;2124   *******************************************************************************/
;;;2125   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;2126   {
;;;2127     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2128   
;;;2129     /* Check the parameters */
;;;2130     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2131     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2132      
;;;2133     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2134   
;;;2135     /* Set or Reset the CC1NP Bit */
;;;2136     tmpccer &= CCER_CC1NP_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;2137     tmpccer |= TIM_OCNPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;2138   
;;;2139     /* Write to TIMx CCER register */
;;;2140     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;2141   }
000010  4770              BX       lr
;;;2142   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;2094   *******************************************************************************/
;;;2095   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2096   {
;;;2097     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2098   
;;;2099     /* Check the parameters */
;;;2100     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2101     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2102   
;;;2103     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2104   
;;;2105     /* Set or Reset the CC1P Bit */
;;;2106     tmpccer &= CCER_CC1P_Reset;
000006  f64f73fd          MOV      r3,#0xfffd
00000a  4019              ANDS     r1,r1,r3
;;;2107     tmpccer |= TIM_OCPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;2108   
;;;2109     /* Write to TIMx CCER register */
;;;2110     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;2111   }
000010  4770              BX       lr
;;;2112   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1691   *******************************************************************************/
;;;1692   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1693   {
;;;1694     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1695   
;;;1696     /* Check the parameters */
;;;1697     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1698     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1699   
;;;1700     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1701   
;;;1702     /* Reset the OC1PE Bit */
;;;1703     tmpccmr1 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1704   
;;;1705     /* Enable or Disable the Output Compare Preload feature */
;;;1706     tmpccmr1 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1707   
;;;1708     /* Write to TIMx CCMR1 register */
;;;1709     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1710   }
000010  4770              BX       lr
;;;1711   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1860   *******************************************************************************/
;;;1861   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1862   {
;;;1863     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1864   
;;;1865     /* Check the parameters */
;;;1866     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1867     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1868   
;;;1869     /* Get the TIMx CCMR1 register value */
;;;1870     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1871   
;;;1872     /* Reset the OC2FE Bit */
;;;1873     tmpccmr1 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1874   
;;;1875     /* Enable or Disable the Output Compare Fast Bit */
;;;1876     tmpccmr1 |= (u16)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1877   
;;;1878     /* Write to TIMx CCMR1 */
;;;1879     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1880   }
000018  4770              BX       lr
;;;1881   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;333    *******************************************************************************/
;;;334    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;335    {
;;;336      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;337       
;;;338      /* Check the parameters */
;;;339      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;340      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;341      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;342      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;343    
;;;344      /* Disable the Channel 2: Reset the CC2E Bit */
;;;345      TIMx->CCER &= CCER_CC2E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;346      
;;;347      /* Get the TIMx CCER register value */  
;;;348      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;349    
;;;350      /* Get the TIMx CR2 register value */
;;;351      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;352      
;;;353      /* Get the TIMx CCMR1 register value */
;;;354      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;355        
;;;356      /* Reset the Output Compare Mode Bits */
;;;357      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;358      
;;;359      /* Select the Output Compare Mode */
;;;360      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;361      
;;;362      /* Reset the Output Polarity level */
;;;363      tmpccer &= CCER_CC2P_Reset;
00002a  f64f75df          MOV      r5,#0xffdf
00002e  402a              ANDS     r2,r2,r5
;;;364    
;;;365      /* Set the Output Compare Polarity */
;;;366      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000030  890d              LDRH     r5,[r1,#8]
000032  ea061505          AND      r5,r6,r5,LSL #4
000036  432a              ORRS     r2,r2,r5
;;;367      
;;;368      /* Set the Output State */
;;;369      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea061505          AND      r5,r6,r5,LSL #4
00003e  432a              ORRS     r2,r2,r5
;;;370      
;;;371      /* Set the Capture Compare Register value */
;;;372      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000040  88cd              LDRH     r5,[r1,#6]
000042  8705              STRH     r5,[r0,#0x38]
;;;373      
;;;374      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000044  4d13              LDR      r5,|L51.148|
000046  42a8              CMP      r0,r5
000048  d002              BEQ      |L51.80|
00004a  4d13              LDR      r5,|L51.152|
00004c  42a8              CMP      r0,r5
00004e  d11d              BNE      |L51.140|
                  |L51.80|
;;;375      {
;;;376        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;377        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;378        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;379        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;380        
;;;381        /* Reset the Output N Polarity level */
;;;382        tmpccer &= CCER_CC2NP_Reset;
000050  f64f757f          MOV      r5,#0xff7f
000054  402a              ANDS     r2,r2,r5
;;;383    
;;;384        /* Set the Output N Polarity */
;;;385        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000056  894d              LDRH     r5,[r1,#0xa]
000058  f64f76ff          MOV      r6,#0xffff
00005c  ea061505          AND      r5,r6,r5,LSL #4
000060  432a              ORRS     r2,r2,r5
;;;386    
;;;387        /* Reset the Output N State */
;;;388        tmpccer &= CCER_CC2NE_Reset;
000062  f64f75bf          MOV      r5,#0xffbf
000066  402a              ANDS     r2,r2,r5
;;;389        
;;;390        /* Set the Output N State */
;;;391        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
000068  888d              LDRH     r5,[r1,#4]
00006a  ea061505          AND      r5,r6,r5,LSL #4
00006e  432a              ORRS     r2,r2,r5
;;;392    
;;;393        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;394        tmpcr2 &= CR2_OIS2_Reset;
000070  f64735ff          MOV      r5,#0x7bff
000074  402b              ANDS     r3,r3,r5
;;;395        tmpcr2 &= CR2_OIS2N_Reset;
000076  f24775ff          MOV      r5,#0x77ff
00007a  402b              ANDS     r3,r3,r5
;;;396    
;;;397        /* Set the Output Idle state */
;;;398        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00007c  898d              LDRH     r5,[r1,#0xc]
00007e  ea060585          AND      r5,r6,r5,LSL #2
000082  432b              ORRS     r3,r3,r5
;;;399    
;;;400        /* Set the Output N Idle state */
;;;401        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000084  89cd              LDRH     r5,[r1,#0xe]
000086  ea060585          AND      r5,r6,r5,LSL #2
00008a  432b              ORRS     r3,r3,r5
                  |L51.140|
;;;402      }
;;;403    
;;;404      /* Write to TIMx CR2 */
;;;405      TIMx->CR2 = tmpcr2;
00008c  8083              STRH     r3,[r0,#4]
;;;406      
;;;407      /* Write to TIMx CCMR1 */
;;;408      TIMx->CCMR1 = tmpccmrx;
00008e  8304              STRH     r4,[r0,#0x18]
;;;409      
;;;410      /* Write to TIMx CCER */
;;;411      TIMx->CCER = tmpccer;
000090  8402              STRH     r2,[r0,#0x20]
;;;412    }
000092  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

                  |L51.148|
                          DCD      0x40012c00
                  |L51.152|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;2185   *******************************************************************************/
;;;2186   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;2187   {
;;;2188     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2189   
;;;2190     /* Check the parameters */
;;;2191     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2192     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2193     
;;;2194     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2195   
;;;2196     /* Set or Reset the CC2NP Bit */
;;;2197     tmpccer &= CCER_CC2NP_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;2198     tmpccer |= (u16)(TIM_OCNPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;2199   
;;;2200     /* Write to TIMx CCER register */
;;;2201     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2202   }
000018  4770              BX       lr
;;;2203   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;2155   *******************************************************************************/
;;;2156   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2157   {
;;;2158     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2159   
;;;2160     /* Check the parameters */
;;;2161     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2162     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2163   
;;;2164     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2165   
;;;2166     /* Set or Reset the CC2P Bit */
;;;2167     tmpccer &= CCER_CC2P_Reset;
000006  f64f73df          MOV      r3,#0xffdf
00000a  4019              ANDS     r1,r1,r3
;;;2168     tmpccer |= (u16)(TIM_OCPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;2169   
;;;2170     /* Write to TIMx CCER register */
;;;2171     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2172   }
000018  4770              BX       lr
;;;2173   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1725   *******************************************************************************/
;;;1726   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1727   {
;;;1728     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1729   
;;;1730     /* Check the parameters */
;;;1731     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1732     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1733   
;;;1734     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1735   
;;;1736     /* Reset the OC2PE Bit */
;;;1737     tmpccmr1 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1738   
;;;1739     /* Enable or Disable the Output Compare Preload feature */
;;;1740     tmpccmr1 |= (u16)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1741   
;;;1742     /* Write to TIMx CCMR1 register */
;;;1743     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1744   }
000018  4770              BX       lr
;;;1745   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1894   *******************************************************************************/
;;;1895   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1896   {
;;;1897     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1898   
;;;1899     /* Check the parameters */
;;;1900     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1901     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1902   
;;;1903     /* Get the TIMx CCMR2 register value */
;;;1904     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1905   
;;;1906     /* Reset the OC3FE Bit */
;;;1907     tmpccmr2 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1908   
;;;1909     /* Enable or Disable the Output Compare Fast Bit */
;;;1910     tmpccmr2 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1911   
;;;1912     /* Write to TIMx CCMR2 */
;;;1913     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1914   }
000010  4770              BX       lr
;;;1915   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;426    *******************************************************************************/
;;;427    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;428    {
;;;429      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;430       
;;;431      /* Check the parameters */
;;;432      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;433      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;434      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;435      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;436    
;;;437      /* Disable the Channel 2: Reset the CC2E Bit */
;;;438      TIMx->CCER &= CCER_CC3E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;439      
;;;440      /* Get the TIMx CCER register value */
;;;441      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;442    
;;;443      /* Get the TIMx CR2 register value */
;;;444      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;445      
;;;446      /* Get the TIMx CCMR2 register value */
;;;447      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;448        
;;;449      /* Reset the Output Compare Mode Bits */
;;;450      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;451      
;;;452      /* Select the Output Compare Mode */
;;;453      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;454      
;;;455      /* Reset the Output Polarity level */
;;;456      tmpccer &= CCER_CC3P_Reset;
000022  f64f55ff          MOV      r5,#0xfdff
000026  402a              ANDS     r2,r2,r5
;;;457    
;;;458      /* Set the Output Compare Polarity */
;;;459      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000028  890d              LDRH     r5,[r1,#8]
00002a  f64f76ff          MOV      r6,#0xffff
00002e  ea062505          AND      r5,r6,r5,LSL #8
000032  432a              ORRS     r2,r2,r5
;;;460      
;;;461      /* Set the Output State */
;;;462      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
000034  884d              LDRH     r5,[r1,#2]
000036  ea062505          AND      r5,r6,r5,LSL #8
00003a  432a              ORRS     r2,r2,r5
;;;463      
;;;464      /* Set the Capture Compare Register value */
;;;465      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00003c  88cd              LDRH     r5,[r1,#6]
00003e  8785              STRH     r5,[r0,#0x3c]
;;;466      
;;;467      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000040  4d13              LDR      r5,|L56.144|
000042  42a8              CMP      r0,r5
000044  d002              BEQ      |L56.76|
000046  4d13              LDR      r5,|L56.148|
000048  42a8              CMP      r0,r5
00004a  d11d              BNE      |L56.136|
                  |L56.76|
;;;468      {
;;;469        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;470        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;471        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;472        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;473        
;;;474        /* Reset the Output N Polarity level */
;;;475        tmpccer &= CCER_CC3NP_Reset;
00004c  f24f75ff          MOV      r5,#0xf7ff
000050  402a              ANDS     r2,r2,r5
;;;476    
;;;477        /* Set the Output N Polarity */
;;;478        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000052  894d              LDRH     r5,[r1,#0xa]
000054  f64f76ff          MOV      r6,#0xffff
000058  ea062505          AND      r5,r6,r5,LSL #8
00005c  432a              ORRS     r2,r2,r5
;;;479    
;;;480        /* Reset the Output N State */
;;;481        tmpccer &= CCER_CC3NE_Reset;
00005e  f64f35ff          MOV      r5,#0xfbff
000062  402a              ANDS     r2,r2,r5
;;;482        
;;;483        /* Set the Output N State */
;;;484        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
000064  888d              LDRH     r5,[r1,#4]
000066  ea062505          AND      r5,r6,r5,LSL #8
00006a  432a              ORRS     r2,r2,r5
;;;485    
;;;486        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;487        tmpcr2 &= CR2_OIS3_Reset;
00006c  f64675ff          MOV      r5,#0x6fff
000070  402b              ANDS     r3,r3,r5
;;;488        tmpcr2 &= CR2_OIS3N_Reset;
000072  f64575ff          MOV      r5,#0x5fff
000076  402b              ANDS     r3,r3,r5
;;;489    
;;;490        /* Set the Output Idle state */
;;;491        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000078  898d              LDRH     r5,[r1,#0xc]
00007a  ea061505          AND      r5,r6,r5,LSL #4
00007e  432b              ORRS     r3,r3,r5
;;;492    
;;;493        /* Set the Output N Idle state */
;;;494        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000080  89cd              LDRH     r5,[r1,#0xe]
000082  ea061505          AND      r5,r6,r5,LSL #4
000086  432b              ORRS     r3,r3,r5
                  |L56.136|
;;;495      }
;;;496    
;;;497      /* Write to TIMx CR2 */
;;;498      TIMx->CR2 = tmpcr2;
000088  8083              STRH     r3,[r0,#4]
;;;499      
;;;500      /* Write to TIMx CCMR2 */
;;;501      TIMx->CCMR2 = tmpccmrx;
00008a  8384              STRH     r4,[r0,#0x1c]
;;;502      
;;;503      /* Write to TIMx CCER */
;;;504      TIMx->CCER = tmpccer;
00008c  8402              STRH     r2,[r0,#0x20]
;;;505    }
00008e  bd70              POP      {r4-r6,pc}
;;;506    
                          ENDP

                  |L56.144|
                          DCD      0x40012c00
                  |L56.148|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;2246   *******************************************************************************/
;;;2247   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;2248   {
;;;2249     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2250    
;;;2251     /* Check the parameters */
;;;2252     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2253     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2254       
;;;2255     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2256   
;;;2257     /* Set or Reset the CC3NP Bit */
;;;2258     tmpccer &= CCER_CC3NP_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;2259     tmpccer |= (u16)(TIM_OCNPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;2260   
;;;2261     /* Write to TIMx CCER register */
;;;2262     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2263   }
000018  4770              BX       lr
;;;2264   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;2216   *******************************************************************************/
;;;2217   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2218   {
;;;2219     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2220   
;;;2221     /* Check the parameters */
;;;2222     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2223     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2224   
;;;2225     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2226   
;;;2227     /* Set or Reset the CC3P Bit */
;;;2228     tmpccer &= CCER_CC3P_Reset;
000006  f64f53ff          MOV      r3,#0xfdff
00000a  4019              ANDS     r1,r1,r3
;;;2229     tmpccer |= (u16)(TIM_OCPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;2230   
;;;2231     /* Write to TIMx CCER register */
;;;2232     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2233   }
000018  4770              BX       lr
;;;2234   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1759   *******************************************************************************/
;;;1760   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1761   {
;;;1762     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1763   
;;;1764     /* Check the parameters */
;;;1765     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1766     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1767   
;;;1768     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1769   
;;;1770     /* Reset the OC3PE Bit */
;;;1771     tmpccmr2 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1772   
;;;1773     /* Enable or Disable the Output Compare Preload feature */
;;;1774     tmpccmr2 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1775   
;;;1776     /* Write to TIMx CCMR2 register */
;;;1777     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1778   }
000010  4770              BX       lr
;;;1779   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1928   *******************************************************************************/
;;;1929   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1930   {
;;;1931     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1932   
;;;1933     /* Check the parameters */
;;;1934     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1935     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1936   
;;;1937     /* Get the TIMx CCMR2 register value */
;;;1938     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1939   
;;;1940     /* Reset the OC4FE Bit */
;;;1941     tmpccmr2 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1942   
;;;1943     /* Enable or Disable the Output Compare Fast Bit */
;;;1944     tmpccmr2 |= (u16)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1945   
;;;1946     /* Write to TIMx CCMR2 */
;;;1947     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1948   }
000018  4770              BX       lr
;;;1949   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;519    *******************************************************************************/
;;;520    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
;;;522      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;523       
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;526      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;527      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;528      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;529    
;;;530      /* Disable the Channel 2: Reset the CC4E Bit */
;;;531      TIMx->CCER &= CCER_CC4E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;532      
;;;533      /* Get the TIMx CCER register value */
;;;534      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;535    
;;;536      /* Get the TIMx CR2 register value */
;;;537      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;538      
;;;539      /* Get the TIMx CCMR2 register value */
;;;540      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;541        
;;;542      /* Reset the Output Compare Mode Bits */
;;;543      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;544      
;;;545      /* Select the Output Compare Mode */
;;;546      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;547      
;;;548      /* Reset the Output Polarity level */
;;;549      tmpccer &= CCER_CC4P_Reset;
00002a  f64d75ff          MOV      r5,#0xdfff
00002e  402a              ANDS     r2,r2,r5
;;;550    
;;;551      /* Set the Output Compare Polarity */
;;;552      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000030  890d              LDRH     r5,[r1,#8]
000032  ea063505          AND      r5,r6,r5,LSL #12
000036  432a              ORRS     r2,r2,r5
;;;553      
;;;554      /* Set the Output State */
;;;555      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea063505          AND      r5,r6,r5,LSL #12
00003e  432a              ORRS     r2,r2,r5
;;;556      
;;;557      /* Set the Capture Compare Register value */
;;;558      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000040  88cd              LDRH     r5,[r1,#6]
000042  f8a05040          STRH     r5,[r0,#0x40]
;;;559      
;;;560      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000046  4d09              LDR      r5,|L61.108|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L61.82|
00004c  4d08              LDR      r5,|L61.112|
00004e  42a8              CMP      r0,r5
000050  d107              BNE      |L61.98|
                  |L61.82|
;;;561      {
;;;562        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;563    
;;;564        /* Reset the Ouput Compare IDLE State */
;;;565        tmpcr2 &= CR2_OIS4_Reset;
000052  f3c3030d          UBFX     r3,r3,#0,#14
;;;566    
;;;567        /* Set the Output Idle state */
;;;568        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000056  898d              LDRH     r5,[r1,#0xc]
000058  f64f76ff          MOV      r6,#0xffff
00005c  ea061585          AND      r5,r6,r5,LSL #6
000060  432b              ORRS     r3,r3,r5
                  |L61.98|
;;;569      }
;;;570    
;;;571      /* Write to TIMx CR2 */
;;;572      TIMx->CR2 = tmpcr2;
000062  8083              STRH     r3,[r0,#4]
;;;573      
;;;574      /* Write to TIMx CCMR2 */  
;;;575      TIMx->CCMR2 = tmpccmrx;
000064  8384              STRH     r4,[r0,#0x1c]
;;;576      
;;;577      /* Write to TIMx CCER */
;;;578      TIMx->CCER = tmpccer;
000066  8402              STRH     r2,[r0,#0x20]
;;;579    }
000068  bd70              POP      {r4-r6,pc}
;;;580    
                          ENDP

00006a  0000              DCW      0x0000
                  |L61.108|
                          DCD      0x40012c00
                  |L61.112|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;2277   *******************************************************************************/
;;;2278   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2279   {
;;;2280     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2281   
;;;2282     /* Check the parameters */
;;;2283     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2284     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2285   
;;;2286     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2287   
;;;2288     /* Set or Reset the CC4P Bit */
;;;2289     tmpccer &= CCER_CC4P_Reset;
000006  f64d73ff          MOV      r3,#0xdfff
00000a  4019              ANDS     r1,r1,r3
;;;2290     tmpccer |= (u16)(TIM_OCPolarity << 12);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea033302          AND      r3,r3,r2,LSL #12
000014  4319              ORRS     r1,r1,r3
;;;2291   
;;;2292     /* Write to TIMx CCER register */
;;;2293     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2294   }
000018  4770              BX       lr
;;;2295   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1793   *******************************************************************************/
;;;1794   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1795   {
;;;1796     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1797   
;;;1798     /* Check the parameters */
;;;1799     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1800     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1801   
;;;1802     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1803   
;;;1804     /* Reset the OC4PE Bit */
;;;1805     tmpccmr2 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1806   
;;;1807     /* Enable or Disable the Output Compare Preload feature */
;;;1808     tmpccmr2 |= (u16)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1809   
;;;1810     /* Write to TIMx CCMR2 register */
;;;1811     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1812   }
000018  4770              BX       lr
;;;1813   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;780    *******************************************************************************/
;;;781    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;782    {
;;;783      /* Set the default configuration */
;;;784      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;785      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;786      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;787      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;788      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;789      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;790      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;791      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;792    }
000012  4770              BX       lr
;;;793    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;659    *******************************************************************************/
;;;660    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;661    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;662      u16 icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;663      u16 icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;664    
;;;665      /* Check the parameters */
;;;666      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;667    
;;;668      /* Select the Opposite Input Polarity */
;;;669      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;670      {
;;;671        icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;672      }
;;;673      else
;;;674      {
;;;675        icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;676      }
;;;677    
;;;678      /* Select the Opposite Input */
;;;679      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;680      {
;;;681        icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;682      }
;;;683      else
;;;684      {
;;;685        icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;686      }
;;;687    
;;;688      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;689      {
;;;690        /* TI1 Configuration */
;;;691        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;692                   TIM_ICInitStruct->TIM_ICFilter);
;;;693    
;;;694        /* Set the Input Capture Prescaler value */
;;;695        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;696    
;;;697        /* TI2 Configuration */
;;;698        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;699    
;;;700        /* Set the Input Capture Prescaler value */
;;;701        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;702      }
;;;703      else
;;;704      { 
;;;705        /* TI2 Configuration */
;;;706        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;707                   TIM_ICInitStruct->TIM_ICFilter);
;;;708    
;;;709        /* Set the Input Capture Prescaler value */
;;;710        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;711    
;;;712        /* TI1 Configuration */
;;;713        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;714    
;;;715        /* Set the Input Capture Prescaler value */
;;;716        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;717      }
;;;718    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;719    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1265   *******************************************************************************/
;;;1266   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1267   {
;;;1268     /* Check the parameters */
;;;1269     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1270     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1271   
;;;1272     /* Set the Prescaler value */
;;;1273     TIMx->PSC = Prescaler;
;;;1274   
;;;1275     /* Set or reset the UG Bit */
;;;1276     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1277   }
000004  4770              BX       lr
;;;1278   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1630   *******************************************************************************/
;;;1631   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L67.12|
;;;1632   {
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1635     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1636   
;;;1637     if (NewState != DISABLE)
;;;1638     {
;;;1639       /* Set the CCDS Bit */
;;;1640       TIMx->CR2 |= CR2_CCDS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L67.22|
                  |L67.12|
;;;1641     }
;;;1642     else
;;;1643     {
;;;1644       /* Reset the CCDS Bit */
;;;1645       TIMx->CR2 &= CR2_CCDS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L67.22|
;;;1646     }
;;;1647   }
000016  4770              BX       lr
;;;1648   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1601   *******************************************************************************/
;;;1602   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;1603   {
;;;1604     /* Check the parameters */
;;;1605     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1606     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1607   
;;;1608     if (NewState != DISABLE)
;;;1609     {
;;;1610       /* Set the COM Bit */
;;;1611       TIMx->CR2 |= CR2_CCUS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;1612     }
;;;1613     else
;;;1614     {
;;;1615       /* Reset the COM Bit */
;;;1616       TIMx->CR2 &= CR2_CCUS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;1617     }
;;;1618   }
000016  4770              BX       lr
;;;1619   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2480   *******************************************************************************/
;;;2481   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2482   {
;;;2483     /* Check the parameters */
;;;2484     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2485     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2486   
;;;2487     if (NewState != DISABLE)
;;;2488     {
;;;2489       /* Set the TI1S Bit */
;;;2490       TIMx->CR2 |= CR2_TI1S_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2491     }
;;;2492     else
;;;2493     {
;;;2494       /* Reset the TI1S Bit */
;;;2495       TIMx->CR2 &= CR2_TI1S_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2496     }
;;;2497   }
000016  4770              BX       lr
;;;2498   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1333   *******************************************************************************/
;;;1334   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;1335   {
;;;1336     u16 tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;1337   
;;;1338     /* Check the parameters */
;;;1339     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1340     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1341   
;;;1342     /* Get the TIMx SMCR register value */
;;;1343     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;1344   
;;;1345     /* Reset the TS Bits */
;;;1346     tmpsmcr &= SMCR_TS_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1347   
;;;1348     /* Set the Input Trigger source */
;;;1349     tmpsmcr |= TIM_InputTriggerSource;
00000c  4311              ORRS     r1,r1,r2
;;;1350   
;;;1351     /* Write to TIMx SMCR */
;;;1352     TIMx->SMCR = tmpsmcr;
00000e  8101              STRH     r1,[r0,#8]
;;;1353   }
000010  4770              BX       lr
;;;1354   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2600   *******************************************************************************/
;;;2601   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2602   {
;;;2603     /* Check the parameters */
;;;2604     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2605     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2606   
;;;2607     /* Reset the MSM Bit */
;;;2608     TIMx->SMCR &= SMCR_MSM_Reset;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2609     
;;;2610     /* Set or Reset the MSM Bit */
;;;2611     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2612   }
000010  4770              BX       lr
;;;2613   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2383   *******************************************************************************/
;;;2384   void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;2385   {
;;;2386     /* Check the parameters */
;;;2387     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2388     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2389     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2390     
;;;2391     /* Disable the Channel: Reset the CCxE Bit */
;;;2392     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2393   
;;;2394     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
00000c  b109              CBZ      r1,|L72.18|
00000e  2908              CMP      r1,#8
000010  d112              BNE      |L72.56|
                  |L72.18|
;;;2395     {
;;;2396       /* Reset the OCxM bits in the CCMRx register */
;;;2397       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
000012  f1000318          ADD      r3,r0,#0x18
000016  eb030361          ADD      r3,r3,r1,ASR #1
00001a  681b              LDR      r3,[r3,#0]
00001c  f64f748f          MOV      r4,#0xff8f
000020  4023              ANDS     r3,r3,r4
000022  f1000418          ADD      r4,r0,#0x18
000026  eb040461          ADD      r4,r4,r1,ASR #1
00002a  6023              STR      r3,[r4,#0]
;;;2398      
;;;2399       /* Configure the OCxM bits in the CCMRx register */
;;;2400       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) = TIM_OCMode;
00002c  f1000318          ADD      r3,r0,#0x18
000030  eb030361          ADD      r3,r3,r1,ASR #1
000034  601a              STR      r2,[r3,#0]
000036  e018              B        |L72.106|
                  |L72.56|
;;;2401   
;;;2402     }
;;;2403     else
;;;2404     {
;;;2405       /* Reset the OCxM bits in the CCMRx register */
;;;2406       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000038  1f0b              SUBS     r3,r1,#4
00003a  f3c3044e          UBFX     r4,r3,#1,#15
00003e  f1000318          ADD      r3,r0,#0x18
000042  591b              LDR      r3,[r3,r4]
000044  f64874ff          MOV      r4,#0x8fff
000048  4023              ANDS     r3,r3,r4
00004a  1f0c              SUBS     r4,r1,#4
00004c  f3c4054e          UBFX     r5,r4,#1,#15
000050  f1000418          ADD      r4,r0,#0x18
000054  5163              STR      r3,[r4,r5]
;;;2407       
;;;2408       /* Configure the OCxM bits in the CCMRx register */
;;;2409       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
000056  f64f73ff          MOV      r3,#0xffff
00005a  ea032402          AND      r4,r3,r2,LSL #8
00005e  1f0b              SUBS     r3,r1,#4
000060  f3c3054e          UBFX     r5,r3,#1,#15
000064  f1000318          ADD      r3,r0,#0x18
000068  515c              STR      r4,[r3,r5]
                  |L72.106|
;;;2410     }
;;;2411   }
00006a  bd30              POP      {r4,r5,pc}
;;;2412   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2510   *******************************************************************************/
;;;2511   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2512   {
;;;2513     /* Check the parameters */
;;;2514     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2515     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2516   
;;;2517     /* Reset the OPM Bit */
;;;2518     TIMx->CR1 &= CR1_OPM_Reset;
000002  f24033f7          MOV      r3,#0x3f7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;2519   
;;;2520     /* Configure the OPM Mode */
;;;2521     TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2522   }
000010  4770              BX       lr
;;;2523   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2544   *******************************************************************************/
;;;2545   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2546   {
;;;2547     /* Check the parameters */
;;;2548     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2549     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2550     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2551   
;;;2552     /* Reset the MMS Bits */
;;;2553     TIMx->CR2 &= CR2_MMS_Mask;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2554   
;;;2555     /* Select the TRGO source */
;;;2556     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2557   }
000010  4770              BX       lr
;;;2558   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2573   *******************************************************************************/
;;;2574   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2575   {
;;;2576     /* Check the parameters */
;;;2577     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2578     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2579   
;;;2580     /* Reset the SMS Bits */
;;;2581     TIMx->SMCR &= SMCR_SMS_Mask;
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2582   
;;;2583     /* Select the Slave Mode */
;;;2584     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2585   }
000010  4770              BX       lr
;;;2586   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2640   *******************************************************************************/
;;;2641   void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2642   {
;;;2643     /* Check the parameters */
;;;2644     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2645   
;;;2646     /* Set the Autoreload Register value */
;;;2647     TIMx->ARR = Autoreload;
;;;2648   }
000002  4770              BX       lr
;;;2649   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2855   *******************************************************************************/
;;;2856   void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2857   {
;;;2858     /* Check the parameters */
;;;2859     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2860     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2861   
;;;2862     /* Reset the CKD Bits */
;;;2863     TIMx->CR1 &= CR1_CKD_Mask;
000002  b2d2              UXTB     r2,r2
000004  8002              STRH     r2,[r0,#0]
;;;2864   
;;;2865     /* Set the CKD value */
;;;2866     TIMx->CR1 |= TIM_CKD;
000006  8802              LDRH     r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  8002              STRH     r2,[r0,#0]
;;;2867   }
00000c  4770              BX       lr
;;;2868   /*******************************************************************************
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2659   *******************************************************************************/
;;;2660   void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2661   {
;;;2662     /* Check the parameters */
;;;2663     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2664   
;;;2665     /* Set the Capture Compare1 Register value */
;;;2666     TIMx->CCR1 = Compare1;
;;;2667   }
000002  4770              BX       lr
;;;2668   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2678   *******************************************************************************/
;;;2679   void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2680   {
;;;2681     /* Check the parameters */
;;;2682     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2683   
;;;2684     /* Set the Capture Compare2 Register value */
;;;2685     TIMx->CCR2 = Compare2;
;;;2686   }
000002  4770              BX       lr
;;;2687   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2697   *******************************************************************************/
;;;2698   void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2699   {
;;;2700     /* Check the parameters */
;;;2701     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2702   
;;;2703     /* Set the Capture Compare3 Register value */
;;;2704     TIMx->CCR3 = Compare3;
;;;2705   }
000002  4770              BX       lr
;;;2706   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2716   *******************************************************************************/
;;;2717   void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2718   {
;;;2719     /* Check the parameters */
;;;2720     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2721   
;;;2722     /* Set the Capture Compare4 Register value */
;;;2723     TIMx->CCR4 = Compare4;
;;;2724   }
000004  4770              BX       lr
;;;2725   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2622   *******************************************************************************/
;;;2623   void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2624   {
;;;2625     /* Check the parameters */
;;;2626     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2627   
;;;2628     /* Set the Counter Register value */
;;;2629     TIMx->CNT = Counter;
;;;2630   }
000002  4770              BX       lr
;;;2631   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2741   *******************************************************************************/
;;;2742   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2743   {
;;;2744     /* Check the parameters */
;;;2745     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2746     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2747   
;;;2748     /* Reset the IC1PSC Bits */
;;;2749     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2750   
;;;2751     /* Set the IC1PSC value */
;;;2752     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2753   }
000010  4770              BX       lr
;;;2754   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2770   *******************************************************************************/
;;;2771   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2772   {
;;;2773     /* Check the parameters */
;;;2774     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2775     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2776   
;;;2777     /* Reset the IC2PSC Bits */
;;;2778     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2779   
;;;2780     /* Set the IC2PSC value */
;;;2781     TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8302              STRH     r2,[r0,#0x18]
;;;2782   }
000018  4770              BX       lr
;;;2783   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2799   *******************************************************************************/
;;;2800   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2801   {
;;;2802     /* Check the parameters */
;;;2803     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2804     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2805   
;;;2806     /* Reset the IC3PSC Bits */
;;;2807     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2808   
;;;2809     /* Set the IC3PSC value */
;;;2810     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2811   }
000010  4770              BX       lr
;;;2812   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2828   *******************************************************************************/
;;;2829   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2830   {  
;;;2831     /* Check the parameters */
;;;2832     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2833     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2834   
;;;2835     /* Reset the IC4PSC Bits */
;;;2836     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2837   
;;;2838     /* Set the IC4PSC value */
;;;2839     TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8382              STRH     r2,[r0,#0x1c]
;;;2840   }
000018  4770              BX       lr
;;;2841   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1092   *******************************************************************************/
;;;1093   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1094                                   u16 TIM_ICPolarity, u16 ICFilter)
;;;1095   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1096     /* Check the parameters */
;;;1097     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1098     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1099     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1100     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1101   
;;;1102     /* Configure the Timer Input Clock Source */
;;;1103     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L87.30|
;;;1104     {
;;;1105       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L87.42|
                  |L87.30|
;;;1106     }
;;;1107     else
;;;1108     {
;;;1109       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L87.42|
;;;1110     }
;;;1111   
;;;1112     /* Select the Trigger source */
;;;1113     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;1114   
;;;1115     /* Select the External clock mode1 */
;;;1116     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;1117   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1118   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;201    *******************************************************************************/
;;;202    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  8802              LDRH     r2,[r0,#0]
;;;203    {
;;;204      /* Check the parameters */
;;;205      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;206      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;207      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;208    
;;;209      /* Select the Counter Mode and set the clock division */
;;;210      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
000002  f002028f          AND      r2,r2,#0x8f
000006  8002              STRH     r2,[r0,#0]
;;;211      TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
000008  88ca              LDRH     r2,[r1,#6]
00000a  884b              LDRH     r3,[r1,#2]
00000c  431a              ORRS     r2,r2,r3
00000e  8803              LDRH     r3,[r0,#0]
000010  431a              ORRS     r2,r2,r3
000012  8002              STRH     r2,[r0,#0]
;;;212                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;213      /* Set the Autoreload value */
;;;214      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000014  888a              LDRH     r2,[r1,#4]
000016  8582              STRH     r2,[r0,#0x2c]
;;;215    
;;;216      /* Set the Prescaler value */
;;;217      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000018  880a              LDRH     r2,[r1,#0]
00001a  8502              STRH     r2,[r0,#0x28]
;;;218    
;;;219      /* Generate an update event to reload the Prescaler value immediatly */
;;;220      TIMx->EGR = TIM_PSCReloadMode_Immediate;   
00001c  2201              MOVS     r2,#1
00001e  8282              STRH     r2,[r0,#0x14]
;;;221        
;;;222      if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
000020  4a04              LDR      r2,|L88.52|
000022  4290              CMP      r0,r2
000024  d002              BEQ      |L88.44|
000026  4a04              LDR      r2,|L88.56|
000028  4290              CMP      r0,r2
00002a  d102              BNE      |L88.50|
                  |L88.44|
;;;223      {
;;;224        /* Set the Repetition Counter value */
;;;225        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00002c  7a0a              LDRB     r2,[r1,#8]
00002e  f8a02050          STRH     r2,[r0,#0x50]
                  |L88.50|
;;;226      }        
;;;227    }
000032  4770              BX       lr
;;;228    
                          ENDP

                  |L88.52|
                          DCD      0x40012c00
                  |L88.56|
                          DCD      0x40013400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;761    *******************************************************************************/
;;;762    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;763    {
;;;764      /* Set the default configuration */
;;;765      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;766      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;767      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;768      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;769      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;770    }
000010  4770              BX       lr
;;;771    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2422   *******************************************************************************/
;;;2423   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L90.12|
;;;2424   {
;;;2425     /* Check the parameters */
;;;2426     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2427     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2428   
;;;2429     if (NewState != DISABLE)
;;;2430     {
;;;2431       /* Set the Update Disable Bit */
;;;2432       TIMx->CR1 |= CR1_UDIS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L90.22|
                  |L90.12|
;;;2433     }
;;;2434     else
;;;2435     {
;;;2436       /* Reset the Update Disable Bit */
;;;2437       TIMx->CR1 &= CR1_UDIS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fd          MOV      r3,#0x3fd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L90.22|
;;;2438     }
;;;2439   }
000016  4770              BX       lr
;;;2440   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2452   *******************************************************************************/
;;;2453   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
000000  b121              CBZ      r1,|L91.12|
;;;2454   {
;;;2455     /* Check the parameters */
;;;2456     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2457     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2458   
;;;2459     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2460     {
;;;2461       /* Set the URS Bit */
;;;2462       TIMx->CR1 |= CR1_URS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;2463     }
;;;2464     else
;;;2465     {
;;;2466       /* Reset the URS Bit */
;;;2467       TIMx->CR1 &= CR1_URS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fb          MOV      r3,#0x3fb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;2468     }
;;;2469   }
000016  4770              BX       lr
;;;2470   
                          ENDP

