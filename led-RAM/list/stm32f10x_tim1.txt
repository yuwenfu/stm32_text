; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_tim1.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\stm32f10x_tim1.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\lib\inc -I.\User -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 -DVECT_TAB_RAM --omf_browse=.\output\stm32f10x_tim1.crf lib\src\stm32f10x_tim1.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=2

                  TI1_Config PROC
;;;2699   *******************************************************************************/
;;;2700   static void TI1_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;2701                          u8 TIM1_ICFilter)
;;;2702   {
000002  4603              MOV      r3,r0
;;;2703     u32 tmpccmr1 = 0;
000004  2000              MOVS     r0,#0
;;;2704   
;;;2705     tmpccmr1 = TIM1->CCMR1;
000006  4c0a              LDR      r4,|L1.48|
000008  8820              LDRH     r0,[r4,#0]
;;;2706   
;;;2707     /* Disable the Channel 1: Reset the CCE Bit */
;;;2708     *(vu32 *) CCER_CC1E_BB = CCER_CCE_Reset;
00000a  2400              MOVS     r4,#0
00000c  4d09              LDR      r5,|L1.52|
00000e  602c              STR      r4,[r5,#0]
;;;2709   
;;;2710     /* Select the Input and set the filter */
;;;2711     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000010  f64f740c          MOV      r4,#0xff0c
000014  4020              ANDS     r0,r0,r4
;;;2712     tmpccmr1 |= (u16)TIM1_ICSelection | (u16)((u16)TIM1_ICFilter << 4);
000016  ea411402          ORR      r4,r1,r2,LSL #4
00001a  4320              ORRS     r0,r0,r4
;;;2713   
;;;2714     TIM1->CCMR1 = (u16)tmpccmr1;
00001c  4d04              LDR      r5,|L1.48|
00001e  8028              STRH     r0,[r5,#0]
;;;2715   
;;;2716     /* Select the Polarity */
;;;2717     *(vu32 *) CCER_CC1P_BB = TIM1_ICPolarity;
000020  4c04              LDR      r4,|L1.52|
000022  1d24              ADDS     r4,r4,#4
000024  6023              STR      r3,[r4,#0]
;;;2718   
;;;2719     /* Set the CCE Bit */
;;;2720     *(vu32 *) CCER_CC1E_BB = CCER_CCE_Set;
000026  2401              MOVS     r4,#1
000028  4d02              LDR      r5,|L1.52|
00002a  602c              STR      r4,[r5,#0]
;;;2721   }
00002c  bd30              POP      {r4,r5,pc}
;;;2722   
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40012c18
                  |L1.52|
                          DCD      0x42258400

                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=2

                  TI2_Config PROC
;;;2743   *******************************************************************************/
;;;2744   static void TI2_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;2745                          u8 TIM1_ICFilter)
;;;2746   {
000002  4603              MOV      r3,r0
;;;2747     u32 tmpccmr1 = 0;
000004  2000              MOVS     r0,#0
;;;2748   
;;;2749     tmpccmr1 = TIM1->CCMR1;
000006  4c0d              LDR      r4,|L2.60|
000008  8820              LDRH     r0,[r4,#0]
;;;2750   
;;;2751     /* Disable the Channel 2: Reset the CCE Bit */
;;;2752     *(vu32 *) CCER_CC2E_BB = CCER_CCE_Reset;
00000a  2400              MOVS     r4,#0
00000c  4d0c              LDR      r5,|L2.64|
00000e  602c              STR      r4,[r5,#0]
;;;2753   
;;;2754     /* Select the Input and set the filter */
;;;2755     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000010  f64044ff          MOV      r4,#0xcff
000014  4020              ANDS     r0,r0,r4
;;;2756     tmpccmr1 |= (u16)((u16)TIM1_ICSelection << 8) | (u16)((u16)TIM1_ICFilter <<12);
000016  f64f74ff          MOV      r4,#0xffff
00001a  ea042401          AND      r4,r4,r1,LSL #8
00001e  f64f75ff          MOV      r5,#0xffff
000022  ea053502          AND      r5,r5,r2,LSL #12
000026  432c              ORRS     r4,r4,r5
000028  4320              ORRS     r0,r0,r4
;;;2757   
;;;2758     TIM1->CCMR1 = (u16)tmpccmr1;
00002a  4c04              LDR      r4,|L2.60|
00002c  8020              STRH     r0,[r4,#0]
;;;2759   
;;;2760     /* Select the Polarity */
;;;2761     *(vu32 *) CCER_CC2P_BB = TIM1_ICPolarity;
00002e  4c04              LDR      r4,|L2.64|
000030  1d24              ADDS     r4,r4,#4
000032  6023              STR      r3,[r4,#0]
;;;2762   
;;;2763     /* Set the CCE Bit */
;;;2764     *(vu32 *) CCER_CC2E_BB = CCER_CCE_Set;
000034  2401              MOVS     r4,#1
000036  4d02              LDR      r5,|L2.64|
000038  602c              STR      r4,[r5,#0]
;;;2765   
;;;2766   }
00003a  bd30              POP      {r4,r5,pc}
;;;2767   
                          ENDP

                  |L2.60|
                          DCD      0x40012c18
                  |L2.64|
                          DCD      0x42258410

                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=2

                  TI3_Config PROC
;;;2788   *******************************************************************************/
;;;2789   static void TI3_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;2790                          u8 TIM1_ICFilter)
;;;2791   {
000002  4603              MOV      r3,r0
;;;2792     u32 tmpccmr2 = 0;
000004  2000              MOVS     r0,#0
;;;2793   
;;;2794     tmpccmr2 = TIM1->CCMR2;
000006  4c0a              LDR      r4,|L3.48|
000008  8820              LDRH     r0,[r4,#0]
;;;2795   
;;;2796     /* Disable the Channel 3: Reset the CCE Bit */
;;;2797     *(vu32 *) CCER_CC3E_BB = CCER_CCE_Reset;
00000a  2400              MOVS     r4,#0
00000c  4d09              LDR      r5,|L3.52|
00000e  602c              STR      r4,[r5,#0]
;;;2798   
;;;2799     /* Select the Input and set the filter */
;;;2800     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000010  f64f740c          MOV      r4,#0xff0c
000014  4020              ANDS     r0,r0,r4
;;;2801     tmpccmr2 |= (u16)TIM1_ICSelection | (u16)((u16)TIM1_ICFilter << 4);
000016  ea411402          ORR      r4,r1,r2,LSL #4
00001a  4320              ORRS     r0,r0,r4
;;;2802   
;;;2803     TIM1->CCMR2 = (u16)tmpccmr2;
00001c  4d04              LDR      r5,|L3.48|
00001e  8028              STRH     r0,[r5,#0]
;;;2804   
;;;2805     /* Select the Polarity */
;;;2806     *(vu32 *) CCER_CC3P_BB = TIM1_ICPolarity;
000020  4c04              LDR      r4,|L3.52|
000022  1d24              ADDS     r4,r4,#4
000024  6023              STR      r3,[r4,#0]
;;;2807   
;;;2808     /* Set the CCE Bit */
;;;2809     *(vu32 *) CCER_CC3E_BB = CCER_CCE_Set;
000026  2401              MOVS     r4,#1
000028  4d02              LDR      r5,|L3.52|
00002a  602c              STR      r4,[r5,#0]
;;;2810   }
00002c  bd30              POP      {r4,r5,pc}
;;;2811   
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x40012c1c
                  |L3.52|
                          DCD      0x42258420

                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=2

                  TI4_Config PROC
;;;2832   *******************************************************************************/
;;;2833   static void TI4_Config(u16 TIM1_ICPolarity, u16 TIM1_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;2834                          u8 TIM1_ICFilter)
;;;2835   {
000002  4603              MOV      r3,r0
;;;2836     u32 tmpccmr2 = 0;
000004  2000              MOVS     r0,#0
;;;2837   
;;;2838     tmpccmr2 = TIM1->CCMR2;
000006  4c0d              LDR      r4,|L4.60|
000008  8820              LDRH     r0,[r4,#0]
;;;2839     
;;;2840     /* Disable the Channel 4: Reset the CCE Bit */
;;;2841     *(vu32 *) CCER_CC4E_BB = CCER_CCE_Reset;
00000a  2400              MOVS     r4,#0
00000c  4d0c              LDR      r5,|L4.64|
00000e  602c              STR      r4,[r5,#0]
;;;2842   
;;;2843     /* Select the Input and set the filter */
;;;2844     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000010  f64044ff          MOV      r4,#0xcff
000014  4020              ANDS     r0,r0,r4
;;;2845     tmpccmr2 |= (u16)((u16)TIM1_ICSelection << 8) | (u16)((u16)TIM1_ICFilter << 12);
000016  f64f74ff          MOV      r4,#0xffff
00001a  ea042401          AND      r4,r4,r1,LSL #8
00001e  f64f75ff          MOV      r5,#0xffff
000022  ea053502          AND      r5,r5,r2,LSL #12
000026  432c              ORRS     r4,r4,r5
000028  4320              ORRS     r0,r0,r4
;;;2846   
;;;2847     TIM1->CCMR2 = (u16)tmpccmr2;
00002a  4c04              LDR      r4,|L4.60|
00002c  8020              STRH     r0,[r4,#0]
;;;2848   
;;;2849     /* Select the Polarity */
;;;2850     *(vu32 *) CCER_CC4P_BB = TIM1_ICPolarity;
00002e  4c04              LDR      r4,|L4.64|
000030  1d24              ADDS     r4,r4,#4
000032  6023              STR      r3,[r4,#0]
;;;2851   
;;;2852     /* Set the CCE Bit */
;;;2853     *(vu32 *) CCER_CC4E_BB = CCER_CCE_Set;
000034  2401              MOVS     r4,#1
000036  4d02              LDR      r5,|L4.64|
000038  602c              STR      r4,[r5,#0]
;;;2854   }
00003a  bd30              POP      {r4,r5,pc}
;;;2855   /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
                          ENDP

                  |L4.60|
                          DCD      0x40012c1c
                  |L4.64|
                          DCD      0x42258430

                          AREA ||i.TIM1_ARRPreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM1_ARRPreloadConfig PROC
;;;1581   *******************************************************************************/
;;;1582   void TIM1_ARRPreloadConfig(FunctionalState Newstate)
000000  4901              LDR      r1,|L5.8|
;;;1583   {
;;;1584     /* Check the parameters */
;;;1585     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;1586   
;;;1587     /* Set or Reset the ARPE Bit */
;;;1588     *(vu32 *) CR1_ARPE_BB = (u16)Newstate;
000002  61c8              STR      r0,[r1,#0x1c]
;;;1589   }
000004  4770              BX       lr
;;;1590   
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x42258000

                          AREA ||i.TIM1_BDTRConfig||, CODE, READONLY, ALIGN=2

                  TIM1_BDTRConfig PROC
;;;558    *******************************************************************************/
;;;559    void TIM1_BDTRConfig(TIM1_BDTRInitTypeDef *TIM1_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;560    {
;;;561      u16 tmpbdtr = 0;
;;;562    
;;;563      /* Check the parameters */
;;;564      assert_param(IS_TIM1_OSSR_STATE(TIM1_BDTRInitStruct->TIM1_OSSRState));
;;;565      assert_param(IS_TIM1_OSSI_STATE(TIM1_BDTRInitStruct->TIM1_OSSIState));
;;;566      assert_param(IS_TIM1_LOCK_LEVEL(TIM1_BDTRInitStruct->TIM1_LOCKLevel));
;;;567      assert_param(IS_TIM1_BREAK_STATE(TIM1_BDTRInitStruct->TIM1_Break));
;;;568      assert_param(IS_TIM1_BREAK_POLARITY(TIM1_BDTRInitStruct->TIM1_BreakPolarity));
;;;569      assert_param(IS_TIM1_AUTOMATIC_OUTPUT_STATE(TIM1_BDTRInitStruct->TIM1_AutomaticOutput));
;;;570    
;;;571      tmpbdtr = TIM1->BDTR;
000002  4a09              LDR      r2,|L6.40|
000004  8811              LDRH     r1,[r2,#0]
;;;572    
;;;573      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;574         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;575    
;;;576      tmpbdtr = (u32)TIM1_BDTRInitStruct->TIM1_OSSRState | TIM1_BDTRInitStruct->TIM1_OSSIState |
000006  8802              LDRH     r2,[r0,#0]
000008  8843              LDRH     r3,[r0,#2]
00000a  431a              ORRS     r2,r2,r3
00000c  8883              LDRH     r3,[r0,#4]
00000e  431a              ORRS     r2,r2,r3
000010  88c3              LDRH     r3,[r0,#6]
000012  431a              ORRS     r2,r2,r3
000014  8903              LDRH     r3,[r0,#8]
000016  431a              ORRS     r2,r2,r3
000018  8943              LDRH     r3,[r0,#0xa]
00001a  431a              ORRS     r2,r2,r3
00001c  8983              LDRH     r3,[r0,#0xc]
00001e  ea420103          ORR      r1,r2,r3
;;;577                 TIM1_BDTRInitStruct->TIM1_LOCKLevel | TIM1_BDTRInitStruct->TIM1_DeadTime |
;;;578    			 TIM1_BDTRInitStruct->TIM1_Break | TIM1_BDTRInitStruct->TIM1_BreakPolarity |
;;;579                 TIM1_BDTRInitStruct->TIM1_AutomaticOutput;
;;;580    
;;;581      TIM1->BDTR = tmpbdtr;
000022  4a01              LDR      r2,|L6.40|
000024  8011              STRH     r1,[r2,#0]
;;;582    }
000026  4770              BX       lr
;;;583    
                          ENDP

                  |L6.40|
                          DCD      0x40012c44

                          AREA ||i.TIM1_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM1_BDTRStructInit PROC
;;;787    *******************************************************************************/
;;;788    void TIM1_BDTRStructInit(TIM1_BDTRInitTypeDef* TIM1_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;789    {
;;;790      /* Set the default configuration */
;;;791      TIM1_BDTRInitStruct->TIM1_OSSRState = TIM1_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;792      TIM1_BDTRInitStruct->TIM1_OSSIState = TIM1_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;793      TIM1_BDTRInitStruct->TIM1_LOCKLevel = TIM1_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;794      TIM1_BDTRInitStruct->TIM1_DeadTime = TIM1_DeadTime_Reset_Mask;
000008  80c1              STRH     r1,[r0,#6]
;;;795      TIM1_BDTRInitStruct->TIM1_Break = TIM1_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;796      TIM1_BDTRInitStruct->TIM1_BreakPolarity = TIM1_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;797      TIM1_BDTRInitStruct->TIM1_AutomaticOutput = TIM1_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;798    }
000010  4770              BX       lr
;;;799    
                          ENDP


                          AREA ||i.TIM1_CCPreloadControl||, CODE, READONLY, ALIGN=2

                  TIM1_CCPreloadControl PROC
;;;1636   *******************************************************************************/
;;;1637   void TIM1_CCPreloadControl(FunctionalState Newstate)
000000  4901              LDR      r1,|L8.8|
;;;1638   {
;;;1639     /* Check the parameters */
;;;1640     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;1641   
;;;1642     /* Set or Reset the CCPC Bit */
;;;1643     *(vu32 *) CR2_CCPC_BB = (u16)Newstate;
000002  6008              STR      r0,[r1,#0]
;;;1644   }
000004  4770              BX       lr
;;;1645   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42258080

                          AREA ||i.TIM1_CCxCmd||, CODE, READONLY, ALIGN=2

                  TIM1_CCxCmd PROC
;;;2070   *******************************************************************************/
;;;2071   void TIM1_CCxCmd(u16 TIM1_Channel, FunctionalState Newstate)
000000  b910              CBNZ     r0,|L9.8|
;;;2072   {
;;;2073     /* Check the parameters */
;;;2074     assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
;;;2075     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;2076   
;;;2077     if(TIM1_Channel == TIM1_Channel_1)
;;;2078     {
;;;2079       /* Set or Reset the CC1E Bit */
;;;2080       *(vu32 *) CCER_CC1E_BB = (u16)Newstate;  
000002  4a09              LDR      r2,|L9.40|
000004  6011              STR      r1,[r2,#0]
000006  e00e              B        |L9.38|
                  |L9.8|
;;;2081     }
;;;2082     else if(TIM1_Channel == TIM1_Channel_2)
000008  2801              CMP      r0,#1
00000a  d103              BNE      |L9.20|
;;;2083     {
;;;2084       /* Set or Reset the CC2E Bit */
;;;2085       *(vu32 *) CCER_CC2E_BB = (u16)Newstate;
00000c  4a06              LDR      r2,|L9.40|
00000e  3210              ADDS     r2,r2,#0x10
000010  6011              STR      r1,[r2,#0]
000012  e008              B        |L9.38|
                  |L9.20|
;;;2086     }
;;;2087     else if(TIM1_Channel == TIM1_Channel_3)
000014  2802              CMP      r0,#2
000016  d103              BNE      |L9.32|
;;;2088     {
;;;2089       /* Set or Reset the CC3E Bit */
;;;2090       *(vu32 *) CCER_CC3E_BB = (u16)Newstate;
000018  4a03              LDR      r2,|L9.40|
00001a  3220              ADDS     r2,r2,#0x20
00001c  6011              STR      r1,[r2,#0]
00001e  e002              B        |L9.38|
                  |L9.32|
;;;2091     }
;;;2092     else
;;;2093     {
;;;2094       /* Set or Reset the CC4E Bit */
;;;2095       *(vu32 *) CCER_CC4E_BB = (u16)Newstate;
000020  4a01              LDR      r2,|L9.40|
000022  3230              ADDS     r2,r2,#0x30
000024  6011              STR      r1,[r2,#0]
                  |L9.38|
;;;2096     }
;;;2097   }
000026  4770              BX       lr
;;;2098   
                          ENDP

                  |L9.40|
                          DCD      0x42258400

                          AREA ||i.TIM1_CCxNCmd||, CODE, READONLY, ALIGN=2

                  TIM1_CCxNCmd PROC
;;;2112   *******************************************************************************/
;;;2113   void TIM1_CCxNCmd(u16 TIM1_Channel, FunctionalState Newstate)
000000  b910              CBNZ     r0,|L10.8|
;;;2114   {
;;;2115     /* Check the parameters */
;;;2116     assert_param(IS_TIM1_COMPLEMENTARY_CHANNEL(TIM1_Channel));
;;;2117     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;2118   
;;;2119     if(TIM1_Channel == TIM1_Channel_1)
;;;2120     {
;;;2121       /* Set or Reset the CC1NE Bit */
;;;2122       *(vu32 *) CCER_CC1NE_BB = (u16)Newstate;  
000002  4a06              LDR      r2,|L10.28|
000004  6011              STR      r1,[r2,#0]
000006  e008              B        |L10.26|
                  |L10.8|
;;;2123     }
;;;2124     else if(TIM1_Channel == TIM1_Channel_2)
000008  2801              CMP      r0,#1
00000a  d103              BNE      |L10.20|
;;;2125     {
;;;2126       /* Set or Reset the CC2NE Bit */
;;;2127       *(vu32 *) CCER_CC2NE_BB = (u16)Newstate;
00000c  4a03              LDR      r2,|L10.28|
00000e  3210              ADDS     r2,r2,#0x10
000010  6011              STR      r1,[r2,#0]
000012  e002              B        |L10.26|
                  |L10.20|
;;;2128     }
;;;2129     else 
;;;2130     {
;;;2131       /* Set or Reset the CC3NE Bit */
;;;2132       *(vu32 *) CCER_CC3NE_BB = (u16)Newstate;
000014  4a01              LDR      r2,|L10.28|
000016  3220              ADDS     r2,r2,#0x20
000018  6011              STR      r1,[r2,#0]
                  |L10.26|
;;;2133     }
;;;2134   }
00001a  4770              BX       lr
;;;2135   
                          ENDP

                  |L10.28|
                          DCD      0x42258408

                          AREA ||i.TIM1_ClearFlag||, CODE, READONLY, ALIGN=2

                  TIM1_ClearFlag PROC
;;;2600   *******************************************************************************/
;;;2601   void TIM1_ClearFlag(u16 TIM1_FLAG)
000000  4902              LDR      r1,|L11.12|
;;;2602   {
;;;2603     /* Check the parameters */
;;;2604     assert_param(IS_TIM1_CLEAR_FLAG(TIM1_FLAG));
;;;2605   
;;;2606     /* Clear the flags */
;;;2607     TIM1->SR &= (u16)~TIM1_FLAG;
000002  8809              LDRH     r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L11.12|
000008  8011              STRH     r1,[r2,#0]
;;;2608   }
00000a  4770              BX       lr
;;;2609   
                          ENDP

                  |L11.12|
                          DCD      0x40012c10

                          AREA ||i.TIM1_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  TIM1_ClearITPendingBit PROC
;;;2669   *******************************************************************************/
;;;2670   void TIM1_ClearITPendingBit(u16 TIM1_IT)
000000  4902              LDR      r1,|L12.12|
;;;2671   {
;;;2672     /* Check the parameters */
;;;2673     assert_param(IS_TIM1_IT(TIM1_IT));
;;;2674   
;;;2675     /* Clear the IT pending Bit */
;;;2676     TIM1->SR &= (u16)~TIM1_IT;
000002  8809              LDRH     r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L12.12|
000008  8011              STRH     r1,[r2,#0]
;;;2677   }
00000a  4770              BX       lr
;;;2678   
                          ENDP

                  |L12.12|
                          DCD      0x40012c10

                          AREA ||i.TIM1_ClearOC1Ref||, CODE, READONLY, ALIGN=2

                  TIM1_ClearOC1Ref PROC
;;;1820   *******************************************************************************/
;;;1821   void TIM1_ClearOC1Ref(u16 TIM1_OCClear)
000000  4901              LDR      r1,|L13.8|
;;;1822   {
;;;1823     /* Check the parameters */
;;;1824     assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
;;;1825   
;;;1826     /* Set or Reset the OC1CE Bit */
;;;1827     *(vu32 *) CCMR1_OC1CE_BB = (u16)TIM1_OCClear;
000002  6008              STR      r0,[r1,#0]
;;;1828   }
000004  4770              BX       lr
;;;1829   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x4225831c

                          AREA ||i.TIM1_ClearOC2Ref||, CODE, READONLY, ALIGN=2

                  TIM1_ClearOC2Ref PROC
;;;1840   *******************************************************************************/
;;;1841   void TIM1_ClearOC2Ref(u16 TIM1_OCClear)
000000  4901              LDR      r1,|L14.8|
;;;1842   {
;;;1843     /* Check the parameters */
;;;1844     assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
;;;1845   
;;;1846     /* Set or Reset the OC2CE Bit */
;;;1847     *(vu32 *) CCMR1_OC2CE_BB = (u16)TIM1_OCClear;
000002  6008              STR      r0,[r1,#0]
;;;1848   }
000004  4770              BX       lr
;;;1849   
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      0x4225833c

                          AREA ||i.TIM1_ClearOC3Ref||, CODE, READONLY, ALIGN=2

                  TIM1_ClearOC3Ref PROC
;;;1860   *******************************************************************************/
;;;1861   void TIM1_ClearOC3Ref(u16 TIM1_OCClear)
000000  4901              LDR      r1,|L15.8|
;;;1862   {
;;;1863     /* Check the parameters */
;;;1864     assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
;;;1865   
;;;1866     /* Set or Reset the OC3CE Bit */
;;;1867     *(vu32 *) CCMR2_OC3CE_BB = (u16)TIM1_OCClear;
000002  6008              STR      r0,[r1,#0]
;;;1868   }
000004  4770              BX       lr
;;;1869   
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x4225839c

                          AREA ||i.TIM1_ClearOC4Ref||, CODE, READONLY, ALIGN=2

                  TIM1_ClearOC4Ref PROC
;;;1880   *******************************************************************************/
;;;1881   void TIM1_ClearOC4Ref(u16 TIM1_OCClear)
000000  4901              LDR      r1,|L16.8|
;;;1882   {
;;;1883     /* Check the parameters */
;;;1884     assert_param(IS_TIM1_OCCLEAR_STATE(TIM1_OCClear));
;;;1885   
;;;1886     /* Set or Reset the OC4CE Bit */
;;;1887     *(vu32 *) CCMR2_OC4CE_BB = (u16)TIM1_OCClear;
000002  6008              STR      r0,[r1,#0]
;;;1888   }
000004  4770              BX       lr
;;;1889   
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x422583bc

                          AREA ||i.TIM1_Cmd||, CODE, READONLY, ALIGN=2

                  TIM1_Cmd PROC
;;;808    *******************************************************************************/
;;;809    void TIM1_Cmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;810    {
;;;811      /* Check the parameters */
;;;812      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;813    
;;;814      /* set or Reset the CEN Bit */
;;;815      *(vu32 *) CR1_CEN_BB = (u16)NewState;
000002  6008              STR      r0,[r1,#0]
;;;816    }
000004  4770              BX       lr
;;;817    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42258000

                          AREA ||i.TIM1_CounterModeConfig||, CODE, READONLY, ALIGN=2

                  TIM1_CounterModeConfig PROC
;;;1426   *******************************************************************************/
;;;1427   void TIM1_CounterModeConfig(u16 TIM1_CounterMode)
000000  4601              MOV      r1,r0
;;;1428   {
;;;1429     u32 tmpcr1 = 0;
000002  2000              MOVS     r0,#0
;;;1430   
;;;1431     /* Check the parameters */
;;;1432     assert_param(IS_TIM1_COUNTER_MODE(TIM1_CounterMode));
;;;1433   
;;;1434     tmpcr1 = TIM1->CR1;
000004  4a04              LDR      r2,|L18.24|
000006  8810              LDRH     r0,[r2,#0]
;;;1435   
;;;1436     /* Reset the CMS and DIR Bits */
;;;1437     tmpcr1 &= CR1_CounterMode_Mask;
000008  f240329f          MOV      r2,#0x39f
00000c  4010              ANDS     r0,r0,r2
;;;1438   
;;;1439     /* Set the Counter Mode */
;;;1440     tmpcr1 |= TIM1_CounterMode;
00000e  4308              ORRS     r0,r0,r1
;;;1441   
;;;1442     TIM1->CR1 = (u16)tmpcr1;
000010  4b01              LDR      r3,|L18.24|
000012  8018              STRH     r0,[r3,#0]
;;;1443   }
000014  4770              BX       lr
;;;1444   
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0x40012c00

                          AREA ||i.TIM1_CtrlPWMOutputs||, CODE, READONLY, ALIGN=2

                  TIM1_CtrlPWMOutputs PROC
;;;826    *******************************************************************************/
;;;827    void TIM1_CtrlPWMOutputs(FunctionalState Newstate)
000000  4901              LDR      r1,|L19.8|
;;;828    {
;;;829      /* Check the parameters */
;;;830      assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;831    
;;;832      /* Set or Reset the MOE Bit */
;;;833      *(vu32 *) BDTR_MOE_BB = (u16)Newstate;
000002  6008              STR      r0,[r1,#0]
;;;834    }
000004  4770              BX       lr
;;;835    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x422588bc

                          AREA ||i.TIM1_DMACmd||, CODE, READONLY, ALIGN=2

                  TIM1_DMACmd PROC
;;;931    *******************************************************************************/
;;;932    void TIM1_DMACmd(u16 TIM1_DMASource, FunctionalState Newstate)
000000  b510              PUSH     {r4,lr}
;;;933    {
000002  460a              MOV      r2,r1
;;;934      u32 tmpdier = 0;
000004  2100              MOVS     r1,#0
;;;935    
;;;936      /* Check the parameters */
;;;937      assert_param(IS_TIM1_DMA_SOURCE(TIM1_DMASource));
;;;938      assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;939    
;;;940      tmpdier = TIM1->DIER;
000006  4b06              LDR      r3,|L20.32|
000008  8819              LDRH     r1,[r3,#0]
;;;941    
;;;942      if (Newstate == ENABLE)
00000a  2a01              CMP      r2,#1
00000c  d101              BNE      |L20.18|
;;;943      {
;;;944        /* Enable the DMA sources */
;;;945        tmpdier |= TIM1_DMASource;
00000e  4301              ORRS     r1,r1,r0
000010  e002              B        |L20.24|
                  |L20.18|
;;;946      }
;;;947      else
;;;948      {
;;;949        /* Disable the DMA sources */
;;;950        tmpdier &= (u16)~TIM1_DMASource;
000012  43c3              MVNS     r3,r0
000014  b29b              UXTH     r3,r3
000016  4019              ANDS     r1,r1,r3
                  |L20.24|
;;;951      }
;;;952      TIM1->DIER = (u16)tmpdier;
000018  4c01              LDR      r4,|L20.32|
00001a  8021              STRH     r1,[r4,#0]
;;;953    }
00001c  bd10              POP      {r4,pc}
;;;954    
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      0x40012c0c

                          AREA ||i.TIM1_DMAConfig||, CODE, READONLY, ALIGN=2

                  TIM1_DMAConfig PROC
;;;893    *******************************************************************************/
;;;894    void TIM1_DMAConfig(u16 TIM1_DMABase, u16 TIM1_DMABurstLength)
000000  b510              PUSH     {r4,lr}
;;;895    {
;;;896      u32 tmpdcr = 0;
000002  2200              MOVS     r2,#0
;;;897    
;;;898      /* Check the parameters */
;;;899      assert_param(IS_TIM1_DMA_BASE(TIM1_DMABase));
;;;900      assert_param(IS_TIM1_DMA_LENGTH(TIM1_DMABurstLength));
;;;901    
;;;902      tmpdcr = TIM1->DCR;
000004  4b04              LDR      r3,|L21.24|
000006  881a              LDRH     r2,[r3,#0]
;;;903    
;;;904      /* Reset the DBA and the DBL Bits */
;;;905      tmpdcr &= DCR_DMA_Mask;
000008  2200              MOVS     r2,#0
;;;906    
;;;907      /* Set the DMA Base and the DMA Burst Length */
;;;908      tmpdcr |= TIM1_DMABase | TIM1_DMABurstLength;
00000a  ea400301          ORR      r3,r0,r1
00000e  431a              ORRS     r2,r2,r3
;;;909    
;;;910      TIM1->DCR = (u16)tmpdcr;
000010  4c01              LDR      r4,|L21.24|
000012  8022              STRH     r2,[r4,#0]
;;;911    }
000014  bd10              POP      {r4,pc}
;;;912    
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      0x40012c48

                          AREA ||i.TIM1_DeInit||, CODE, READONLY, ALIGN=1

                  TIM1_DeInit PROC
;;;289    *******************************************************************************/
;;;290    void TIM1_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;291    {
;;;292      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000002  2101              MOVS     r1,#1
000004  02c8              LSLS     r0,r1,#11
000006  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;293      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f44f6000          MOV      r0,#0x800
000010  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;294    }
000014  bd10              POP      {r4,pc}
;;;295    
                          ENDP


                          AREA ||i.TIM1_ETRClockMode1Config||, CODE, READONLY, ALIGN=2

                  TIM1_ETRClockMode1Config PROC
;;;986    *******************************************************************************/
;;;987    void TIM1_ETRClockMode1Config(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
000000  b570              PUSH     {r4-r6,lr}
;;;988                                 u16 ExtTRGFilter)
;;;989    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;990      /* Check the parameters */
;;;991      assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
;;;992      assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
;;;993    
;;;994      /* Configure the ETR Clock source */
;;;995      TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIM1_ETRConfig
;;;996    
;;;997      /* Select the External clock mode1 */
;;;998      TIM1->SMCR &= SMCR_SMS_Mask;
000012  480c              LDR      r0,|L23.68|
000014  8800              LDRH     r0,[r0,#0]
000016  f64f71f0          MOV      r1,#0xfff0
00001a  4008              ANDS     r0,r0,r1
00001c  4909              LDR      r1,|L23.68|
00001e  8008              STRH     r0,[r1,#0]
;;;999      TIM1->SMCR |= TIM1_SlaveMode_External1;
000020  4608              MOV      r0,r1
000022  8800              LDRH     r0,[r0,#0]
000024  f0400007          ORR      r0,r0,#7
000028  8008              STRH     r0,[r1,#0]
;;;1000     
;;;1001     /* Select the Trigger selection : ETRF */
;;;1002     TIM1->SMCR &= SMCR_TS_Mask;
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]
00002e  f64f7187          MOV      r1,#0xff87
000032  4008              ANDS     r0,r0,r1
000034  4903              LDR      r1,|L23.68|
000036  8008              STRH     r0,[r1,#0]
;;;1003     TIM1->SMCR |= TIM1_TS_ETRF;
000038  4608              MOV      r0,r1
00003a  8800              LDRH     r0,[r0,#0]
00003c  f0400070          ORR      r0,r0,#0x70
000040  8008              STRH     r0,[r1,#0]
;;;1004   }
000042  bd70              POP      {r4-r6,pc}
;;;1005   
                          ENDP

                  |L23.68|
                          DCD      0x40012c08

                          AREA ||i.TIM1_ETRClockMode2Config||, CODE, READONLY, ALIGN=2

                  TIM1_ETRClockMode2Config PROC
;;;1024   *******************************************************************************/
;;;1025   void TIM1_ETRClockMode2Config(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
000000  b570              PUSH     {r4-r6,lr}
;;;1026                                u16 ExtTRGFilter)
;;;1027   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1028     /* Check the parameters */
;;;1029     assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
;;;1030     assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
;;;1031   
;;;1032     /* Configure the ETR Clock source */
;;;1033     TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIM1_ETRConfig
;;;1034   
;;;1035     /* Enable the External clock mode2 */
;;;1036     *(vu32 *) SMCR_ECE_BB = SMCR_ECE_Set;
000012  2001              MOVS     r0,#1
000014  4901              LDR      r1,|L24.28|
000016  6008              STR      r0,[r1,#0]
;;;1037   }
000018  bd70              POP      {r4-r6,pc}
;;;1038   
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      0x42258138

                          AREA ||i.TIM1_ETRConfig||, CODE, READONLY, ALIGN=2

                  TIM1_ETRConfig PROC
;;;1057   *******************************************************************************/
;;;1058   void TIM1_ETRConfig(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity,
000000  b530              PUSH     {r4,r5,lr}
;;;1059                       u16 ExtTRGFilter)
;;;1060   {
000002  4603              MOV      r3,r0
;;;1061     u32 tmpsmcr = 0;
000004  2000              MOVS     r0,#0
;;;1062   
;;;1063     tmpsmcr = TIM1->SMCR;
000006  4c08              LDR      r4,|L25.40|
000008  8820              LDRH     r0,[r4,#0]
;;;1064   
;;;1065     /* Set the Prescaler, the Filter value and the Polarity */
;;;1066     tmpsmcr &= SMCR_ETR_Mask;
00000a  f24404f7          MOV      r4,#0x40f7
00000e  4020              ANDS     r0,r0,r4
;;;1067     tmpsmcr |= TIM1_ExtTRGPrescaler | TIM1_ExtTRGPolarity | (u16)((u16)ExtTRGFilter << 8);
000010  ea430401          ORR      r4,r3,r1
000014  f64f75ff          MOV      r5,#0xffff
000018  ea052502          AND      r5,r5,r2,LSL #8
00001c  432c              ORRS     r4,r4,r5
00001e  4320              ORRS     r0,r0,r4
;;;1068   
;;;1069     TIM1->SMCR = (u16)tmpsmcr;
000020  4d01              LDR      r5,|L25.40|
000022  8028              STRH     r0,[r5,#0]
;;;1070   }
000024  bd30              POP      {r4,r5,pc}
;;;1071   
                          ENDP

000026  0000              DCW      0x0000
                  |L25.40|
                          DCD      0x40012c08

                          AREA ||i.TIM1_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=2

                  TIM1_EncoderInterfaceConfig PROC
;;;1356   *******************************************************************************/
;;;1357   void TIM1_EncoderInterfaceConfig(u16 TIM1_EncoderMode, u16 TIM1_IC1Polarity,
000000  b570              PUSH     {r4-r6,lr}
;;;1358                                   u16 TIM1_IC2Polarity)
;;;1359   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1360     u32 tmpsmcr = 0;
000006  2100              MOVS     r1,#0
;;;1361     u32 tmpccmr1 = 0;
000008  2000              MOVS     r0,#0
;;;1362   
;;;1363     /* Check the parameters */
;;;1364     assert_param(IS_TIM1_ENCODER_MODE(TIM1_EncoderMode));
;;;1365     assert_param(IS_TIM1_IC_POLARITY(TIM1_IC1Polarity));
;;;1366     assert_param(IS_TIM1_IC_POLARITY(TIM1_IC2Polarity));
;;;1367   
;;;1368     tmpsmcr = TIM1->SMCR;
00000a  4d0d              LDR      r5,|L26.64|
00000c  8829              LDRH     r1,[r5,#0]
;;;1369     tmpccmr1 = TIM1->CCMR1;
00000e  4d0c              LDR      r5,|L26.64|
000010  3510              ADDS     r5,r5,#0x10
000012  8828              LDRH     r0,[r5,#0]
;;;1370   
;;;1371     /* Set the encoder Mode */
;;;1372     tmpsmcr &= SMCR_SMS_Mask;
000014  f64f75f0          MOV      r5,#0xfff0
000018  4029              ANDS     r1,r1,r5
;;;1373     tmpsmcr |= TIM1_EncoderMode;
00001a  4319              ORRS     r1,r1,r3
;;;1374   
;;;1375     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1376     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
00001c  f64f45fc          MOV      r5,#0xfcfc
000020  4028              ANDS     r0,r0,r5
;;;1377     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
000022  f2401501          MOV      r5,#0x101
000026  4328              ORRS     r0,r0,r5
;;;1378   
;;;1379     /* Set the TI1 and the TI2 Polarities */
;;;1380     *(vu32 *) CCER_CC1P_BB = TIM1_IC1Polarity;
000028  4d06              LDR      r5,|L26.68|
00002a  602c              STR      r4,[r5,#0]
;;;1381     *(vu32 *) CCER_CC2P_BB = TIM1_IC2Polarity;
00002c  4d05              LDR      r5,|L26.68|
00002e  3510              ADDS     r5,r5,#0x10
000030  602a              STR      r2,[r5,#0]
;;;1382   
;;;1383     TIM1->SMCR = (u16)tmpsmcr;
000032  4e03              LDR      r6,|L26.64|
000034  8031              STRH     r1,[r6,#0]
;;;1384   
;;;1385     TIM1->CCMR1 = (u16)tmpccmr1;
000036  4d02              LDR      r5,|L26.64|
000038  3510              ADDS     r5,r5,#0x10
00003a  8028              STRH     r0,[r5,#0]
;;;1386   }
00003c  bd70              POP      {r4-r6,pc}
;;;1387   
                          ENDP

00003e  0000              DCW      0x0000
                  |L26.64|
                          DCD      0x40012c08
                  |L26.68|
                          DCD      0x42258404

                          AREA ||i.TIM1_ForcedOC1Config||, CODE, READONLY, ALIGN=2

                  TIM1_ForcedOC1Config PROC
;;;1458   *******************************************************************************/
;;;1459   void TIM1_ForcedOC1Config(u16 TIM1_ForcedAction)
000000  4601              MOV      r1,r0
;;;1460   {
;;;1461     u32 tmpccmr1 = 0;
000002  2000              MOVS     r0,#0
;;;1462   
;;;1463     /* Check the parameters */
;;;1464     assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
;;;1465   
;;;1466     tmpccmr1 = TIM1->CCMR1;
000004  4a04              LDR      r2,|L27.24|
000006  8810              LDRH     r0,[r2,#0]
;;;1467   
;;;1468     /* Reset the OCM Bits */
;;;1469     tmpccmr1 &= CCMR_OCM13_Mask;
000008  f647720f          MOV      r2,#0x7f0f
00000c  4010              ANDS     r0,r0,r2
;;;1470   
;;;1471     /* Configure The Forced output Mode */
;;;1472     tmpccmr1 |= TIM1_ForcedAction;
00000e  4308              ORRS     r0,r0,r1
;;;1473   
;;;1474     TIM1->CCMR1 = (u16)tmpccmr1;
000010  4b01              LDR      r3,|L27.24|
000012  8018              STRH     r0,[r3,#0]
;;;1475   }
000014  4770              BX       lr
;;;1476   
                          ENDP

000016  0000              DCW      0x0000
                  |L27.24|
                          DCD      0x40012c18

                          AREA ||i.TIM1_ForcedOC2Config||, CODE, READONLY, ALIGN=2

                  TIM1_ForcedOC2Config PROC
;;;1490   *******************************************************************************/
;;;1491   void TIM1_ForcedOC2Config(u16 TIM1_ForcedAction)
000000  4601              MOV      r1,r0
;;;1492   {
;;;1493     u32 tmpccmr1 = 0;
000002  2000              MOVS     r0,#0
;;;1494   
;;;1495     /* Check the parameters */
;;;1496     assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
;;;1497   
;;;1498     tmpccmr1 = TIM1->CCMR1;
000004  4a04              LDR      r2,|L28.24|
000006  8810              LDRH     r0,[r2,#0]
;;;1499   
;;;1500     /* Reset the OCM Bits */
;;;1501     tmpccmr1 &= CCMR_OCM24_Mask;
000008  f640727f          MOV      r2,#0xf7f
00000c  4010              ANDS     r0,r0,r2
;;;1502   
;;;1503     /* Configure The Forced output Mode */
;;;1504     tmpccmr1 |= (u32)TIM1_ForcedAction << 8;
00000e  ea402001          ORR      r0,r0,r1,LSL #8
;;;1505   
;;;1506     TIM1->CCMR1 = (u16)tmpccmr1;
000012  4b01              LDR      r3,|L28.24|
000014  8018              STRH     r0,[r3,#0]
;;;1507   }
000016  4770              BX       lr
;;;1508   
                          ENDP

                  |L28.24|
                          DCD      0x40012c18

                          AREA ||i.TIM1_ForcedOC3Config||, CODE, READONLY, ALIGN=2

                  TIM1_ForcedOC3Config PROC
;;;1522   *******************************************************************************/
;;;1523   void TIM1_ForcedOC3Config(u16 TIM1_ForcedAction)
000000  4601              MOV      r1,r0
;;;1524   {
;;;1525     u32 tmpccmr2 = 0;
000002  2000              MOVS     r0,#0
;;;1526   
;;;1527     /* Check the parameters */
;;;1528     assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
;;;1529   
;;;1530     tmpccmr2 = TIM1->CCMR2;
000004  4a04              LDR      r2,|L29.24|
000006  8810              LDRH     r0,[r2,#0]
;;;1531   
;;;1532     /* Reset the OCM Bits */
;;;1533     tmpccmr2 &= CCMR_OCM13_Mask;
000008  f647720f          MOV      r2,#0x7f0f
00000c  4010              ANDS     r0,r0,r2
;;;1534   
;;;1535     /* Configure The Forced output Mode */
;;;1536     tmpccmr2 |= TIM1_ForcedAction;
00000e  4308              ORRS     r0,r0,r1
;;;1537   
;;;1538     TIM1->CCMR2 = (u16)tmpccmr2;
000010  4b01              LDR      r3,|L29.24|
000012  8018              STRH     r0,[r3,#0]
;;;1539   }
000014  4770              BX       lr
;;;1540   
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40012c1c

                          AREA ||i.TIM1_ForcedOC4Config||, CODE, READONLY, ALIGN=2

                  TIM1_ForcedOC4Config PROC
;;;1554   *******************************************************************************/
;;;1555   void TIM1_ForcedOC4Config(u16 TIM1_ForcedAction)
000000  4601              MOV      r1,r0
;;;1556   {
;;;1557     u32 tmpccmr2 = 0;
000002  2000              MOVS     r0,#0
;;;1558   
;;;1559     /* Check the parameters */
;;;1560     assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
;;;1561   
;;;1562     tmpccmr2 = TIM1->CCMR1;
000004  4a06              LDR      r2,|L30.32|
000006  8810              LDRH     r0,[r2,#0]
;;;1563   
;;;1564     /* Reset the OCM Bits */
;;;1565     tmpccmr2 &= CCMR_OCM24_Mask;
000008  f640727f          MOV      r2,#0xf7f
00000c  4010              ANDS     r0,r0,r2
;;;1566   
;;;1567     /* Configure The Forced output Mode */
;;;1568     tmpccmr2 |= (u16)((u16)TIM1_ForcedAction << 8);
00000e  f64f72ff          MOV      r2,#0xffff
000012  ea022201          AND      r2,r2,r1,LSL #8
000016  4310              ORRS     r0,r0,r2
;;;1569   
;;;1570     TIM1->CCMR2 = (u16)tmpccmr2;
000018  4a01              LDR      r2,|L30.32|
00001a  1d12              ADDS     r2,r2,#4
00001c  8010              STRH     r0,[r2,#0]
;;;1571   }
00001e  4770              BX       lr
;;;1572   
                          ENDP

                  |L30.32|
                          DCD      0x40012c18

                          AREA ||i.TIM1_GenerateEvent||, CODE, READONLY, ALIGN=2

                  TIM1_GenerateEvent PROC
;;;1906   *******************************************************************************/
;;;1907   void TIM1_GenerateEvent(u16 TIM1_EventSource)
000000  4902              LDR      r1,|L31.12|
;;;1908   {
;;;1909     /* Check the parameters */
;;;1910     assert_param(IS_TIM1_EVENT_SOURCE(TIM1_EventSource));
;;;1911   
;;;1912     /* Set the event sources */
;;;1913     TIM1->EGR |= TIM1_EventSource;
000002  8809              LDRH     r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L31.12|
000008  8011              STRH     r1,[r2,#0]
;;;1914   }
00000a  4770              BX       lr
;;;1915   
                          ENDP

                  |L31.12|
                          DCD      0x40012c14

                          AREA ||i.TIM1_GetCapture1||, CODE, READONLY, ALIGN=2

                  TIM1_GetCapture1 PROC
;;;2464   *******************************************************************************/
;;;2465   u16 TIM1_GetCapture1(void)
000000  4801              LDR      r0,|L32.8|
;;;2466   {
;;;2467     /* Get the Capture 1 Register value */
;;;2468     return TIM1->CCR1;
000002  8800              LDRH     r0,[r0,#0]
;;;2469   }
000004  4770              BX       lr
;;;2470   
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x40012c34

                          AREA ||i.TIM1_GetCapture2||, CODE, READONLY, ALIGN=2

                  TIM1_GetCapture2 PROC
;;;2478   *******************************************************************************/
;;;2479   u16 TIM1_GetCapture2(void)
000000  4801              LDR      r0,|L33.8|
;;;2480   {
;;;2481     /* Get the Capture 2 Register value */
;;;2482     return TIM1->CCR2;
000002  8800              LDRH     r0,[r0,#0]
;;;2483   }
000004  4770              BX       lr
;;;2484   
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x40012c38

                          AREA ||i.TIM1_GetCapture3||, CODE, READONLY, ALIGN=2

                  TIM1_GetCapture3 PROC
;;;2492   *******************************************************************************/
;;;2493   u16 TIM1_GetCapture3(void)
000000  4801              LDR      r0,|L34.8|
;;;2494   {
;;;2495     /* Get the Capture 3 Register value */
;;;2496     return TIM1->CCR3;
000002  8800              LDRH     r0,[r0,#0]
;;;2497   }
000004  4770              BX       lr
;;;2498   
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      0x40012c3c

                          AREA ||i.TIM1_GetCapture4||, CODE, READONLY, ALIGN=2

                  TIM1_GetCapture4 PROC
;;;2506   *******************************************************************************/
;;;2507   u16 TIM1_GetCapture4(void)
000000  4801              LDR      r0,|L35.8|
;;;2508   {
;;;2509     /* Get the Capture 4 Register value */
;;;2510     return TIM1->CCR4;
000002  8800              LDRH     r0,[r0,#0]
;;;2511   }
000004  4770              BX       lr
;;;2512   
                          ENDP

000006  0000              DCW      0x0000
                  |L35.8|
                          DCD      0x40012c40

                          AREA ||i.TIM1_GetCounter||, CODE, READONLY, ALIGN=2

                  TIM1_GetCounter PROC
;;;2520   *******************************************************************************/
;;;2521   u16 TIM1_GetCounter(void)
000000  4801              LDR      r0,|L36.8|
;;;2522   {
;;;2523     /* Get the Counter Register value */
;;;2524     return TIM1->CNT;
000002  8800              LDRH     r0,[r0,#0]
;;;2525   }
000004  4770              BX       lr
;;;2526   
                          ENDP

000006  0000              DCW      0x0000
                  |L36.8|
                          DCD      0x40012c24

                          AREA ||i.TIM1_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  TIM1_GetFlagStatus PROC
;;;2561   *******************************************************************************/
;;;2562   FlagStatus TIM1_GetFlagStatus(u16 TIM1_FLAG)
000000  4601              MOV      r1,r0
;;;2563   {
;;;2564     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;2565   
;;;2566     /* Check the parameters */
;;;2567     assert_param(IS_TIM1_GET_FLAG(TIM1_FLAG));
;;;2568   
;;;2569     if ((TIM1->SR & TIM1_FLAG) != (u16)RESET )
000004  4a03              LDR      r2,|L37.20|
000006  8812              LDRH     r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L37.16|
;;;2570     {
;;;2571       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L37.18|
                  |L37.16|
;;;2572     }
;;;2573     else
;;;2574     {
;;;2575       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L37.18|
;;;2576     }
;;;2577     return bitstatus;
;;;2578   }
000012  4770              BX       lr
;;;2579   
                          ENDP

                  |L37.20|
                          DCD      0x40012c10

                          AREA ||i.TIM1_GetITStatus||, CODE, READONLY, ALIGN=2

                  TIM1_GetITStatus PROC
;;;2627   *******************************************************************************/
;;;2628   ITStatus TIM1_GetITStatus(u16 TIM1_IT)
000000  b510              PUSH     {r4,lr}
;;;2629   {
000002  4601              MOV      r1,r0
;;;2630     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2631     
;;;2632     u16 TIM1_itStatus = 0x0, TIM1_itEnable = 0x0;
000006  2200              MOVS     r2,#0
000008  2300              MOVS     r3,#0
;;;2633   
;;;2634     /* Check the parameters */
;;;2635     assert_param(IS_TIM1_GET_IT(TIM1_IT));
;;;2636     
;;;2637     TIM1_itStatus = TIM1->SR & TIM1_IT;
00000a  4c07              LDR      r4,|L38.40|
00000c  8824              LDRH     r4,[r4,#0]
00000e  ea040201          AND      r2,r4,r1
;;;2638     
;;;2639     TIM1_itEnable = TIM1->DIER & TIM1_IT;
000012  4c05              LDR      r4,|L38.40|
000014  1f24              SUBS     r4,r4,#4
000016  8824              LDRH     r4,[r4,#0]
000018  ea040301          AND      r3,r4,r1
;;;2640   
;;;2641     if ((TIM1_itStatus != (u16)RESET ) && (TIM1_itEnable != (u16)RESET ))
00001c  b112              CBZ      r2,|L38.36|
00001e  b10b              CBZ      r3,|L38.36|
;;;2642     {
;;;2643       bitstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L38.38|
                  |L38.36|
;;;2644     }
;;;2645     else
;;;2646     {
;;;2647       bitstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L38.38|
;;;2648     }
;;;2649     return bitstatus;
;;;2650   }
000026  bd10              POP      {r4,pc}
;;;2651   
                          ENDP

                  |L38.40|
                          DCD      0x40012c10

                          AREA ||i.TIM1_GetPrescaler||, CODE, READONLY, ALIGN=2

                  TIM1_GetPrescaler PROC
;;;2534   *******************************************************************************/
;;;2535   u16 TIM1_GetPrescaler(void)
000000  4801              LDR      r0,|L39.8|
;;;2536   {
;;;2537     /* Get the Prescaler Register value */
;;;2538     return TIM1->PSC;
000002  8800              LDRH     r0,[r0,#0]
;;;2539   }
000004  4770              BX       lr
;;;2540   
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      0x40012c28

                          AREA ||i.TIM1_ICInit||, CODE, READONLY, ALIGN=1

                  TIM1_ICInit PROC
;;;594    *******************************************************************************/
;;;595    void TIM1_ICInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct)
000000  b510              PUSH     {r4,lr}
;;;596    {
000002  4604              MOV      r4,r0
;;;597      /* Check the parameters */
;;;598      assert_param(IS_TIM1_CHANNEL(TIM1_ICInitStruct->TIM1_Channel));
;;;599      assert_param(IS_TIM1_IC_POLARITY(TIM1_ICInitStruct->TIM1_ICPolarity));
;;;600      assert_param(IS_TIM1_IC_SELECTION(TIM1_ICInitStruct->TIM1_ICSelection));
;;;601      assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICInitStruct->TIM1_ICPrescaler));
;;;602      assert_param(IS_TIM1_IC_FILTER(TIM1_ICInitStruct->TIM1_ICFilter));
;;;603    
;;;604      if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_1)
000004  8820              LDRH     r0,[r4,#0]
000006  b940              CBNZ     r0,|L40.26|
;;;605      {
;;;606        /* TI1 Configuration */
;;;607        TI1_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
000008  7a22              LDRB     r2,[r4,#8]
00000a  88a1              LDRH     r1,[r4,#4]
00000c  8860              LDRH     r0,[r4,#2]
00000e  f7fffffe          BL       TI1_Config
;;;608                   TIM1_ICInitStruct->TIM1_ICSelection,
;;;609                   TIM1_ICInitStruct->TIM1_ICFilter);
;;;610    
;;;611        /* Set the Input Capture Prescaler value */
;;;612        TIM1_SetIC1Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
000012  88e0              LDRH     r0,[r4,#6]
000014  f7fffffe          BL       TIM1_SetIC1Prescaler
000018  e01f              B        |L40.90|
                  |L40.26|
;;;613      }
;;;614      else if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_2)
00001a  8820              LDRH     r0,[r4,#0]
00001c  2801              CMP      r0,#1
00001e  d108              BNE      |L40.50|
;;;615      {
;;;616        /* TI2 Configuration */
;;;617        TI2_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
000020  7a22              LDRB     r2,[r4,#8]
000022  88a1              LDRH     r1,[r4,#4]
000024  8860              LDRH     r0,[r4,#2]
000026  f7fffffe          BL       TI2_Config
;;;618                   TIM1_ICInitStruct->TIM1_ICSelection,
;;;619                   TIM1_ICInitStruct->TIM1_ICFilter);
;;;620    
;;;621        /* Set the Input Capture Prescaler value */
;;;622        TIM1_SetIC2Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
00002a  88e0              LDRH     r0,[r4,#6]
00002c  f7fffffe          BL       TIM1_SetIC2Prescaler
000030  e013              B        |L40.90|
                  |L40.50|
;;;623      }
;;;624      else if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_3)
000032  8820              LDRH     r0,[r4,#0]
000034  2802              CMP      r0,#2
000036  d108              BNE      |L40.74|
;;;625      {
;;;626        /* TI3 Configuration */
;;;627        TI3_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
000038  7a22              LDRB     r2,[r4,#8]
00003a  88a1              LDRH     r1,[r4,#4]
00003c  8860              LDRH     r0,[r4,#2]
00003e  f7fffffe          BL       TI3_Config
;;;628                   TIM1_ICInitStruct->TIM1_ICSelection,
;;;629                   TIM1_ICInitStruct->TIM1_ICFilter);
;;;630    
;;;631        /* Set the Input Capture Prescaler value */
;;;632        TIM1_SetIC3Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
000042  88e0              LDRH     r0,[r4,#6]
000044  f7fffffe          BL       TIM1_SetIC3Prescaler
000048  e007              B        |L40.90|
                  |L40.74|
;;;633      }
;;;634      else
;;;635      {
;;;636        /* TI4 Configuration */
;;;637        TI4_Config(TIM1_ICInitStruct->TIM1_ICPolarity,
00004a  7a22              LDRB     r2,[r4,#8]
00004c  88a1              LDRH     r1,[r4,#4]
00004e  8860              LDRH     r0,[r4,#2]
000050  f7fffffe          BL       TI4_Config
;;;638                   TIM1_ICInitStruct->TIM1_ICSelection,
;;;639                   TIM1_ICInitStruct->TIM1_ICFilter);
;;;640    
;;;641        /* Set the Input Capture Prescaler value */
;;;642        TIM1_SetIC4Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
000054  88e0              LDRH     r0,[r4,#6]
000056  f7fffffe          BL       TIM1_SetIC4Prescaler
                  |L40.90|
;;;643      }
;;;644    }
00005a  bd10              POP      {r4,pc}
;;;645    
                          ENDP


                          AREA ||i.TIM1_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM1_ICStructInit PROC
;;;749    *******************************************************************************/
;;;750    void TIM1_ICStructInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;751    {
;;;752      /* Set the default configuration */
;;;753      TIM1_ICInitStruct->TIM1_Channel = TIM1_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;754      TIM1_ICInitStruct->TIM1_ICSelection = TIM1_ICSelection_DirectTI;
000004  2101              MOVS     r1,#1
000006  8081              STRH     r1,[r0,#4]
;;;755      TIM1_ICInitStruct->TIM1_ICPolarity = TIM1_ICPolarity_Rising;
000008  2100              MOVS     r1,#0
00000a  8041              STRH     r1,[r0,#2]
;;;756      TIM1_ICInitStruct->TIM1_ICPrescaler = TIM1_ICPSC_DIV1;
00000c  80c1              STRH     r1,[r0,#6]
;;;757      TIM1_ICInitStruct->TIM1_ICFilter = TIM1_ICFilter_Mask;
00000e  7201              STRB     r1,[r0,#8]
;;;758    }
000010  4770              BX       lr
;;;759    
                          ENDP


                          AREA ||i.TIM1_ITConfig||, CODE, READONLY, ALIGN=2

                  TIM1_ITConfig PROC
;;;856    *******************************************************************************/
;;;857    void TIM1_ITConfig(u16 TIM1_IT, FunctionalState NewState)
000000  2901              CMP      r1,#1
;;;858    {
;;;859      /* Check the parameters */
;;;860      assert_param(IS_TIM1_IT(TIM1_IT));
;;;861      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;862    
;;;863      if (NewState == ENABLE)
000002  d105              BNE      |L42.16|
;;;864      {
;;;865        /* Enable the Interrupt sources */
;;;866        TIM1->DIER |= TIM1_IT;
000004  4a05              LDR      r2,|L42.28|
000006  8812              LDRH     r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L42.28|
00000c  801a              STRH     r2,[r3,#0]
00000e  e004              B        |L42.26|
                  |L42.16|
;;;867      }
;;;868      else
;;;869      {
;;;870        /* Disable the Interrupt sources */
;;;871        TIM1->DIER &= (u16)~TIM1_IT;
000010  4a02              LDR      r2,|L42.28|
000012  8812              LDRH     r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L42.28|
000018  801a              STRH     r2,[r3,#0]
                  |L42.26|
;;;872      }
;;;873    }
00001a  4770              BX       lr
;;;874    
                          ENDP

                  |L42.28|
                          DCD      0x40012c0c

                          AREA ||i.TIM1_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=2

                  TIM1_ITRxExternalClockConfig PROC
;;;1084   *******************************************************************************/
;;;1085   void TIM1_ITRxExternalClockConfig(u16 TIM1_InputTriggerSource)
000000  b510              PUSH     {r4,lr}
;;;1086   {
000002  4604              MOV      r4,r0
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_TIM1_INTERNAL_TRIGGER_SELECTION(TIM1_InputTriggerSource));
;;;1089     
;;;1090     /* Select the Internal Trigger */
;;;1091     TIM1_SelectInputTrigger(TIM1_InputTriggerSource);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       TIM1_SelectInputTrigger
;;;1092   
;;;1093     /* Select the External clock mode1 */
;;;1094     TIM1->SMCR |= TIM1_SlaveMode_External1;
00000a  4803              LDR      r0,|L43.24|
00000c  8800              LDRH     r0,[r0,#0]
00000e  f0400007          ORR      r0,r0,#7
000012  4901              LDR      r1,|L43.24|
000014  8008              STRH     r0,[r1,#0]
;;;1095   }
000016  bd10              POP      {r4,pc}
;;;1096   
                          ENDP

                  |L43.24|
                          DCD      0x40012c08

                          AREA ||i.TIM1_InternalClockConfig||, CODE, READONLY, ALIGN=2

                  TIM1_InternalClockConfig PROC
;;;962    *******************************************************************************/
;;;963    void TIM1_InternalClockConfig(void)
000000  4803              LDR      r0,|L44.16|
;;;964    {
;;;965      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;966      TIM1->SMCR &=  SMCR_SMS_Mask;
000002  8800              LDRH     r0,[r0,#0]
000004  f64f71f0          MOV      r1,#0xfff0
000008  4008              ANDS     r0,r0,r1
00000a  4901              LDR      r1,|L44.16|
00000c  8008              STRH     r0,[r1,#0]
;;;967    }
00000e  4770              BX       lr
;;;968    /*******************************************************************************
                          ENDP

                  |L44.16|
                          DCD      0x40012c08

                          AREA ||i.TIM1_OC1FastConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC1FastConfig PROC
;;;1740   *******************************************************************************/
;;;1741   void TIM1_OC1FastConfig(u16 TIM1_OCFast)
000000  4901              LDR      r1,|L45.8|
;;;1742   {
;;;1743     /* Check the parameters */
;;;1744     assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
;;;1745   
;;;1746     /* Set or Reset the OC1FE Bit */
;;;1747     *(vu32 *) CCMR1_OC1FE_BB = (u16)TIM1_OCFast;
000002  6008              STR      r0,[r1,#0]
;;;1748   }
000004  4770              BX       lr
;;;1749   
                          ENDP

000006  0000              DCW      0x0000
                  |L45.8|
                          DCD      0x42258308

                          AREA ||i.TIM1_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM1_OC1Init PROC
;;;337    *******************************************************************************/
;;;338    void TIM1_OC1Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;339    {
;;;340      u16 tmpccmr = 0;
;;;341    
;;;342      /* Check the parameters */
;;;343      assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
;;;344      assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
;;;345      assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OCInitStruct->TIM1_OutputNState));
;;;346      assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
;;;347      assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCInitStruct->TIM1_OCNPolarity));
;;;348      assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
;;;349      assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCInitStruct->TIM1_OCNIdleState)); 
;;;350    
;;;351      tmpccmr = TIM1->CCMR1;
000002  4a11              LDR      r2,|L46.72|
000004  8811              LDRH     r1,[r2,#0]
;;;352    
;;;353      /* Disable the Channel 1: Reset the CCE Bit */
;;;354      *(vu32 *) CCER_CC1E_BB = CCER_CCE_Reset;
000006  2200              MOVS     r2,#0
000008  4b10              LDR      r3,|L46.76|
00000a  601a              STR      r2,[r3,#0]
;;;355    
;;;356      /* Reset the Output Compare Bits */
;;;357       tmpccmr &= OC13Mode_Mask;
00000c  f401417f          AND      r1,r1,#0xff00
;;;358    
;;;359      /* Set the Ouput Compare Mode */
;;;360      tmpccmr |= TIM1_OCInitStruct->TIM1_OCMode;
000010  8802              LDRH     r2,[r0,#0]
000012  4311              ORRS     r1,r1,r2
;;;361    
;;;362      TIM1->CCMR1 = tmpccmr;
000014  4a0c              LDR      r2,|L46.72|
000016  8011              STRH     r1,[r2,#0]
;;;363    
;;;364      /* Set the Output State */
;;;365      *(vu32 *) CCER_CC1E_BB = TIM1_OCInitStruct->TIM1_OutputState;
000018  8842              LDRH     r2,[r0,#2]
00001a  601a              STR      r2,[r3,#0]
;;;366    
;;;367      /* Set the Output N State */
;;;368      *(vu32 *) CCER_CC1NE_BB = TIM1_OCInitStruct->TIM1_OutputNState;
00001c  8882              LDRH     r2,[r0,#4]
00001e  4b0b              LDR      r3,|L46.76|
000020  3308              ADDS     r3,r3,#8
000022  601a              STR      r2,[r3,#0]
;;;369    
;;;370      /* Set the Output Polarity */
;;;371      *(vu32 *) CCER_CC1P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
000024  8902              LDRH     r2,[r0,#8]
000026  1f1b              SUBS     r3,r3,#4
000028  601a              STR      r2,[r3,#0]
;;;372    
;;;373      /* Set the Output N Polarity */
;;;374      *(vu32 *) CCER_CC1NP_BB = TIM1_OCInitStruct->TIM1_OCNPolarity;
00002a  8942              LDRH     r2,[r0,#0xa]
00002c  4b07              LDR      r3,|L46.76|
00002e  330c              ADDS     r3,r3,#0xc
000030  601a              STR      r2,[r3,#0]
;;;375    
;;;376      /* Set the Output Idle state */
;;;377      *(vu32 *) CR2_OIS1_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
000032  8982              LDRH     r2,[r0,#0xc]
000034  4b06              LDR      r3,|L46.80|
000036  601a              STR      r2,[r3,#0]
;;;378    
;;;379      /* Set the Output N Idle state */
;;;380      *(vu32 *) CR2_OIS1N_BB = TIM1_OCInitStruct->TIM1_OCNIdleState;
000038  89c2              LDRH     r2,[r0,#0xe]
00003a  1d1b              ADDS     r3,r3,#4
00003c  601a              STR      r2,[r3,#0]
;;;381    
;;;382      /* Set the Pulse value */
;;;383      TIM1->CCR1 = TIM1_OCInitStruct->TIM1_Pulse;
00003e  88c2              LDRH     r2,[r0,#6]
000040  4b01              LDR      r3,|L46.72|
000042  331c              ADDS     r3,r3,#0x1c
000044  801a              STRH     r2,[r3,#0]
;;;384    }
000046  4770              BX       lr
;;;385    
                          ENDP

                  |L46.72|
                          DCD      0x40012c18
                  |L46.76|
                          DCD      0x42258400
                  |L46.80|
                          DCD      0x422580a0

                          AREA ||i.TIM1_OC1NPolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC1NPolarityConfig PROC
;;;1946   *******************************************************************************/
;;;1947   void TIM1_OC1NPolarityConfig(u16 TIM1_OCNPolarity)
000000  4901              LDR      r1,|L47.8|
;;;1948   {
;;;1949     /* Check the parameters */
;;;1950     assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
;;;1951   
;;;1952     /* Set or Reset the CC3P Bit */
;;;1953     *(vu32 *) CCER_CC1NP_BB = (u16)TIM1_OCNPolarity;
000002  6008              STR      r0,[r1,#0]
;;;1954   }
000004  4770              BX       lr
;;;1955   
                          ENDP

000006  0000              DCW      0x0000
                  |L47.8|
                          DCD      0x4225840c

                          AREA ||i.TIM1_OC1PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC1PolarityConfig PROC
;;;1926   *******************************************************************************/
;;;1927   void TIM1_OC1PolarityConfig(u16 TIM1_OCPolarity)
000000  4901              LDR      r1,|L48.8|
;;;1928   {
;;;1929     /* Check the parameters */
;;;1930     assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
;;;1931   
;;;1932     /* Set or Reset the CC1P Bit */
;;;1933     *(vu32 *) CCER_CC1P_BB = (u16)TIM1_OCPolarity;
000002  6008              STR      r0,[r1,#0]
;;;1934   }
000004  4770              BX       lr
;;;1935   
                          ENDP

000006  0000              DCW      0x0000
                  |L48.8|
                          DCD      0x42258404

                          AREA ||i.TIM1_OC1PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC1PreloadConfig PROC
;;;1657   *******************************************************************************/
;;;1658   void TIM1_OC1PreloadConfig(u16 TIM1_OCPreload)
000000  4901              LDR      r1,|L49.8|
;;;1659   {
;;;1660     /* Check the parameters */
;;;1661     assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
;;;1662   
;;;1663     /* Set or Reset the OC1PE Bit */
;;;1664     *(vu32 *) CCMR1_OC1PE_BB = (u16)TIM1_OCPreload;
000002  6008              STR      r0,[r1,#0]
;;;1665   }
000004  4770              BX       lr
;;;1666   
                          ENDP

000006  0000              DCW      0x0000
                  |L49.8|
                          DCD      0x4225830c

                          AREA ||i.TIM1_OC2FastConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC2FastConfig PROC
;;;1760   *******************************************************************************/
;;;1761   void TIM1_OC2FastConfig(u16 TIM1_OCFast)
000000  4901              LDR      r1,|L50.8|
;;;1762   {
;;;1763     /* Check the parameters */
;;;1764     assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
;;;1765   
;;;1766     /* Set or Reset the OC2FE Bit */
;;;1767     *(vu32 *) CCMR1_OC2FE_BB = (u16)TIM1_OCFast;
000002  6008              STR      r0,[r1,#0]
;;;1768   }
000004  4770              BX       lr
;;;1769   
                          ENDP

000006  0000              DCW      0x0000
                  |L50.8|
                          DCD      0x42258328

                          AREA ||i.TIM1_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM1_OC2Init PROC
;;;395    *******************************************************************************/
;;;396    void TIM1_OC2Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;397    {
;;;398      u32 tmpccmr = 0;
;;;399    
;;;400      /* Check the parameters */
;;;401      assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
;;;402      assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
;;;403      assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OCInitStruct->TIM1_OutputNState));
;;;404      assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
;;;405      assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCInitStruct->TIM1_OCNPolarity));
;;;406      assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
;;;407      assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCInitStruct->TIM1_OCNIdleState));
;;;408    
;;;409      tmpccmr = TIM1->CCMR1;
000002  4a12              LDR      r2,|L51.76|
000004  8811              LDRH     r1,[r2,#0]
;;;410    
;;;411      /* Disable the Channel 2: Reset the CCE Bit */
;;;412      *(vu32 *) CCER_CC2E_BB = CCER_CCE_Reset;
000006  2200              MOVS     r2,#0
000008  4b11              LDR      r3,|L51.80|
00000a  601a              STR      r2,[r3,#0]
;;;413    
;;;414      /* Reset the Output Compare Bits */
;;;415       tmpccmr &= OC24Mode_Mask;
00000c  b2c9              UXTB     r1,r1
;;;416    
;;;417      /* Set the Ouput Compare Mode */
;;;418      tmpccmr |= (u32)TIM1_OCInitStruct->TIM1_OCMode << 8;
00000e  8802              LDRH     r2,[r0,#0]
000010  ea412102          ORR      r1,r1,r2,LSL #8
;;;419    
;;;420      TIM1->CCMR1 = (u16)tmpccmr;
000014  4b0d              LDR      r3,|L51.76|
000016  8019              STRH     r1,[r3,#0]
;;;421    
;;;422      /* Set the Output State */
;;;423      *(vu32 *) CCER_CC2E_BB = TIM1_OCInitStruct->TIM1_OutputState;
000018  8842              LDRH     r2,[r0,#2]
00001a  4b0d              LDR      r3,|L51.80|
00001c  601a              STR      r2,[r3,#0]
;;;424    
;;;425      /* Set the Output N State */
;;;426      *(vu32 *) CCER_CC2NE_BB = TIM1_OCInitStruct->TIM1_OutputNState;
00001e  8882              LDRH     r2,[r0,#4]
000020  4b0b              LDR      r3,|L51.80|
000022  3308              ADDS     r3,r3,#8
000024  601a              STR      r2,[r3,#0]
;;;427    
;;;428      /* Set the Output Polarity */
;;;429      *(vu32 *) CCER_CC2P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
000026  8902              LDRH     r2,[r0,#8]
000028  1f1b              SUBS     r3,r3,#4
00002a  601a              STR      r2,[r3,#0]
;;;430    
;;;431      /* Set the Output N Polarity */
;;;432      *(vu32 *) CCER_CC2NP_BB = TIM1_OCInitStruct->TIM1_OCNPolarity;
00002c  8942              LDRH     r2,[r0,#0xa]
00002e  4b08              LDR      r3,|L51.80|
000030  330c              ADDS     r3,r3,#0xc
000032  601a              STR      r2,[r3,#0]
;;;433    
;;;434      /* Set the Output Idle state */
;;;435      *(vu32 *) CR2_OIS2_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
000034  8982              LDRH     r2,[r0,#0xc]
000036  4b07              LDR      r3,|L51.84|
000038  601a              STR      r2,[r3,#0]
;;;436    
;;;437      /* Set the Output N Idle state */
;;;438      *(vu32 *) CR2_OIS2N_BB = TIM1_OCInitStruct->TIM1_OCNIdleState;
00003a  89c2              LDRH     r2,[r0,#0xe]
00003c  1d1b              ADDS     r3,r3,#4
00003e  601a              STR      r2,[r3,#0]
;;;439    
;;;440      /* Set the Pulse value */
;;;441      TIM1->CCR2 = TIM1_OCInitStruct->TIM1_Pulse;
000040  88c2              LDRH     r2,[r0,#6]
000042  4b02              LDR      r3,|L51.76|
000044  3320              ADDS     r3,r3,#0x20
000046  801a              STRH     r2,[r3,#0]
;;;442    }
000048  4770              BX       lr
;;;443    
                          ENDP

00004a  0000              DCW      0x0000
                  |L51.76|
                          DCD      0x40012c18
                  |L51.80|
                          DCD      0x42258410
                  |L51.84|
                          DCD      0x422580a8

                          AREA ||i.TIM1_OC2NPolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC2NPolarityConfig PROC
;;;1986   *******************************************************************************/
;;;1987   void TIM1_OC2NPolarityConfig(u16 TIM1_OCNPolarity)
000000  4901              LDR      r1,|L52.8|
;;;1988   {
;;;1989     /* Check the parameters */
;;;1990     assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
;;;1991   
;;;1992     /* Set or Reset the CC3P Bit */
;;;1993     *(vu32 *) CCER_CC2NP_BB = (u16)TIM1_OCNPolarity;
000002  6008              STR      r0,[r1,#0]
;;;1994   }
000004  4770              BX       lr
;;;1995   
                          ENDP

000006  0000              DCW      0x0000
                  |L52.8|
                          DCD      0x4225841c

                          AREA ||i.TIM1_OC2PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC2PolarityConfig PROC
;;;1966   *******************************************************************************/
;;;1967   void TIM1_OC2PolarityConfig(u16 TIM1_OCPolarity)
000000  4901              LDR      r1,|L53.8|
;;;1968   {
;;;1969     /* Check the parameters */
;;;1970     assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
;;;1971   
;;;1972     /* Set or Reset the CC2P Bit */
;;;1973     *(vu32 *) CCER_CC2P_BB = (u16)TIM1_OCPolarity;
000002  6008              STR      r0,[r1,#0]
;;;1974   }
000004  4770              BX       lr
;;;1975   
                          ENDP

000006  0000              DCW      0x0000
                  |L53.8|
                          DCD      0x42258414

                          AREA ||i.TIM1_OC2PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC2PreloadConfig PROC
;;;1678   *******************************************************************************/
;;;1679   void TIM1_OC2PreloadConfig(u16 TIM1_OCPreload)
000000  4901              LDR      r1,|L54.8|
;;;1680   {
;;;1681     /* Check the parameters */
;;;1682     assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
;;;1683   
;;;1684     /* Set or Reset the OC2PE Bit */
;;;1685     *(vu32 *) CCMR1_OC2PE_BB = (u16)TIM1_OCPreload;
000002  6008              STR      r0,[r1,#0]
;;;1686   }
000004  4770              BX       lr
;;;1687   
                          ENDP

000006  0000              DCW      0x0000
                  |L54.8|
                          DCD      0x4225832c

                          AREA ||i.TIM1_OC3FastConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC3FastConfig PROC
;;;1780   *******************************************************************************/
;;;1781   void TIM1_OC3FastConfig(u16 TIM1_OCFast)
000000  4901              LDR      r1,|L55.8|
;;;1782   {
;;;1783     /* Check the parameters */
;;;1784     assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
;;;1785   
;;;1786     /* Set or Reset the OC3FE Bit */
;;;1787     *(vu32 *) CCMR2_OC3FE_BB = (u16)TIM1_OCFast;
000002  6008              STR      r0,[r1,#0]
;;;1788   }
000004  4770              BX       lr
;;;1789   
                          ENDP

000006  0000              DCW      0x0000
                  |L55.8|
                          DCD      0x42258388

                          AREA ||i.TIM1_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM1_OC3Init PROC
;;;453    *******************************************************************************/
;;;454    void TIM1_OC3Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;455    {
;;;456      u16 tmpccmr = 0;
;;;457    
;;;458      /* Check the parameters */
;;;459      assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
;;;460      assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
;;;461      assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OCInitStruct->TIM1_OutputNState));
;;;462      assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
;;;463      assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCInitStruct->TIM1_OCNPolarity));
;;;464      assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
;;;465      assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCInitStruct->TIM1_OCNIdleState));
;;;466    
;;;467      tmpccmr = TIM1->CCMR2;
000002  4a11              LDR      r2,|L56.72|
000004  8811              LDRH     r1,[r2,#0]
;;;468    
;;;469      /* Disable the Channel 3: Reset the CCE Bit */
;;;470      *(vu32 *) CCER_CC3E_BB = CCER_CCE_Reset;
000006  2200              MOVS     r2,#0
000008  4b10              LDR      r3,|L56.76|
00000a  601a              STR      r2,[r3,#0]
;;;471    
;;;472      /* Reset the Output Compare Bits */
;;;473       tmpccmr &= OC13Mode_Mask;
00000c  f401417f          AND      r1,r1,#0xff00
;;;474    
;;;475      /* Set the Ouput Compare Mode */
;;;476      tmpccmr |= TIM1_OCInitStruct->TIM1_OCMode;
000010  8802              LDRH     r2,[r0,#0]
000012  4311              ORRS     r1,r1,r2
;;;477    
;;;478      TIM1->CCMR2 = tmpccmr;
000014  4a0c              LDR      r2,|L56.72|
000016  8011              STRH     r1,[r2,#0]
;;;479    
;;;480      /* Set the Output State */
;;;481      *(vu32 *) CCER_CC3E_BB = TIM1_OCInitStruct->TIM1_OutputState;
000018  8842              LDRH     r2,[r0,#2]
00001a  601a              STR      r2,[r3,#0]
;;;482    
;;;483      /* Set the Output N State */
;;;484      *(vu32 *) CCER_CC3NE_BB = TIM1_OCInitStruct->TIM1_OutputNState;
00001c  8882              LDRH     r2,[r0,#4]
00001e  4b0b              LDR      r3,|L56.76|
000020  3308              ADDS     r3,r3,#8
000022  601a              STR      r2,[r3,#0]
;;;485    
;;;486      /* Set the Output Polarity */
;;;487      *(vu32 *) CCER_CC3P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
000024  8902              LDRH     r2,[r0,#8]
000026  1f1b              SUBS     r3,r3,#4
000028  601a              STR      r2,[r3,#0]
;;;488    
;;;489      /* Set the Output N Polarity */
;;;490      *(vu32 *) CCER_CC3NP_BB = TIM1_OCInitStruct->TIM1_OCNPolarity;
00002a  8942              LDRH     r2,[r0,#0xa]
00002c  4b07              LDR      r3,|L56.76|
00002e  330c              ADDS     r3,r3,#0xc
000030  601a              STR      r2,[r3,#0]
;;;491    
;;;492      /* Set the Output Idle state */
;;;493      *(vu32 *) CR2_OIS3_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
000032  8982              LDRH     r2,[r0,#0xc]
000034  4b06              LDR      r3,|L56.80|
000036  601a              STR      r2,[r3,#0]
;;;494    
;;;495      /* Set the Output N Idle state */
;;;496      *(vu32 *) CR2_OIS3N_BB = TIM1_OCInitStruct->TIM1_OCNIdleState;
000038  89c2              LDRH     r2,[r0,#0xe]
00003a  1d1b              ADDS     r3,r3,#4
00003c  601a              STR      r2,[r3,#0]
;;;497    
;;;498      /* Set the Pulse value */
;;;499      TIM1->CCR3 = TIM1_OCInitStruct->TIM1_Pulse;
00003e  88c2              LDRH     r2,[r0,#6]
000040  4b01              LDR      r3,|L56.72|
000042  3320              ADDS     r3,r3,#0x20
000044  801a              STRH     r2,[r3,#0]
;;;500    }
000046  4770              BX       lr
;;;501    
                          ENDP

                  |L56.72|
                          DCD      0x40012c1c
                  |L56.76|
                          DCD      0x42258420
                  |L56.80|
                          DCD      0x422580b0

                          AREA ||i.TIM1_OC3NPolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC3NPolarityConfig PROC
;;;2026   *******************************************************************************/
;;;2027   void TIM1_OC3NPolarityConfig(u16 TIM1_OCNPolarity)
000000  4901              LDR      r1,|L57.8|
;;;2028   {
;;;2029     /* Check the parameters */
;;;2030     assert_param(IS_TIM1_OC_POLARITY(TIM1_OCNPolarity));
;;;2031   
;;;2032     /* Set or Reset the CC3P Bit */
;;;2033     *(vu32 *) CCER_CC3NP_BB = (u16)TIM1_OCNPolarity;
000002  6008              STR      r0,[r1,#0]
;;;2034   }
000004  4770              BX       lr
;;;2035   
                          ENDP

000006  0000              DCW      0x0000
                  |L57.8|
                          DCD      0x4225842c

                          AREA ||i.TIM1_OC3PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC3PolarityConfig PROC
;;;2006   *******************************************************************************/
;;;2007   void TIM1_OC3PolarityConfig(u16 TIM1_OCPolarity)
000000  4901              LDR      r1,|L58.8|
;;;2008   {
;;;2009     /* Check the parameters */
;;;2010     assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
;;;2011   
;;;2012     /* Set or Reset the CC3P Bit */
;;;2013     *(vu32 *) CCER_CC3P_BB = (u16)TIM1_OCPolarity;
000002  6008              STR      r0,[r1,#0]
;;;2014   }
000004  4770              BX       lr
;;;2015   
                          ENDP

000006  0000              DCW      0x0000
                  |L58.8|
                          DCD      0x42258424

                          AREA ||i.TIM1_OC3PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC3PreloadConfig PROC
;;;1699   *******************************************************************************/
;;;1700   void TIM1_OC3PreloadConfig(u16 TIM1_OCPreload)
000000  4901              LDR      r1,|L59.8|
;;;1701   {
;;;1702     /* Check the parameters */
;;;1703     assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
;;;1704   
;;;1705     /* Set or Reset the OC3PE Bit */
;;;1706     *(vu32 *) CCMR2_OC3PE_BB = (u16)TIM1_OCPreload;
000002  6008              STR      r0,[r1,#0]
;;;1707   }
000004  4770              BX       lr
;;;1708   
                          ENDP

000006  0000              DCW      0x0000
                  |L59.8|
                          DCD      0x4225838c

                          AREA ||i.TIM1_OC4FastConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC4FastConfig PROC
;;;1800   *******************************************************************************/
;;;1801   void TIM1_OC4FastConfig(u16 TIM1_OCFast)
000000  4901              LDR      r1,|L60.8|
;;;1802   {
;;;1803     /* Check the parameters */
;;;1804     assert_param(IS_TIM1_OCFAST_STATE(TIM1_OCFast));
;;;1805   
;;;1806     /* Set or Reset the OC4FE Bit */
;;;1807     *(vu32 *) CCMR2_OC4FE_BB = (u16)TIM1_OCFast;
000002  6008              STR      r0,[r1,#0]
;;;1808   }
000004  4770              BX       lr
;;;1809   
                          ENDP

000006  0000              DCW      0x0000
                  |L60.8|
                          DCD      0x422583a8

                          AREA ||i.TIM1_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM1_OC4Init PROC
;;;511    *******************************************************************************/
;;;512    void TIM1_OC4Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;513    {
;;;514      u32 tmpccmr = 0;
;;;515    
;;;516      /* Check the parameters */
;;;517      assert_param(IS_TIM1_OC_MODE(TIM1_OCInitStruct->TIM1_OCMode));
;;;518      assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OCInitStruct->TIM1_OutputState));
;;;519      assert_param(IS_TIM1_OC_POLARITY(TIM1_OCInitStruct->TIM1_OCPolarity));
;;;520      assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCInitStruct->TIM1_OCIdleState));
;;;521    
;;;522      tmpccmr = TIM1->CCMR2;
000002  4a0c              LDR      r2,|L61.52|
000004  8811              LDRH     r1,[r2,#0]
;;;523    
;;;524      /* Disable the Channel 4: Reset the CCE Bit */
;;;525      *(vu32 *) CCER_CC4E_BB = CCER_CCE_Reset;
000006  2200              MOVS     r2,#0
000008  4b0b              LDR      r3,|L61.56|
00000a  601a              STR      r2,[r3,#0]
;;;526    
;;;527      /* Reset the Output Compare Bits */
;;;528       tmpccmr &= OC24Mode_Mask;
00000c  b2c9              UXTB     r1,r1
;;;529    
;;;530      /* Set the Ouput Compare Mode */
;;;531      tmpccmr |= (u32)TIM1_OCInitStruct->TIM1_OCMode << 8;
00000e  8802              LDRH     r2,[r0,#0]
000010  ea412102          ORR      r1,r1,r2,LSL #8
;;;532    
;;;533      TIM1->CCMR2 = (u16)tmpccmr;
000014  4b07              LDR      r3,|L61.52|
000016  8019              STRH     r1,[r3,#0]
;;;534    
;;;535      /* Set the Output State */
;;;536      *(vu32 *) CCER_CC4E_BB = TIM1_OCInitStruct->TIM1_OutputState;
000018  8842              LDRH     r2,[r0,#2]
00001a  4b07              LDR      r3,|L61.56|
00001c  601a              STR      r2,[r3,#0]
;;;537    
;;;538      /* Set the Output Polarity */
;;;539      *(vu32 *) CCER_CC4P_BB = TIM1_OCInitStruct->TIM1_OCPolarity;
00001e  8902              LDRH     r2,[r0,#8]
000020  1d1b              ADDS     r3,r3,#4
000022  601a              STR      r2,[r3,#0]
;;;540    
;;;541      /* Set the Output Idle state */
;;;542      *(vu32 *) CR2_OIS4_BB = TIM1_OCInitStruct->TIM1_OCIdleState;
000024  8982              LDRH     r2,[r0,#0xc]
000026  4b05              LDR      r3,|L61.60|
000028  601a              STR      r2,[r3,#0]
;;;543    
;;;544      /* Set the Pulse value */
;;;545      TIM1->CCR4 = TIM1_OCInitStruct->TIM1_Pulse;
00002a  88c2              LDRH     r2,[r0,#6]
00002c  4b01              LDR      r3,|L61.52|
00002e  3324              ADDS     r3,r3,#0x24
000030  801a              STRH     r2,[r3,#0]
;;;546    }
000032  4770              BX       lr
;;;547    
                          ENDP

                  |L61.52|
                          DCD      0x40012c1c
                  |L61.56|
                          DCD      0x42258430
                  |L61.60|
                          DCD      0x422580b8

                          AREA ||i.TIM1_OC4PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC4PolarityConfig PROC
;;;2046   *******************************************************************************/
;;;2047   void TIM1_OC4PolarityConfig(u16 TIM1_OCPolarity)
000000  4901              LDR      r1,|L62.8|
;;;2048   {
;;;2049     /* Check the parameters */
;;;2050     assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
;;;2051   
;;;2052     /* Set or Reset the CC4P Bit */
;;;2053     *(vu32 *) CCER_CC4P_BB = (u16)TIM1_OCPolarity;
000002  6008              STR      r0,[r1,#0]
;;;2054   }
000004  4770              BX       lr
;;;2055   
                          ENDP

000006  0000              DCW      0x0000
                  |L62.8|
                          DCD      0x42258434

                          AREA ||i.TIM1_OC4PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM1_OC4PreloadConfig PROC
;;;1720   *******************************************************************************/
;;;1721   void TIM1_OC4PreloadConfig(u16 TIM1_OCPreload)
000000  4901              LDR      r1,|L63.8|
;;;1722   {
;;;1723     /* Check the parameters */
;;;1724     assert_param(IS_TIM1_OCPRELOAD_STATE(TIM1_OCPreload));
;;;1725   
;;;1726     /* Set or Reset the OC4PE Bit */
;;;1727     *(vu32 *) CCMR2_OC4PE_BB = (u16)TIM1_OCPreload;
000002  6008              STR      r0,[r1,#0]
;;;1728   }
000004  4770              BX       lr
;;;1729   
                          ENDP

000006  0000              DCW      0x0000
                  |L63.8|
                          DCD      0x422583ac

                          AREA ||i.TIM1_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM1_OCStructInit PROC
;;;727    *******************************************************************************/
;;;728    void TIM1_OCStructInit(TIM1_OCInitTypeDef* TIM1_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;729    {
;;;730      /* Set the default configuration */
;;;731      TIM1_OCInitStruct->TIM1_OCMode = TIM1_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;732      TIM1_OCInitStruct->TIM1_OutputState = TIM1_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;733      TIM1_OCInitStruct->TIM1_OutputNState = TIM1_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;734      TIM1_OCInitStruct->TIM1_Pulse = TIM1_Pulse_Reset_Mask;
000008  80c1              STRH     r1,[r0,#6]
;;;735      TIM1_OCInitStruct->TIM1_OCPolarity = TIM1_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;736      TIM1_OCInitStruct->TIM1_OCNPolarity = TIM1_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;737      TIM1_OCInitStruct->TIM1_OCIdleState = TIM1_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;738      TIM1_OCInitStruct->TIM1_OCNIdleState = TIM1_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;739    }
000012  4770              BX       lr
;;;740    
                          ENDP


                          AREA ||i.TIM1_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM1_PWMIConfig PROC
;;;656    *******************************************************************************/
;;;657    void TIM1_PWMIConfig(TIM1_ICInitTypeDef* TIM1_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;658    {
000002  4604              MOV      r4,r0
;;;659      u8 ICPolarity = TIM1_ICPolarity_Rising;
000004  2500              MOVS     r5,#0
;;;660      u8 ICSelection = TIM1_ICSelection_DirectTI;
000006  2601              MOVS     r6,#1
;;;661    
;;;662      /* Check the parameters */
;;;663      assert_param(IS_TIM1_PWMI_CHANNEL(TIM1_ICInitStruct->TIM1_Channel));
;;;664      assert_param(IS_TIM1_IC_POLARITY(TIM1_ICInitStruct->TIM1_ICPolarity));
;;;665      assert_param(IS_TIM1_IC_SELECTION(TIM1_ICInitStruct->TIM1_ICSelection));
;;;666      assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICInitStruct->TIM1_ICPrescaler));
;;;667    
;;;668      /* Select the Opposite Input Polarity */
;;;669      if (TIM1_ICInitStruct->TIM1_ICPolarity == TIM1_ICPolarity_Rising)
000008  8860              LDRH     r0,[r4,#2]
00000a  b908              CBNZ     r0,|L65.16|
;;;670      {
;;;671        ICPolarity = TIM1_ICPolarity_Falling;
00000c  2501              MOVS     r5,#1
00000e  e000              B        |L65.18|
                  |L65.16|
;;;672      }
;;;673      else
;;;674      {
;;;675        ICPolarity = TIM1_ICPolarity_Rising;
000010  2500              MOVS     r5,#0
                  |L65.18|
;;;676      }
;;;677    
;;;678      /* Select the Opposite Input */
;;;679      if (TIM1_ICInitStruct->TIM1_ICSelection == TIM1_ICSelection_DirectTI)
000012  88a0              LDRH     r0,[r4,#4]
000014  2801              CMP      r0,#1
000016  d101              BNE      |L65.28|
;;;680      {
;;;681        ICSelection = TIM1_ICSelection_IndirectTI;
000018  2602              MOVS     r6,#2
00001a  e000              B        |L65.30|
                  |L65.28|
;;;682      }
;;;683      else
;;;684      {
;;;685        ICSelection = TIM1_ICSelection_DirectTI;
00001c  2601              MOVS     r6,#1
                  |L65.30|
;;;686      }
;;;687    
;;;688      if (TIM1_ICInitStruct->TIM1_Channel == TIM1_Channel_1)
00001e  8820              LDRH     r0,[r4,#0]
000020  b980              CBNZ     r0,|L65.68|
;;;689      {
;;;690        /* TI1 Configuration */
;;;691        TI1_Config(TIM1_ICInitStruct->TIM1_ICPolarity, TIM1_ICInitStruct->TIM1_ICSelection,
000022  7a22              LDRB     r2,[r4,#8]
000024  88a1              LDRH     r1,[r4,#4]
000026  8860              LDRH     r0,[r4,#2]
000028  f7fffffe          BL       TI1_Config
;;;692                   TIM1_ICInitStruct->TIM1_ICFilter);
;;;693    
;;;694        /* Set the Input Capture Prescaler value */
;;;695        TIM1_SetIC1Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
00002c  88e0              LDRH     r0,[r4,#6]
00002e  f7fffffe          BL       TIM1_SetIC1Prescaler
;;;696    
;;;697        /* TI2 Configuration */
;;;698        TI2_Config(ICPolarity, ICSelection, TIM1_ICInitStruct->TIM1_ICFilter);
000032  7a22              LDRB     r2,[r4,#8]
000034  4631              MOV      r1,r6
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       TI2_Config
;;;699    
;;;700        /* Set the Input Capture Prescaler value */
;;;701        TIM1_SetIC2Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
00003c  88e0              LDRH     r0,[r4,#6]
00003e  f7fffffe          BL       TIM1_SetIC2Prescaler
000042  e00f              B        |L65.100|
                  |L65.68|
;;;702      }
;;;703      else
;;;704      {	 
;;;705        /* TI2 Configuration */
;;;706        TI2_Config(TIM1_ICInitStruct->TIM1_ICPolarity, TIM1_ICInitStruct->TIM1_ICSelection,
000044  7a22              LDRB     r2,[r4,#8]
000046  88a1              LDRH     r1,[r4,#4]
000048  8860              LDRH     r0,[r4,#2]
00004a  f7fffffe          BL       TI2_Config
;;;707                   TIM1_ICInitStruct->TIM1_ICFilter);
;;;708    
;;;709        /* Set the Input Capture Prescaler value */
;;;710        TIM1_SetIC2Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
00004e  88e0              LDRH     r0,[r4,#6]
000050  f7fffffe          BL       TIM1_SetIC2Prescaler
;;;711    
;;;712        /* TI1 Configuration */
;;;713        TI1_Config(ICPolarity, ICSelection, TIM1_ICInitStruct->TIM1_ICFilter);
000054  7a22              LDRB     r2,[r4,#8]
000056  4631              MOV      r1,r6
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       TI1_Config
;;;714    
;;;715        /* Set the Input Capture Prescaler value */
;;;716        TIM1_SetIC1Prescaler(TIM1_ICInitStruct->TIM1_ICPrescaler);
00005e  88e0              LDRH     r0,[r4,#6]
000060  f7fffffe          BL       TIM1_SetIC1Prescaler
                  |L65.100|
;;;717      }
;;;718    }
000064  bd70              POP      {r4-r6,pc}
;;;719    /*******************************************************************************
                          ENDP


                          AREA ||i.TIM1_PrescalerConfig||, CODE, READONLY, ALIGN=2

                  TIM1_PrescalerConfig PROC
;;;1401   *******************************************************************************/
;;;1402   void TIM1_PrescalerConfig(u16 Prescaler, u16 TIM1_PSCReloadMode)
000000  4a02              LDR      r2,|L66.12|
;;;1403   {
;;;1404     /* Check the parameters */
;;;1405     assert_param(IS_TIM1_PRESCALER_RELOAD(TIM1_PSCReloadMode));
;;;1406   
;;;1407     /* Set the Prescaler value */
;;;1408     TIM1->PSC = Prescaler;
000002  8010              STRH     r0,[r2,#0]
;;;1409   
;;;1410     /* Set or reset the UG Bit */
;;;1411     *(vu32 *) EGR_UG_BB = TIM1_PSCReloadMode;
000004  4a02              LDR      r2,|L66.16|
000006  6011              STR      r1,[r2,#0]
;;;1412   }
000008  4770              BX       lr
;;;1413   /*******************************************************************************
                          ENDP

00000a  0000              DCW      0x0000
                  |L66.12|
                          DCD      0x40012c28
                  |L66.16|
                          DCD      0x42258280

                          AREA ||i.TIM1_SelectCCDMA||, CODE, READONLY, ALIGN=2

                  TIM1_SelectCCDMA PROC
;;;1617   *******************************************************************************/
;;;1618   void TIM1_SelectCCDMA(FunctionalState Newstate)
000000  4901              LDR      r1,|L67.8|
;;;1619   {
;;;1620     /* Check the parameters */
;;;1621     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;1622   
;;;1623     /* Set or Reset the CCDS Bit */
;;;1624     *(vu32 *) CR2_CCDS_BB = (u16)Newstate;
000002  6008              STR      r0,[r1,#0]
;;;1625   }
000004  4770              BX       lr
;;;1626   
                          ENDP

000006  0000              DCW      0x0000
                  |L67.8|
                          DCD      0x4225808c

                          AREA ||i.TIM1_SelectCOM||, CODE, READONLY, ALIGN=2

                  TIM1_SelectCOM PROC
;;;1599   *******************************************************************************/
;;;1600   void TIM1_SelectCOM(FunctionalState Newstate)
000000  4901              LDR      r1,|L68.8|
;;;1601   {
;;;1602     /* Check the parameters */
;;;1603     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;1604   
;;;1605     /* Set or Reset the CCUS Bit */
;;;1606     *(vu32 *) CR2_CCUS_BB = (u16)Newstate;
000002  6008              STR      r0,[r1,#0]
;;;1607   }
000004  4770              BX       lr
;;;1608   
                          ENDP

000006  0000              DCW      0x0000
                  |L68.8|
                          DCD      0x42258088

                          AREA ||i.TIM1_SelectHallSensor||, CODE, READONLY, ALIGN=2

                  TIM1_SelectHallSensor PROC
;;;1217   *******************************************************************************/
;;;1218   void TIM1_SelectHallSensor(FunctionalState Newstate)
000000  4901              LDR      r1,|L69.8|
;;;1219   {
;;;1220     /* Check the parameters */
;;;1221     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;1222   
;;;1223     /* Set or Reset the TI1S Bit */
;;;1224     *(vu32 *) CR2_TI1S_BB = (u16)Newstate;
000002  6008              STR      r0,[r1,#0]
;;;1225   }
000004  4770              BX       lr
;;;1226   
                          ENDP

000006  0000              DCW      0x0000
                  |L69.8|
                          DCD      0x4225809c

                          AREA ||i.TIM1_SelectInputTrigger||, CODE, READONLY, ALIGN=2

                  TIM1_SelectInputTrigger PROC
;;;1155   *******************************************************************************/
;;;1156   void TIM1_SelectInputTrigger(u16 TIM1_InputTriggerSource)
000000  4601              MOV      r1,r0
;;;1157   {
;;;1158     u32 tmpsmcr = 0;
000002  2000              MOVS     r0,#0
;;;1159   
;;;1160     /* Check the parameters */
;;;1161     assert_param(IS_TIM1_TRIGGER_SELECTION(TIM1_InputTriggerSource));
;;;1162   
;;;1163     tmpsmcr = TIM1->SMCR;
000004  4a04              LDR      r2,|L70.24|
000006  8810              LDRH     r0,[r2,#0]
;;;1164   
;;;1165     /* Select the Tgigger Source */
;;;1166     tmpsmcr &= SMCR_TS_Mask;
000008  f64f7287          MOV      r2,#0xff87
00000c  4010              ANDS     r0,r0,r2
;;;1167     tmpsmcr |= TIM1_InputTriggerSource;
00000e  4308              ORRS     r0,r0,r1
;;;1168   
;;;1169     TIM1->SMCR = (u16)tmpsmcr;
000010  4b01              LDR      r3,|L70.24|
000012  8018              STRH     r0,[r3,#0]
;;;1170   }
000014  4770              BX       lr
;;;1171   
                          ENDP

000016  0000              DCW      0x0000
                  |L70.24|
                          DCD      0x40012c08

                          AREA ||i.TIM1_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=2

                  TIM1_SelectMasterSlaveMode PROC
;;;1324   *******************************************************************************/
;;;1325   void TIM1_SelectMasterSlaveMode(u16 TIM1_MasterSlaveMode)
000000  4901              LDR      r1,|L71.8|
;;;1326   {
;;;1327     /* Check the parameters */
;;;1328     assert_param(IS_TIM1_MSM_STATE(TIM1_MasterSlaveMode));
;;;1329   
;;;1330     /* Set or Reset the MSM Bit */
;;;1331     *(vu32 *) SMCR_MSM_BB = TIM1_MasterSlaveMode;
000002  6008              STR      r0,[r1,#0]
;;;1332   }
000004  4770              BX       lr
;;;1333   
                          ENDP

000006  0000              DCW      0x0000
                  |L71.8|
                          DCD      0x4225811c

                          AREA ||i.TIM1_SelectOCxM||, CODE, READONLY, ALIGN=2

                  TIM1_SelectOCxM PROC
;;;2162   *******************************************************************************/
;;;2163   void TIM1_SelectOCxM(u16 TIM1_Channel, u16 TIM1_OCMode)
000000  b968              CBNZ     r0,|L72.30|
;;;2164   {
;;;2165     /* Check the parameters */
;;;2166     assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
;;;2167     assert_param(IS_TIM1_OCM(TIM1_OCMode));
;;;2168   
;;;2169     if(TIM1_Channel == TIM1_Channel_1)
;;;2170     {
;;;2171       /* Disable the Channel 1: Reset the CCE Bit */
;;;2172       *(vu32 *) CCER_CC1E_BB = CCER_CCE_Reset;
000002  2200              MOVS     r2,#0
000004  4b25              LDR      r3,|L72.156|
000006  601a              STR      r2,[r3,#0]
;;;2173   
;;;2174       /* Reset the Output Compare Bits */
;;;2175       TIM1->CCMR1 &= OC13Mode_Mask;
000008  4a25              LDR      r2,|L72.160|
00000a  8812              LDRH     r2,[r2,#0]
00000c  f402427f          AND      r2,r2,#0xff00
000010  4b23              LDR      r3,|L72.160|
000012  801a              STRH     r2,[r3,#0]
;;;2176   
;;;2177       /* Set the Ouput Compare Mode */
;;;2178       TIM1->CCMR1 |= TIM1_OCMode;
000014  461a              MOV      r2,r3
000016  8812              LDRH     r2,[r2,#0]
000018  430a              ORRS     r2,r2,r1
00001a  801a              STRH     r2,[r3,#0]
00001c  e03c              B        |L72.152|
                  |L72.30|
;;;2179     }
;;;2180     else if(TIM1_Channel == TIM1_Channel_2)
00001e  2801              CMP      r0,#1
000020  d112              BNE      |L72.72|
;;;2181     {
;;;2182       /* Disable the Channel 2: Reset the CCE Bit */
;;;2183       *(vu32 *) CCER_CC2E_BB = CCER_CCE_Reset;
000022  2200              MOVS     r2,#0
000024  4b1d              LDR      r3,|L72.156|
000026  3310              ADDS     r3,r3,#0x10
000028  601a              STR      r2,[r3,#0]
;;;2184   
;;;2185       /* Reset the Output Compare Bits */
;;;2186       TIM1->CCMR1 &= OC24Mode_Mask;
00002a  4a1d              LDR      r2,|L72.160|
00002c  8812              LDRH     r2,[r2,#0]
00002e  b2d2              UXTB     r2,r2
000030  4b1b              LDR      r3,|L72.160|
000032  801a              STRH     r2,[r3,#0]
;;;2187   
;;;2188       /* Set the Ouput Compare Mode */
;;;2189       TIM1->CCMR1 |= (u16)((u16)TIM1_OCMode << 8);
000034  461a              MOV      r2,r3
000036  8812              LDRH     r2,[r2,#0]
000038  f64f73ff          MOV      r3,#0xffff
00003c  ea032301          AND      r3,r3,r1,LSL #8
000040  431a              ORRS     r2,r2,r3
000042  4b17              LDR      r3,|L72.160|
000044  801a              STRH     r2,[r3,#0]
000046  e027              B        |L72.152|
                  |L72.72|
;;;2190     }
;;;2191     else if(TIM1_Channel == TIM1_Channel_3)
000048  2802              CMP      r0,#2
00004a  d110              BNE      |L72.110|
;;;2192     {
;;;2193       /* Disable the Channel 3: Reset the CCE Bit */
;;;2194       *(vu32 *) CCER_CC3E_BB = CCER_CCE_Reset;
00004c  2200              MOVS     r2,#0
00004e  4b13              LDR      r3,|L72.156|
000050  3320              ADDS     r3,r3,#0x20
000052  601a              STR      r2,[r3,#0]
;;;2195   
;;;2196       /* Reset the Output Compare Bits */
;;;2197       TIM1->CCMR2 &= OC13Mode_Mask;
000054  4a12              LDR      r2,|L72.160|
000056  1d12              ADDS     r2,r2,#4
000058  8812              LDRH     r2,[r2,#0]
00005a  f402427f          AND      r2,r2,#0xff00
00005e  4b10              LDR      r3,|L72.160|
000060  1d1b              ADDS     r3,r3,#4
000062  801a              STRH     r2,[r3,#0]
;;;2198   
;;;2199       /* Set the Ouput Compare Mode */
;;;2200       TIM1->CCMR2 |= TIM1_OCMode;
000064  461a              MOV      r2,r3
000066  8812              LDRH     r2,[r2,#0]
000068  430a              ORRS     r2,r2,r1
00006a  801a              STRH     r2,[r3,#0]
00006c  e014              B        |L72.152|
                  |L72.110|
;;;2201     }
;;;2202     else
;;;2203     {
;;;2204       /* Disable the Channel 4: Reset the CCE Bit */
;;;2205       *(vu32 *) CCER_CC4E_BB = CCER_CCE_Reset;
00006e  2200              MOVS     r2,#0
000070  4b0a              LDR      r3,|L72.156|
000072  3330              ADDS     r3,r3,#0x30
000074  601a              STR      r2,[r3,#0]
;;;2206   
;;;2207       /* Reset the Output Compare Bits */
;;;2208       TIM1->CCMR2 &= OC24Mode_Mask;
000076  4a0a              LDR      r2,|L72.160|
000078  1d12              ADDS     r2,r2,#4
00007a  8812              LDRH     r2,[r2,#0]
00007c  b2d2              UXTB     r2,r2
00007e  4b08              LDR      r3,|L72.160|
000080  1d1b              ADDS     r3,r3,#4
000082  801a              STRH     r2,[r3,#0]
;;;2209   
;;;2210       /* Set the Ouput Compare Mode */
;;;2211       TIM1->CCMR2 |= (u16)((u16)TIM1_OCMode << 8);
000084  461a              MOV      r2,r3
000086  8812              LDRH     r2,[r2,#0]
000088  f64f73ff          MOV      r3,#0xffff
00008c  ea032301          AND      r3,r3,r1,LSL #8
000090  431a              ORRS     r2,r2,r3
000092  4b03              LDR      r3,|L72.160|
000094  1d1b              ADDS     r3,r3,#4
000096  801a              STRH     r2,[r3,#0]
                  |L72.152|
;;;2212     }
;;;2213   }
000098  4770              BX       lr
;;;2214   
                          ENDP

00009a  0000              DCW      0x0000
                  |L72.156|
                          DCD      0x42258400
                  |L72.160|
                          DCD      0x40012c18

                          AREA ||i.TIM1_SelectOnePulseMode||, CODE, READONLY, ALIGN=2

                  TIM1_SelectOnePulseMode PROC
;;;1237   *******************************************************************************/
;;;1238   void TIM1_SelectOnePulseMode(u16 TIM1_OPMode)
000000  4901              LDR      r1,|L73.8|
;;;1239   {
;;;1240     /* Check the parameters */
;;;1241     assert_param(IS_TIM1_OPM_MODE(TIM1_OPMode));
;;;1242   
;;;1243     /* Set or Reset the OPM Bit */
;;;1244     *(vu32 *) CR1_OPM_BB = TIM1_OPMode;
000002  60c8              STR      r0,[r1,#0xc]
;;;1245   }
000004  4770              BX       lr
;;;1246   
                          ENDP

000006  0000              DCW      0x0000
                  |L73.8|
                          DCD      0x42258000

                          AREA ||i.TIM1_SelectOutputTrigger||, CODE, READONLY, ALIGN=2

                  TIM1_SelectOutputTrigger PROC
;;;1263   *******************************************************************************/
;;;1264   void TIM1_SelectOutputTrigger(u16 TIM1_TRGOSource)
000000  4601              MOV      r1,r0
;;;1265   {
;;;1266     u32 tmpcr2 = 0;
000002  2000              MOVS     r0,#0
;;;1267   
;;;1268     /* Check the parameters */
;;;1269     assert_param(IS_TIM1_TRGO_SOURCE(TIM1_TRGOSource));
;;;1270   
;;;1271     tmpcr2 = TIM1->CR2;
000004  4a03              LDR      r2,|L74.20|
000006  8810              LDRH     r0,[r2,#0]
;;;1272   
;;;1273     /* Reset the MMS Bits */
;;;1274     tmpcr2 &= CR2_MMS_Mask;
000008  f0000080          AND      r0,r0,#0x80
;;;1275   
;;;1276     /* Select the TRGO source */
;;;1277     tmpcr2 |=  TIM1_TRGOSource;
00000c  4308              ORRS     r0,r0,r1
;;;1278   
;;;1279     TIM1->CR2 = (u16)tmpcr2;
00000e  4613              MOV      r3,r2
000010  8018              STRH     r0,[r3,#0]
;;;1280   }
000012  4770              BX       lr
;;;1281   
                          ENDP

                  |L74.20|
                          DCD      0x40012c04

                          AREA ||i.TIM1_SelectSlaveMode||, CODE, READONLY, ALIGN=2

                  TIM1_SelectSlaveMode PROC
;;;1294   *******************************************************************************/
;;;1295   void TIM1_SelectSlaveMode(u16 TIM1_SlaveMode)
000000  4601              MOV      r1,r0
;;;1296   {
;;;1297     u32 tmpsmcr = 0;
000002  2000              MOVS     r0,#0
;;;1298   
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM1_SLAVE_MODE(TIM1_SlaveMode));
;;;1301   
;;;1302     tmpsmcr = TIM1->SMCR;
000004  4a04              LDR      r2,|L75.24|
000006  8810              LDRH     r0,[r2,#0]
;;;1303   
;;;1304     /* Reset the SMS Bits */
;;;1305     tmpsmcr &= SMCR_SMS_Mask;
000008  f64f72f0          MOV      r2,#0xfff0
00000c  4010              ANDS     r0,r0,r2
;;;1306   
;;;1307     /* Select the Slave Mode */
;;;1308     tmpsmcr |= TIM1_SlaveMode;
00000e  4308              ORRS     r0,r0,r1
;;;1309   
;;;1310     TIM1->SMCR = (u16)tmpsmcr;
000010  4b01              LDR      r3,|L75.24|
000012  8018              STRH     r0,[r3,#0]
;;;1311   }
000014  4770              BX       lr
;;;1312   
                          ENDP

000016  0000              DCW      0x0000
                  |L75.24|
                          DCD      0x40012c08

                          AREA ||i.TIM1_SetAutoreload||, CODE, READONLY, ALIGN=2

                  TIM1_SetAutoreload PROC
;;;2236   *******************************************************************************/
;;;2237   void TIM1_SetAutoreload(u16 Autoreload)
000000  4901              LDR      r1,|L76.8|
;;;2238   {
;;;2239     /* Set the Autoreload Register value */
;;;2240     TIM1->ARR = Autoreload;
000002  8008              STRH     r0,[r1,#0]
;;;2241   }
000004  4770              BX       lr
;;;2242   
                          ENDP

000006  0000              DCW      0x0000
                  |L76.8|
                          DCD      0x40012c2c

                          AREA ||i.TIM1_SetClockDivision||, CODE, READONLY, ALIGN=2

                  TIM1_SetClockDivision PROC
;;;2438   *******************************************************************************/
;;;2439   void TIM1_SetClockDivision(u16 TIM1_CKD)
000000  4601              MOV      r1,r0
;;;2440   {
;;;2441     u32 tmpcr1 = 0;
000002  2000              MOVS     r0,#0
;;;2442   
;;;2443     /* Check the parameters */
;;;2444     assert_param(IS_TIM1_CKD_DIV(TIM1_CKD));
;;;2445   
;;;2446     tmpcr1 = TIM1->CR1;
000004  4a03              LDR      r2,|L77.20|
000006  8810              LDRH     r0,[r2,#0]
;;;2447   
;;;2448     /* Reset the CKD Bits */
;;;2449     tmpcr1 &= CR1_CKD_Mask;
000008  b2c0              UXTB     r0,r0
;;;2450   
;;;2451     /* Set the CKD value */
;;;2452     tmpcr1 |= TIM1_CKD;
00000a  4308              ORRS     r0,r0,r1
;;;2453   
;;;2454     TIM1->CR1 = (u16)tmpcr1;
00000c  4613              MOV      r3,r2
00000e  8018              STRH     r0,[r3,#0]
;;;2455   }
000010  4770              BX       lr
;;;2456   
                          ENDP

000012  0000              DCW      0x0000
                  |L77.20|
                          DCD      0x40012c00

                          AREA ||i.TIM1_SetCompare1||, CODE, READONLY, ALIGN=2

                  TIM1_SetCompare1 PROC
;;;2250   *******************************************************************************/
;;;2251   void TIM1_SetCompare1(u16 Compare1)
000000  4901              LDR      r1,|L78.8|
;;;2252   {
;;;2253     /* Set the Capture Compare1 Register value */
;;;2254     TIM1->CCR1 = Compare1;
000002  8008              STRH     r0,[r1,#0]
;;;2255   }
000004  4770              BX       lr
;;;2256   
                          ENDP

000006  0000              DCW      0x0000
                  |L78.8|
                          DCD      0x40012c34

                          AREA ||i.TIM1_SetCompare2||, CODE, READONLY, ALIGN=2

                  TIM1_SetCompare2 PROC
;;;2264   *******************************************************************************/
;;;2265   void TIM1_SetCompare2(u16 Compare2)
000000  4901              LDR      r1,|L79.8|
;;;2266   {
;;;2267     /* Set the Capture Compare2 Register value */
;;;2268     TIM1->CCR2 = Compare2;
000002  8008              STRH     r0,[r1,#0]
;;;2269   }
000004  4770              BX       lr
;;;2270   
                          ENDP

000006  0000              DCW      0x0000
                  |L79.8|
                          DCD      0x40012c38

                          AREA ||i.TIM1_SetCompare3||, CODE, READONLY, ALIGN=2

                  TIM1_SetCompare3 PROC
;;;2278   *******************************************************************************/
;;;2279   void TIM1_SetCompare3(u16 Compare3)
000000  4901              LDR      r1,|L80.8|
;;;2280   {
;;;2281     /* Set the Capture Compare3 Register value */
;;;2282     TIM1->CCR3 = Compare3;
000002  8008              STRH     r0,[r1,#0]
;;;2283   }
000004  4770              BX       lr
;;;2284   
                          ENDP

000006  0000              DCW      0x0000
                  |L80.8|
                          DCD      0x40012c3c

                          AREA ||i.TIM1_SetCompare4||, CODE, READONLY, ALIGN=2

                  TIM1_SetCompare4 PROC
;;;2292   *******************************************************************************/
;;;2293   void TIM1_SetCompare4(u16 Compare4)
000000  4901              LDR      r1,|L81.8|
;;;2294   {
;;;2295     /* Set the Capture Compare4 Register value */
;;;2296     TIM1->CCR4 = Compare4;
000002  8008              STRH     r0,[r1,#0]
;;;2297   }
000004  4770              BX       lr
;;;2298   
                          ENDP

000006  0000              DCW      0x0000
                  |L81.8|
                          DCD      0x40012c40

                          AREA ||i.TIM1_SetCounter||, CODE, READONLY, ALIGN=2

                  TIM1_SetCounter PROC
;;;2222   *******************************************************************************/
;;;2223   void TIM1_SetCounter(u16 Counter)
000000  4901              LDR      r1,|L82.8|
;;;2224   {
;;;2225     /* Set the Counter Register value */
;;;2226     TIM1->CNT = Counter;
000002  8008              STRH     r0,[r1,#0]
;;;2227   }
000004  4770              BX       lr
;;;2228   
                          ENDP

000006  0000              DCW      0x0000
                  |L82.8|
                          DCD      0x40012c24

                          AREA ||i.TIM1_SetIC1Prescaler||, CODE, READONLY, ALIGN=2

                  TIM1_SetIC1Prescaler PROC
;;;2312   *******************************************************************************/
;;;2313   void TIM1_SetIC1Prescaler(u16 TIM1_IC1Prescaler)
000000  4601              MOV      r1,r0
;;;2314   {
;;;2315     u32 tmpccmr1 = 0;
000002  2000              MOVS     r0,#0
;;;2316     
;;;2317     /* Check the parameters */
;;;2318     assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC1Prescaler));
;;;2319   
;;;2320     tmpccmr1 = TIM1->CCMR1;
000004  4a04              LDR      r2,|L83.24|
000006  8810              LDRH     r0,[r2,#0]
;;;2321   
;;;2322     /* Reset the IC1PSC Bits */
;;;2323     tmpccmr1 &= CCMR_IC13PSC_Mask;
000008  f64f72f3          MOV      r2,#0xfff3
00000c  4010              ANDS     r0,r0,r2
;;;2324   
;;;2325     /* Set the IC1PSC value */
;;;2326     tmpccmr1 |= TIM1_IC1Prescaler;
00000e  4308              ORRS     r0,r0,r1
;;;2327   
;;;2328     TIM1->CCMR1 = (u16)tmpccmr1;
000010  4b01              LDR      r3,|L83.24|
000012  8018              STRH     r0,[r3,#0]
;;;2329   }
000014  4770              BX       lr
;;;2330   
                          ENDP

000016  0000              DCW      0x0000
                  |L83.24|
                          DCD      0x40012c18

                          AREA ||i.TIM1_SetIC2Prescaler||, CODE, READONLY, ALIGN=2

                  TIM1_SetIC2Prescaler PROC
;;;2344   *******************************************************************************/
;;;2345   void TIM1_SetIC2Prescaler(u16 TIM1_IC2Prescaler)
000000  4601              MOV      r1,r0
;;;2346   {
;;;2347     u32 tmpccmr1 = 0;
000002  2000              MOVS     r0,#0
;;;2348   
;;;2349     /* Check the parameters */
;;;2350     assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC2Prescaler));
;;;2351   
;;;2352     tmpccmr1 = TIM1->CCMR1;
000004  4a06              LDR      r2,|L84.32|
000006  8810              LDRH     r0,[r2,#0]
;;;2353   
;;;2354     /* Reset the IC2PSC Bits */
;;;2355     tmpccmr1 &= CCMR_IC24PSC_Mask;
000008  f24f32ff          MOV      r2,#0xf3ff
00000c  4010              ANDS     r0,r0,r2
;;;2356   
;;;2357     /* Set the IC2PSC value */
;;;2358     tmpccmr1 |= (u16)((u16)TIM1_IC2Prescaler << 8);
00000e  f64f72ff          MOV      r2,#0xffff
000012  ea022201          AND      r2,r2,r1,LSL #8
000016  4310              ORRS     r0,r0,r2
;;;2359   
;;;2360     TIM1->CCMR1 = (u16)tmpccmr1;
000018  4a01              LDR      r2,|L84.32|
00001a  8010              STRH     r0,[r2,#0]
;;;2361   }
00001c  4770              BX       lr
;;;2362   
                          ENDP

00001e  0000              DCW      0x0000
                  |L84.32|
                          DCD      0x40012c18

                          AREA ||i.TIM1_SetIC3Prescaler||, CODE, READONLY, ALIGN=2

                  TIM1_SetIC3Prescaler PROC
;;;2376   *******************************************************************************/
;;;2377   void TIM1_SetIC3Prescaler(u16 TIM1_IC3Prescaler)
000000  4601              MOV      r1,r0
;;;2378   {
;;;2379     u32 tmpccmr2 = 0;
000002  2000              MOVS     r0,#0
;;;2380   
;;;2381     /* Check the parameters */
;;;2382     assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC3Prescaler));
;;;2383   
;;;2384     tmpccmr2 = TIM1->CCMR2;
000004  4a04              LDR      r2,|L85.24|
000006  8810              LDRH     r0,[r2,#0]
;;;2385   
;;;2386     /* Reset the IC3PSC Bits */
;;;2387     tmpccmr2 &= CCMR_IC13PSC_Mask;
000008  f64f72f3          MOV      r2,#0xfff3
00000c  4010              ANDS     r0,r0,r2
;;;2388   
;;;2389     /* Set the IC3PSC value */
;;;2390     tmpccmr2 |= TIM1_IC3Prescaler;
00000e  4308              ORRS     r0,r0,r1
;;;2391   
;;;2392     TIM1->CCMR2 = (u16)tmpccmr2;
000010  4b01              LDR      r3,|L85.24|
000012  8018              STRH     r0,[r3,#0]
;;;2393   }
000014  4770              BX       lr
;;;2394   
                          ENDP

000016  0000              DCW      0x0000
                  |L85.24|
                          DCD      0x40012c1c

                          AREA ||i.TIM1_SetIC4Prescaler||, CODE, READONLY, ALIGN=2

                  TIM1_SetIC4Prescaler PROC
;;;2408   *******************************************************************************/
;;;2409   void TIM1_SetIC4Prescaler(u16 TIM1_IC4Prescaler)
000000  4601              MOV      r1,r0
;;;2410   {
;;;2411     u32 tmpccmr2 = 0;
000002  2000              MOVS     r0,#0
;;;2412   
;;;2413     /* Check the parameters */
;;;2414     assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC4Prescaler));
;;;2415   
;;;2416     tmpccmr2 = TIM1->CCMR2;
000004  4a06              LDR      r2,|L86.32|
000006  8810              LDRH     r0,[r2,#0]
;;;2417   
;;;2418     /* Reset the IC4PSC Bits */
;;;2419     tmpccmr2 &= CCMR_IC24PSC_Mask;
000008  f24f32ff          MOV      r2,#0xf3ff
00000c  4010              ANDS     r0,r0,r2
;;;2420   
;;;2421     /* Set the IC4PSC value */
;;;2422     tmpccmr2 |= (u16)((u16)TIM1_IC4Prescaler << 8);
00000e  f64f72ff          MOV      r2,#0xffff
000012  ea022201          AND      r2,r2,r1,LSL #8
000016  4310              ORRS     r0,r0,r2
;;;2423   
;;;2424     TIM1->CCMR2 = (u16)tmpccmr2;
000018  4a01              LDR      r2,|L86.32|
00001a  8010              STRH     r0,[r2,#0]
;;;2425   }
00001c  4770              BX       lr
;;;2426   
                          ENDP

00001e  0000              DCW      0x0000
                  |L86.32|
                          DCD      0x40012c1c

                          AREA ||i.TIM1_TIxExternalClockConfig||, CODE, READONLY, ALIGN=2

                  TIM1_TIxExternalClockConfig PROC
;;;1114   *******************************************************************************/
;;;1115   void TIM1_TIxExternalClockConfig(u16 TIM1_TIxExternalCLKSource,
000000  b570              PUSH     {r4-r6,lr}
;;;1116                                   u16 TIM1_ICPolarity, u8 ICFilter)
;;;1117   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1118     /* Check the parameters */
;;;1119     assert_param(IS_TIM1_TIX_TRIGGER_SELECTION(TIM1_TIxExternalCLKSource));
;;;1120     assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
;;;1121     assert_param(IS_TIM1_IC_FILTER(ICFilter));
;;;1122   
;;;1123     /* Configure the TIM1 Input Clock Source */
;;;1124     if (TIM1_TIxExternalCLKSource == TIM1_TIxExternalCLK1Source_TI2)
000008  2c60              CMP      r4,#0x60
00000a  d105              BNE      |L87.24|
;;;1125     {
;;;1126       TI2_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
00000c  4632              MOV      r2,r6
00000e  2101              MOVS     r1,#1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI2_Config
000016  e004              B        |L87.34|
                  |L87.24|
;;;1127     }
;;;1128     else
;;;1129     {
;;;1130       TI1_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
000018  4632              MOV      r2,r6
00001a  2101              MOVS     r1,#1
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       TI1_Config
                  |L87.34|
;;;1131     }
;;;1132   
;;;1133     /* Select the Trigger source */
;;;1134     TIM1_SelectInputTrigger(TIM1_TIxExternalCLKSource);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       TIM1_SelectInputTrigger
;;;1135   
;;;1136     /* Select the External clock mode1 */
;;;1137     TIM1->SMCR |= TIM1_SlaveMode_External1;
000028  4803              LDR      r0,|L87.56|
00002a  8800              LDRH     r0,[r0,#0]
00002c  f0400007          ORR      r0,r0,#7
000030  4901              LDR      r1,|L87.56|
000032  8008              STRH     r0,[r1,#0]
;;;1138   }
000034  bd70              POP      {r4-r6,pc}
;;;1139   /*******************************************************************************
                          ENDP

000036  0000              DCW      0x0000
                  |L87.56|
                          DCD      0x40012c08

                          AREA ||i.TIM1_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM1_TimeBaseInit PROC
;;;306    *******************************************************************************/
;;;307    void TIM1_TimeBaseInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct)
000000  8881              LDRH     r1,[r0,#4]
;;;308    {
;;;309     /* Check the parameters */
;;;310      assert_param(IS_TIM1_COUNTER_MODE(TIM1_TimeBaseInitStruct->TIM1_CounterMode));
;;;311      assert_param(IS_TIM1_CKD_DIV(TIM1_TimeBaseInitStruct->TIM1_ClockDivision));
;;;312    
;;;313      /* Set the Autoreload value */
;;;314      TIM1->ARR = TIM1_TimeBaseInitStruct->TIM1_Period ;
000002  4a0e              LDR      r2,|L88.60|
000004  8011              STRH     r1,[r2,#0]
;;;315    
;;;316      /* Set the Prescaler value */
;;;317      TIM1->PSC = TIM1_TimeBaseInitStruct->TIM1_Prescaler;
000006  8801              LDRH     r1,[r0,#0]
000008  1f12              SUBS     r2,r2,#4
00000a  8011              STRH     r1,[r2,#0]
;;;318    
;;;319      /* Select the Counter Mode and set the clock division */
;;;320      TIM1->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
00000c  490b              LDR      r1,|L88.60|
00000e  392c              SUBS     r1,r1,#0x2c
000010  8809              LDRH     r1,[r1,#0]
000012  f001019f          AND      r1,r1,#0x9f
000016  4a09              LDR      r2,|L88.60|
000018  3a2c              SUBS     r2,r2,#0x2c
00001a  8011              STRH     r1,[r2,#0]
;;;321      TIM1->CR1 |= (u32)TIM1_TimeBaseInitStruct->TIM1_ClockDivision |
00001c  88c1              LDRH     r1,[r0,#6]
00001e  8842              LDRH     r2,[r0,#2]
000020  4311              ORRS     r1,r1,r2
000022  4a06              LDR      r2,|L88.60|
000024  3a2c              SUBS     r2,r2,#0x2c
000026  8812              LDRH     r2,[r2,#0]
000028  4311              ORRS     r1,r1,r2
00002a  4a04              LDR      r2,|L88.60|
00002c  3a2c              SUBS     r2,r2,#0x2c
00002e  8011              STRH     r1,[r2,#0]
;;;322                   TIM1_TimeBaseInitStruct->TIM1_CounterMode;
;;;323    
;;;324      /* Set the Repetition Counter value */
;;;325      TIM1->RCR = TIM1_TimeBaseInitStruct->TIM1_RepetitionCounter;
000030  7a01              LDRB     r1,[r0,#8]
000032  4a02              LDR      r2,|L88.60|
000034  1d12              ADDS     r2,r2,#4
000036  8011              STRH     r1,[r2,#0]
;;;326    }
000038  4770              BX       lr
;;;327    
                          ENDP

00003a  0000              DCW      0x0000
                  |L88.60|
                          DCD      0x40012c2c

                          AREA ||i.TIM1_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM1_TimeBaseStructInit PROC
;;;768    *******************************************************************************/
;;;769    void TIM1_TimeBaseStructInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;770    {
;;;771      /* Set the default configuration */
;;;772      TIM1_TimeBaseInitStruct->TIM1_Period = TIM1_Period_Reset_Mask;
000004  8081              STRH     r1,[r0,#4]
;;;773      TIM1_TimeBaseInitStruct->TIM1_Prescaler = TIM1_Prescaler_Reset_Mask;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;774      TIM1_TimeBaseInitStruct->TIM1_ClockDivision = TIM1_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;775      TIM1_TimeBaseInitStruct->TIM1_CounterMode = TIM1_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;776      TIM1_TimeBaseInitStruct->TIM1_RepetitionCounter = TIM1_RepetitionCounter_Reset_Mask;
00000e  7201              STRB     r1,[r0,#8]
;;;777    }
000010  4770              BX       lr
;;;778    
                          ENDP


                          AREA ||i.TIM1_UpdateDisableConfig||, CODE, READONLY, ALIGN=2

                  TIM1_UpdateDisableConfig PROC
;;;1180   *******************************************************************************/
;;;1181   void TIM1_UpdateDisableConfig(FunctionalState Newstate)
000000  4901              LDR      r1,|L90.8|
;;;1182   {
;;;1183     /* Check the parameters */
;;;1184     assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;1185   
;;;1186     /* Set or Reset the UDIS Bit */
;;;1187     *(vu32 *) CR1_UDIS_BB = (u16)Newstate;
000002  6048              STR      r0,[r1,#4]
;;;1188   }
000004  4770              BX       lr
;;;1189   
                          ENDP

000006  0000              DCW      0x0000
                  |L90.8|
                          DCD      0x42258000

                          AREA ||i.TIM1_UpdateRequestConfig||, CODE, READONLY, ALIGN=2

                  TIM1_UpdateRequestConfig PROC
;;;1200   *******************************************************************************/
;;;1201   void TIM1_UpdateRequestConfig(u8 TIM1_UpdateSource)
000000  4901              LDR      r1,|L91.8|
;;;1202   {
;;;1203     /* Check the parameters */
;;;1204     assert_param(IS_TIM1_UPDATE_SOURCE(TIM1_UpdateSource));
;;;1205   
;;;1206     /* Set or Reset the URS Bit */
;;;1207     *(vu32 *) CR1_URS_BB = TIM1_UpdateSource;
000002  6088              STR      r0,[r1,#8]
;;;1208   }
000004  4770              BX       lr
;;;1209   
                          ENDP

000006  0000              DCW      0x0000
                  |L91.8|
                          DCD      0x42258000
